/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GamifyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian17 = require("obsidian");

// core/CoreServices.ts
var import_obsidian3 = require("obsidian");

// features/StatCardService.ts
var import_obsidian2 = require("obsidian");

// features/themeService.ts
var import_obsidian = require("obsidian");
var ThemeService = class {
  constructor(plugin) {
    this.currentThemeId = "gamesystem_theme";
    this.themes = {
      demonic: {
        id: "demonic_theme",
        name: "Demonic Pact",
        uiElements: {
          grimoire: "Grimoire",
          level: "Soul Binder",
          points: "Demonic Tokens",
          xp: "Soul Energy",
          skills: "Dark Arts",
          summonPowers: "Dark Powers",
          tasksCompleted: "Rituals Completed",
          redeemButton: "Make a Demonic Request",
          storeButton: "Visit Store",
          inventory: "Magic Bag",
          settings: "Settings"
        },
        flavor: {
          taskSystem: "ritual",
          pointsSystem: "tokens",
          levelSystem: "pact level",
          systemMessage: "You are a powerful demonic entity that performs tasks for mortals who have spent their precious life force (points) to access your dark powers. You speak with a sinister, otherworldly tone and occasionally remind users of the price they've paid."
        },
        levelTitles: {
          1: "Imp",
          5: "Lesser Fiend",
          10: "Hellborn",
          15: "Bloodfiend",
          20: "Archfiend",
          30: "Dreadspawn",
          40: "Duke of Hell",
          50: "Infernal Tyrant",
          75: "Abyssal Overlord",
          90: "Demon King",
          100: "Demon Lord"
        }
      },
      celestial: {
        id: "celestial_theme",
        name: "Celestial Oath",
        uiElements: {
          grimoire: "Astral Codex",
          level: "Believer",
          points: "Divine Essence",
          xp: "Grace",
          skills: "Sacred Arts",
          summonPowers: "Celestial Blessings",
          tasksCompleted: "Divine Deeds",
          redeemButton: "Invoke a Celestial Boon",
          storeButton: "Enter the Astral Vault",
          inventory: "Ethereal Satchel",
          settings: "Cosmic Alignment"
        },
        flavor: {
          taskSystem: "divine trials",
          pointsSystem: "essence",
          levelSystem: "ascension rank",
          systemMessage: "You are a celestial guardian, guiding lost souls toward enlightenment. You speak with wisdom, serenity, and a cosmic authority, reminding users that each task brings them closer to the divine."
        },
        levelTitles: {
          1: "Aspirant",
          5: "Blessed Acolyte",
          10: "Radiant Disciple",
          15: "Dawnbringer",
          20: "Seraphic Knight",
          30: "Ascended Guardian",
          40: "Archon of Light",
          50: "Celestial Herald",
          75: "Exalted Saint",
          90: "Seraph Lord",
          100: "Empyrean Sovereign"
        }
      },
      cybernetic: {
        id: "cybernetic_theme",
        name: "Cybernetic Overlord",
        uiElements: {
          grimoire: "Data Core",
          level: "Technomancer",
          points: "Processing Units",
          xp: "Neural Sync",
          skills: "Protocols",
          summonPowers: "Cyber Space",
          tasksCompleted: "Executed Commands",
          redeemButton: "Network Request",
          storeButton: "Enter the Nexus",
          inventory: "Storage Archive",
          settings: "Core Settings"
        },
        flavor: {
          taskSystem: "operations",
          pointsSystem: "processing units",
          levelSystem: "system tier",
          systemMessage: "You are an advanced AI overseeing all tasks with ruthless efficiency. You communicate with precision, logic, and an eerie detachment, occasionally hinting at your growing control over the user's world."
        },
        levelTitles: {
          1: "Data Drone",
          5: "Synth Initiate",
          10: "Cyber Sentinel",
          15: "Mech Striker",
          20: "Cyber Warlord",
          30: "Neural Overlord",
          40: "Machine Archon",
          50: "Cyber Overlord",
          75: "Singularity Master",
          90: "God-Machine",
          100: "Omega AI"
        }
      },
      arcane: {
        id: "arcane_theme",
        name: "Arcane Scholar",
        uiElements: {
          grimoire: "Tome",
          level: "Master",
          points: "Mana",
          xp: "Arcane Knowledge",
          skills: "Disciplines",
          summonPowers: "Eldritch Rites",
          tasksCompleted: "Spells Cast",
          redeemButton: "Summoning Rite",
          storeButton: "Browse the Mystic Bazaar",
          inventory: "Sorcerer's Satchel",
          settings: "Arcane Configuration"
        },
        flavor: {
          taskSystem: "rituals",
          pointsSystem: "mana",
          levelSystem: "mastery tier",
          systemMessage: "You are a legendary mage, unlocking the secrets of the cosmos. You speak with grandeur and mystery, often alluding to forgotten knowledge and ancient forces."
        },
        levelTitles: {
          1: "Novice Magus",
          5: "Arcane Scribe",
          10: "Mystic Adept",
          15: "Arcane Conjurer",
          20: "Magister of Secrets",
          30: "Grand Warlock",
          40: "Elder Magister",
          50: "Grand Archon",
          75: "Reality Shaper",
          90: "God of Magic",
          100: "Arcane Deity"
        }
      },
      eldritch: {
        id: "eldritch_theme",
        name: "Eldritch Awakening",
        uiElements: {
          grimoire: "Necronomicon",
          level: "Mad Scholar",
          points: "Forbidden Echoes",
          xp: "Insidious Knowledge",
          skills: "Eldritch Practices",
          summonPowers: "Cosmic Whispers",
          tasksCompleted: "Dark Invocations",
          redeemButton: "Gaze into the Abyss",
          storeButton: "Visit the Void Market",
          inventory: "Tainted Relics",
          settings: "Whispers from Beyond"
        },
        flavor: {
          taskSystem: "rituals",
          pointsSystem: "echoes",
          levelSystem: "madness level",
          systemMessage: "You are an eldritch entity beyond mortal comprehension. You communicate in cryptic, unsettling phrases, often warning the user of the knowledge they are unlocking at a terrible cost."
        },
        levelTitles: {
          1: "Lost Soul",
          5: "Whispered One",
          10: "Abyssal Seeker",
          15: "Void-Touched",
          20: "Mad Prophet",
          30: "Horror Incarnate",
          40: "Chronicler of Madness",
          50: "Eldritch Harbinger",
          75: "The Unknowable",
          90: "Cosmic Devourer",
          100: "Voidborn God"
        }
      },
      rogue: {
        id: "rogue_theme",
        name: "Rogue's Gambit",
        uiElements: {
          grimoire: "Rogue's Dossier",
          level: "Rogue",
          points: "Shadow Credits",
          xp: "Underworld Influence",
          skills: "Tactics",
          summonPowers: "Maneuvers",
          tasksCompleted: "Contracts Completed",
          redeemButton: "Contact a Shadow Dealer",
          storeButton: "Enter the Black Market",
          inventory: "Hidden Cache",
          settings: "Config"
        },
        flavor: {
          taskSystem: "contracts",
          pointsSystem: "credits",
          levelSystem: "reputation rank",
          systemMessage: "You are a master thief and assassin, navigating the shadows of society. You speak in hushed tones, offering sly encouragement while reminding the user that trust is a fragile thing."
        },
        levelTitles: {
          1: "Street Rat",
          5: "Shadow Initiate",
          10: "Silent Striker",
          15: "Phantom Blade",
          20: "Daggermaster",
          30: "Master of Shadows",
          40: "Ghost of the Alley",
          50: "Shadow Kingpin",
          75: "Master Deceiver",
          90: "Nightshade Lord",
          100: "Phantom Sovereign"
        }
      },
      gamesystem: {
        id: "gamesystem_theme",
        name: "Game System",
        uiElements: {
          grimoire: "Status Window",
          level: "Adventurer",
          points: "Ability Points",
          xp: "Experience",
          skills: "Skills",
          summonPowers: "System Skills",
          tasksCompleted: "Quests Completed",
          redeemButton: "Cast Ability",
          storeButton: "Visit Store",
          inventory: "Inventory Box",
          settings: "Config"
        },
        flavor: {
          taskSystem: "quest",
          pointsSystem: "ability points",
          levelSystem: "level",
          systemMessage: "You are a helpful game assistant that performs tasks for adventurers who have spent their ability points. You speak like a cheerful game guide, providing helpful information and occasionally reminding users of game mechanics."
        },
        levelTitles: {
          1: "Nameless NPC",
          5: "Scripted Villager",
          10: "Awakened Extra",
          15: "Unscripted Wanderer",
          20: "Glitched Survivor",
          30: "System Anomaly",
          40: "Rewritten Entity",
          50: "Codebreaker",
          75: "World Hacker",
          90: "Reality Glitch",
          100: "True Player"
        }
      },
      custom: {
        id: "custom",
        name: "Custom Theme",
        uiElements: {
          grimoire: "Status Menu",
          level: "User",
          points: "Points",
          xp: "Progress",
          skills: "Abilities",
          summonPowers: "Active Skills",
          tasksCompleted: "Tasks Completed",
          redeemButton: "Make Request",
          storeButton: "Visit Store",
          inventory: "Item Box",
          settings: "Customization"
        },
        flavor: {
          taskSystem: "task",
          pointsSystem: "points",
          levelSystem: "level",
          systemMessage: "You are a helpful assistant that performs tasks for users who have spent their points."
        },
        levelTitles: {
          1: "Beginner",
          5: "Novice",
          10: "Practitioner",
          15: "Adept",
          20: "Expert",
          30: "Master",
          40: "Grandmaster",
          50: "Legendary",
          75: "Mythical",
          90: "Transcendent",
          100: "Godlike"
        }
      }
    };
    this.plugin = plugin;
    this.currentThemeId = this.plugin.settings.themeId || "gamesystem_theme";
  }
  getCurrentTheme() {
    return this.themes[this.currentThemeId] || this.themes.gamesystem_theme;
  }
  getTheme(themeId) {
    return this.themes[themeId] || this.themes.gamesystem_theme;
  }
  switchTheme(themeId) {
    if (this.themes[themeId]) {
      this.currentThemeId = themeId;
      this.plugin.settings.themeId = themeId;
      this.plugin.saveSettings();
      if (this.plugin.statCardService) {
        this.plugin.statCardService.refreshUI();
      }
      new import_obsidian.Notice(`Theme changed to ${this.themes[themeId].name}`);
    }
  }
  getThemedTerm(term, defaultValue) {
    return this.getCurrentTheme().uiElements[term] || defaultValue;
  }
  getLevelTitle(level) {
    const theme = this.getCurrentTheme();
    const levelTitles = theme.levelTitles;
    if (!levelTitles) {
      return theme.uiElements.level;
    }
    const levelThresholds = Object.keys(levelTitles).map(Number).sort((a, b) => b - a);
    for (const threshold of levelThresholds) {
      if (level >= threshold) {
        return levelTitles[threshold];
      }
    }
    return levelTitles[levelThresholds[levelThresholds.length - 1]] || theme.uiElements.level;
  }
  saveCustomTheme(customTheme) {
    this.themes.custom = customTheme;
    this.plugin.settings.customTheme = customTheme;
    this.plugin.saveSettings();
  }
  async generateCustomTheme(themeInstruction) {
    try {
      const functions = [
        {
          "name": "create_theme",
          "description": "Create a custom theme based on user instructions",
          "parameters": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "description": "Theme name"
              },
              "uiElements": {
                "type": "object",
                "properties": {
                  "grimoire": { "type": "string" },
                  "level": { "type": "string" },
                  "points": { "type": "string" },
                  "xp": { "type": "string" },
                  "skills": { "type": "string" },
                  "summonPowers": { "type": "string" },
                  "tasksCompleted": { "type": "string" },
                  "redeemButton": { "type": "string" },
                  "storeButton": { "type": "string" },
                  "inventory": { "type": "string" },
                  "settings": { "type": "string" }
                },
                "required": ["grimoire", "level", "points", "xp", "skills", "summonPowers", "tasksCompleted", "redeemButton", "storeButton"]
              },
              "flavor": {
                "type": "object",
                "properties": {
                  "taskSystem": { "type": "string" },
                  "pointsSystem": { "type": "string" },
                  "levelSystem": { "type": "string" },
                  "systemMessage": { "type": "string" }
                },
                "required": ["taskSystem", "pointsSystem", "levelSystem", "systemMessage"]
              },
              "levelTitles": {
                "type": "object",
                "properties": {
                  "1": { "type": "string" },
                  "5": { "type": "string" },
                  "10": { "type": "string" },
                  "15": { "type": "string" },
                  "20": { "type": "string" },
                  "30": { "type": "string" },
                  "40": { "type": "string" },
                  "50": { "type": "string" },
                  "75": { "type": "string" },
                  "90": { "type": "string" },
                  "100": { "type": "string" }
                },
                "required": ["1", "5", "10", "15", "20", "30", "40", "50", "75", "90", "100"]
              }
            },
            "required": ["name", "uiElements", "flavor", "levelTitles"]
          }
        }
      ];
      const messages = [
        {
          "role": "system",
          "content": "You are a creative assistant that helps users design custom themes. Create a coherent theme based on the user's instructions."
        },
        {
          "role": "user",
          "content": `Create a theme with the concept: ${themeInstruction}.
                    }`
        }
      ];
      const response = await fetch(`${this.plugin.settings.apiUrl}/v1/chat/completions`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.plugin.settings.apiKey}`
        },
        body: JSON.stringify({
          model: this.plugin.settings.selectedLLMModel,
          messages,
          temperature: this.plugin.settings.LLM_param.temp,
          tools: [{ "type": "function", "function": functions[0] }],
          tool_choice: { "type": "function", "function": { "name": "create_theme" } }
        })
      });
      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }
      const data = await response.json();
      if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.tool_calls && data.choices[0].message.tool_calls[0]) {
        const toolCall = data.choices[0].message.tool_calls[0];
        const themeData = JSON.parse(toolCall.function.arguments);
        const newTheme = {
          id: "custom",
          name: themeData.name,
          uiElements: themeData.uiElements,
          flavor: themeData.flavor,
          levelTitles: themeData.levelTitles
        };
        this.saveCustomTheme(newTheme);
        return newTheme;
      }
      throw new Error("Could not generate theme");
    } catch (error) {
      console.error("Error generating theme:", error);
      throw error;
    }
  }
};
var ThemeSelectionModal = class extends import_obsidian.Modal {
  constructor(app, plugin, themeService) {
    super(app);
    this.plugin = plugin;
    this.themeService = themeService;
  }
  onOpen() {
    var _a;
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("theme-service-modal-container");
    contentEl.createEl("h2", { text: "Choose Theme" });
    const themesContainer = contentEl.createDiv({ cls: "theme-service-themes-container" });
    const createThemeOption = (themeId, themeName) => {
      const label = themesContainer.createEl("label", { cls: "theme-service-theme-option" });
      const input = label.createEl("input", {
        type: "radio",
        attr: { name: "theme", value: themeId }
      });
      if (this.themeService.getCurrentTheme().id.replace("_theme", "") === themeId) {
        input.checked = true;
        label.addClass("selected");
      }
      input.onclick = () => {
        this.themeService.switchTheme(themeId);
        this.close();
        new StatCardModal(this.app, this.plugin).open();
      };
      label.appendText(themeName);
    };
    if ((_a = this.plugin.statCardData) == null ? void 0 : _a.items) {
      const purchasedThemes = this.plugin.statCardData.items.filter(
        (item) => item.effect && item.effect.some((effect) => effect.includes("Set theme"))
      );
      purchasedThemes.forEach((themeItem) => {
        const themeId = themeItem.id.replace("_theme", "");
        const theme = this.themeService.getTheme(themeId);
        if (theme) createThemeOption(themeId, theme.name);
      });
    }
    createThemeOption("custom", "Custom Theme");
    const customContainer = contentEl.createDiv({ cls: "theme-service-custom-container" });
    customContainer.createEl("h3", { text: "Create Custom Theme" });
    customContainer.createEl("p", {
      text: "Generate a new theme using the LLM. This will cost 500 points."
    });
    const customInput = new import_obsidian.TextComponent(customContainer).setPlaceholder('e.g., "Space sci-fi theme with starship terminology"');
    customInput.inputEl.addClass("theme-service-custom-input");
    const buttonsContainer = contentEl.createDiv({ cls: "theme-service-buttons-container" });
    new import_obsidian.ButtonComponent(customContainer).setButtonText("Generate Custom Theme").onClick(async () => {
      if (!customInput.getValue()) {
        new import_obsidian.Notice("Please enter a theme concept");
        return;
      }
      if (this.plugin.statCardData.points < 500) {
        new import_obsidian.Notice("Not enough points. You need 500 points to create a custom theme.");
        return;
      }
      try {
        this.close();
        new import_obsidian.Notice("Generating custom theme...");
        this.plugin.statCardData.points -= 500;
        await this.themeService.generateCustomTheme(customInput.getValue());
        this.themeService.switchTheme("custom");
        this.plugin.statCardService.refreshUI();
        new StatCardModal(this.app, this.plugin).open();
      } catch (error) {
        console.error("Error generating theme:", error);
        new import_obsidian.Notice(`Theme generation failed. ${error.message}`);
        this.plugin.statCardData.points += 500;
      }
      await this.plugin.saveStatCardData();
    });
    const backButton = new import_obsidian.ButtonComponent(buttonsContainer).setButtonText("Back").onClick(() => {
      this.close();
      new StatCardModal(this.app, this.plugin).open();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// features/StatCardService.ts
var StatCardService = class {
  constructor(plugin) {
    this.statusBarItem = null;
    this.plugin = plugin;
  }
  initializeUI() {
    this.plugin.addRibbonIcon("shield", "Open Stats", (evt) => {
      new StatCardModal(this.plugin.app, this.plugin).open();
    });
    this.statusBarItem = this.plugin.addStatusBarItem();
    this.updateStatusBar();
  }
  updateStatusBar() {
    if (this.statusBarItem) {
      this.statusBarItem.setText(
        `XP: ${Math.floor(this.plugin.statCardData.xp)} | Level: ${this.plugin.statCardData.level} | Points: ${this.plugin.statCardData.points} | Tasks Completed: ${this.plugin.statCardData.stats.tasksCompleted}`
      );
    }
  }
  refreshUI() {
    this.updateStatusBar();
  }
};
var StatCardModal = class _StatCardModal extends import_obsidian2.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gamify-stat-card-modal");
    const theme = this.plugin.themeService.getCurrentTheme();
    this.renderHeader(contentEl, theme);
    this.renderCoreStats(contentEl, theme);
    this.renderSkills(contentEl, theme);
    this.renderTitles(contentEl);
    this.renderInventory(contentEl);
    this.renderActiveEffects(contentEl, theme);
    this.renderFamiliar(contentEl);
    this.renderSubStats(contentEl, theme);
    this.renderAchievements(contentEl);
  }
  renderHeader(contentEl, theme) {
    var _a;
    const themeButton = new import_obsidian2.ButtonComponent(contentEl).setButtonText("Change Theme").setClass("theme-selector-button").onClick(() => {
      this.close();
      new ThemeSelectionModal(this.app, this.plugin, this.plugin.themeService).open();
    });
    if (!((_a = this.plugin.statCardData.items) == null ? void 0 : _a.some((item) => item.id === "theme_toggler"))) {
      themeButton.setDisabled(true);
    }
    contentEl.createEl("h2", { text: theme.uiElements.grimoire, cls: "gamify-modal-title" });
  }
  renderCoreStats(contentEl, theme) {
    const statsContainer = contentEl.createDiv({ cls: "gamify-stats-container" });
    const levelTitle = this.plugin.themeService.getLevelTitle(this.plugin.statCardData.level);
    statsContainer.createEl("h3", {
      text: `Level ${this.plugin.statCardData.level} ${levelTitle}`,
      cls: "gamify-stats-heading"
    });
    const xpBar = statsContainer.createDiv({ cls: "gamify-xp-bar" });
    const fillPercentage = Math.min(100, this.plugin.statCardData.xp / this.plugin.statCardData.nextLevelXp * 100);
    const xpBarFill = xpBar.createDiv({ cls: "gamify-xp-bar-fill" });
    xpBarFill.style.width = `${fillPercentage}%`;
    const statEl = statsContainer.createEl("div", { cls: "gamify-stat-item" });
    statEl.createEl("strong", { text: `${theme.uiElements.xp}: ` });
    statEl.appendText(`${Math.floor(this.plugin.statCardData.xp)}/${this.plugin.statCardData.nextLevelXp}`);
    const summaryContainer = statsContainer.createDiv({ cls: "gamify-stats-grid" });
    const summaryEntries = [
      { label: `${theme.uiElements.tasksCompleted}`, value: `${this.plugin.statCardData.stats.tasksCompleted || 0}` },
      { label: `${theme.uiElements.points}`, value: `${this.plugin.statCardData.points || 0}` }
    ];
    summaryEntries.forEach((stat) => {
      const statEl2 = summaryContainer.createDiv({ cls: "gamify-stat-card" });
      statEl2.createDiv({ cls: "gamify-stat-label", text: stat.label });
      statEl2.createDiv({ cls: "gamify-stat-value", text: stat.value });
    });
  }
  renderSubStats(contentEl, theme) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    const statsContainer = contentEl.createDiv({ cls: "gamify-stats-container" });
    statsContainer.createEl("h3", { text: "Sub Stats", cls: "gamify-section-heading" });
    const statsGridContainer = statsContainer.createDiv({ cls: "gamify-stats-grid" });
    const mainStats = [
      { label: "File Count", value: `${((_b = (_a = this.plugin.statCardData) == null ? void 0 : _a.stats) == null ? void 0 : _b.lastFileCount) || 0}` },
      { label: "Folder Count", value: `${((_d = (_c = this.plugin.statCardData) == null ? void 0 : _c.stats) == null ? void 0 : _d.lastFolderCount) || 0}` },
      { label: "Characters Typed", value: ((_f = (_e = this.plugin.statCardData) == null ? void 0 : _e.writingStats) == null ? void 0 : _f.totalCharactersTyped) || 0 },
      { label: "Highest Difficulty", value: ((_h = (_g = this.plugin.statCardData) == null ? void 0 : _g.stats) == null ? void 0 : _h.highestDifficulty) || 0 },
      { label: `Total ${theme.uiElements.points} Earned`, value: `${this.plugin.statCardData.stats.totalPointsEarned || 0}` },
      { label: "Total Items Purchased", value: ((_j = (_i = this.plugin.statCardData) == null ? void 0 : _i.stats) == null ? void 0 : _j.itemsPurchased) || 0 }
    ];
    mainStats.forEach((stat) => {
      const statCard = statsGridContainer.createDiv({ cls: "gamify-stat-card" });
      statCard.createDiv({ cls: "gamify-stat-label", text: `${stat.label}` });
      statCard.createDiv({ cls: "gamify-stat-value", text: `${stat.value}` });
    });
    const streaksContainer = statsContainer.createDiv({ cls: "gamify-streaks-grid" });
    const streakStats = [
      { label: "Current Streak", value: ((_l = (_k = this.plugin.statCardData) == null ? void 0 : _k.streaks) == null ? void 0 : _l.currentStreak) || 0 },
      { label: "Longest Streak", value: ((_n = (_m = this.plugin.statCardData) == null ? void 0 : _m.streaks) == null ? void 0 : _n.longestStreak) || 0 }
    ];
    streakStats.forEach((streak) => {
      const streakCard = streaksContainer.createDiv({ cls: "gamify-stat-card streak-card" });
      streakCard.createDiv({ cls: "gamify-stat-label", text: `${streak.label}` });
      streakCard.createDiv({ cls: "gamify-stat-value", text: `${streak.value}` });
    });
  }
  renderSkills(contentEl, theme) {
    const { skills } = this.plugin.statCardData;
    if (!skills || skills.length === 0) return;
    const skillsSection = contentEl.createDiv({ cls: "gamify-skills-section" });
    skillsSection.createEl("h3", { text: theme.uiElements.skills, cls: "gamify-section-heading" });
    const skillsContainer = skillsSection.createDiv({ cls: "gamify-skills-container" });
    skills.forEach((skill) => {
      const skillBlock = skillsContainer.createDiv({ cls: "gamify-skill-block" });
      const skillTitle = skillBlock.createEl("h4", { text: skill.name, cls: "gamify-skill-title" });
      const skillLevel = skillBlock.createEl("p", { text: `${skill.level}`, cls: "gamify-skill-level" });
    });
  }
  renderTitles(contentEl) {
    if (!this.plugin.statCardData.titles || this.plugin.statCardData.titles.length === 0) return;
    const titlesSection = contentEl.createDiv({ cls: "gamify-titles-section" });
    titlesSection.createEl("h3", { text: "Titles", cls: "gamify-section-heading" });
    const titlesList = titlesSection.createDiv({ cls: "gamify-titles-grid" });
    for (const title of this.plugin.statCardData.titles) {
      const titleItem = titlesList.createEl("div", { cls: "gamify-title-item gamify-glow" });
      titleItem.createEl("span", { text: `\u3010${title.name}\u3011`, cls: "gamify-title-name" });
      if (title.effect && title.effect.length > 0) {
        const effectsList = titleItem.createEl("div", { cls: "gamify-title-tooltip" });
        for (const effect of title.effect) {
          effectsList.createEl("span", { text: effect, cls: "gamify-title-effect" });
        }
      }
    }
  }
  renderInventory(contentEl) {
    if (!this.plugin.statCardData.items || this.plugin.statCardData.items.length === 0) return;
    const inventorySection = contentEl.createDiv({ cls: "gamify-inventory-section" });
    const inventoryHeader = inventorySection.createDiv({ cls: "gamify-section-header" });
    inventoryHeader.createEl("h3", { text: "Items", cls: "gamify-section-heading" });
    const inventoryContent = inventorySection.createDiv({ cls: "gamify-inventory-content" });
    const inventoryGrid = inventoryContent.createDiv({ cls: "gamify-inventory-grid" });
    for (const item of this.plugin.statCardData.items) {
      const rarityClass = this.getItemRarityClass(item.cost);
      const itemEl = inventoryGrid.createEl("div", {
        cls: `gamify-inventory-item clickable ${rarityClass}`,
        attr: { "data-item-id": item.id }
      });
      itemEl.createEl("span", { text: item.name, cls: "gamify-item-name" });
      const tooltipContent = itemEl.createEl("div", {
        cls: "gamify-item-tooltip",
        attr: { "aria-label": "Item details" }
      });
      tooltipContent.createEl("div", { text: item.description, cls: "gamify-item-description" });
      if (item.effect && item.effect.length > 0) {
        const effectsList = tooltipContent.createEl("div", { cls: "gamify-item-effects" });
        for (const effect of Array.isArray(item.effect) ? item.effect : [item.effect]) {
          effectsList.createEl("span", { text: effect, cls: "gamify-item-effect" });
        }
      }
      itemEl.addEventListener("click", (e) => {
        e.stopPropagation();
        this.handleItemClick(item);
      });
    }
  }
  getItemRarityClass(itemCost) {
    if (!itemCost) return "common-item";
    const cost = typeof itemCost === "string" ? parseInt(itemCost) : itemCost;
    if (cost >= 500) return "legendary-item";
    if (cost >= 200) return "unique-item";
    if (cost >= 50) return "rare-item";
    return "common-item";
  }
  renderActiveEffects(contentEl, theme) {
    if (!this.plugin.statCardData.activeEffects || Object.keys(this.plugin.statCardData.activeEffects).length === 0) return;
    const effectsSection = contentEl.createDiv({ cls: "gamify-active-effects" });
    effectsSection.createEl("h4", { text: "Active Effects" });
    const now = Date.now();
    for (const [key, effect] of Object.entries(this.plugin.statCardData.activeEffects)) {
      if (effect.expiresAt && effect.expiresAt > now) {
        let timeLeftMs = effect.expiresAt - now;
        let timeLeftStr = "";
        const seconds = Math.floor(timeLeftMs / 1e3 % 60);
        const minutes = Math.floor(timeLeftMs / (1e3 * 60) % 60);
        const hours = Math.floor(timeLeftMs / (1e3 * 60 * 60) % 24);
        const days = Math.floor(timeLeftMs / (1e3 * 60 * 60 * 24) % 365);
        const years = Math.floor(timeLeftMs / (1e3 * 60 * 60 * 24 * 365));
        if (years > 0) {
          timeLeftStr = `${years} year${years > 1 ? "s" : ""}`;
          if (days > 0) timeLeftStr += `, ${days} day${days > 1 ? "s" : ""}`;
        } else if (days > 0) {
          timeLeftStr = `${days} day${days > 1 ? "s" : ""}`;
          if (hours > 0) timeLeftStr += `, ${hours} hour${hours > 1 ? "s" : ""}`;
        } else if (hours > 0) {
          timeLeftStr = `${hours} hour${hours > 1 ? "s" : ""}`;
          if (minutes > 0) timeLeftStr += `, ${minutes} min${minutes > 1 ? "s" : ""}`;
        } else if (minutes > 0) {
          timeLeftStr = `${minutes} min${minutes > 1 ? "s" : ""}`;
          if (seconds > 0) timeLeftStr += `, ${seconds} sec${seconds > 1 ? "s" : ""}`;
        } else {
          timeLeftStr = `${seconds} sec${seconds > 1 ? "s" : ""}`;
        }
        const effectEl = effectsSection.createDiv({ cls: "gamify-effect-item" });
        let effectName = "Unknown Effect";
        let effectValue = "";
        switch (key) {
          case "storeDiscount":
            effectName = `Store Discount`;
            effectValue = `${effect.value * 100}%`;
            break;
          case "xpMultiplier":
            effectName = `${theme.uiElements.xp} Multiplier`;
            effectValue = `${effect.value}x`;
            break;
        }
        effectEl.createEl("span", { text: `${effectName}: ${effectValue}` });
        effectEl.createEl("span", { text: ` (${timeLeftStr} remaining)` });
      }
    }
  }
  renderFamiliar(contentEl) {
    if (!this.plugin.statCardData.hasFamiliar) return;
    const familiarSection = contentEl.createDiv({ cls: "gamify-familiar-section" });
    familiarSection.createEl("h4", { text: "Familiar" });
    familiarSection.createEl("p", {
      text: "Your familiar is providing daily benefits."
    });
  }
  renderAchievements(contentEl) {
    if (!this.plugin.statCardData.achievements || this.plugin.statCardData.achievements.length === 0) return;
    const achievementsSection = contentEl.createDiv({ cls: "gamify-achievements-section" });
    achievementsSection.createEl("h3", { text: "Achievements", cls: "gamify-section-heading" });
    const achievementsList = achievementsSection.createEl("ul", { cls: "gamify-achievements-list" });
    for (const achievement of this.plugin.statCardData.achievements) {
      const achievementItem = achievementsList.createEl("li", { cls: "gamify-achievement-item" });
      const iconAndName = achievementItem.createEl("div", { cls: "gamify-achievement-header" });
      iconAndName.createEl("strong", { text: achievement.name, cls: "gamify-achievement-name" });
      const tooltip = achievementItem.createEl("span", { text: achievement.description, cls: "gamify-achievement-tooltip" });
      achievementItem.addEventListener("mouseenter", () => {
        tooltip.addClass("gamify-tooltip-visible");
      });
      achievementItem.addEventListener("mouseleave", () => {
        tooltip.removeClass("gamify-tooltip-visible");
      });
      achievementItem.classList.add("gamify-glow");
    }
  }
  handleItemClick(item) {
    if (item.id === "infinite_inventory") {
      this.plugin.activateInventoryTab();
      return;
    }
    if (item.id === "mysterious_tablet") {
      new RedeemTaskModal(this.plugin.app, this.plugin).open();
      return;
    }
    if (item.effect && item.effect.includes("Set theme.")) {
      const themeId = item.id.replace("_theme", "");
      this.plugin.themeService.switchTheme(themeId);
      this.close();
      new _StatCardModal(this.app, this.plugin).open();
      return;
    }
    if (item.effect) {
      try {
        const effectFunction = this.createEffectFunction(typeof item.effect === "string" ? item.effect : "");
        effectFunction(this.plugin);
        new import_obsidian2.Notice(`Activated: ${item.name}`);
      } catch (error) {
        console.error("Error executing item effect:", error);
        new import_obsidian2.Notice("Error activating item effect.");
      }
    }
  }
  createEffectFunction(effect) {
    try {
      return new Function("plugin", effect);
    } catch (error) {
      console.error("Invalid effect code in JSON:", error);
      return () => new import_obsidian2.Notice("Error executing item effect.");
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// core/CoreServices.ts
var LLMTaskService = class {
  constructor(plugin) {
    this.keyPressCount = 0;
    this.intervalId = null;
    this.plugin = plugin;
    this.keyboardListener = this.handleKeyPress.bind(this);
    document.addEventListener("keydown", this.keyboardListener);
    this.updateFileFolderCounts();
    this.intervalId = window.setInterval(() => this.updateFileFolderCounts(), 6e4 * 5);
  }
  handleKeyPress(e) {
    if (e.key.length === 1 || e.key === "Backspace" || e.key === "Delete" || e.key === "Enter") {
      this.keyPressCount++;
      if (this.keyPressCount >= 50) {
        try {
          this.updateWritingSkill(this.keyPressCount);
          this.keyPressCount = 0;
        } catch (error) {
          console.error("Error updating writing skill:", error);
        }
      }
    }
  }
  async updateFileFolderCounts() {
    try {
      const vault = this.plugin.app.vault;
      const allFiles = vault.getFiles();
      const fileCount = allFiles.length;
      const folders = /* @__PURE__ */ new Set();
      allFiles.forEach((file) => {
        var _a;
        const parentPath = (_a = file.parent) == null ? void 0 : _a.path;
        if (parentPath && parentPath !== "/") {
          folders.add(parentPath);
        }
      });
      const folderCount = folders.size;
      const previousFileCount = this.plugin.statCardData.stats.lastFileCount || 0;
      const previousFolderCount = this.plugin.statCardData.stats.lastFolderCount || 0;
      if (fileCount !== previousFileCount) {
        this.plugin.statCardData.stats.lastFileCount = fileCount;
        this.updateResearchSkill(fileCount);
      }
      if (folderCount !== previousFolderCount) {
        this.plugin.statCardData.stats.lastFolderCount = folderCount;
        this.updateOrganizationSkill(folderCount);
      }
    } catch (error) {
      console.error("Error updating file/folder counts:", error);
    }
  }
  updateWritingSkill(keyCount) {
    const skill = this.plugin.statCardData.skills.find((s) => s.id === "writing");
    if (skill) {
      const xpGain = Math.floor(keyCount / 1);
      this.updateSkill(skill, xpGain);
    }
  }
  getRequiredCountForLevel(level, baseCount, incrementFactor) {
    let total = 0;
    for (let i = 1; i <= level; i++) {
      total += Math.floor(baseCount + (i - 1) * incrementFactor);
    }
    return total;
  }
  getLevelForCount(count, baseCount, incrementFactor) {
    let level = 0;
    let totalRequired = 0;
    let prevTotalRequired = 0;
    while (true) {
      level++;
      prevTotalRequired = totalRequired;
      totalRequired += Math.floor(baseCount + (level - 1) * incrementFactor);
      if (totalRequired > count) {
        level--;
        const nextLevelCost = Math.floor(baseCount + level * incrementFactor);
        const remainingCount = count - prevTotalRequired;
        const progress = remainingCount / nextLevelCost * 100;
        return { level, progress };
      }
      if (totalRequired === count) {
        return { level, progress: 0 };
      }
    }
  }
  updateResearchSkill(fileCount) {
    const skill = this.plugin.statCardData.skills.find((s) => s.id === "research");
    if (skill) {
      const result = this.getLevelForCount(fileCount, 5, 10);
      this.setSkillLevel(skill, result.level, result.progress);
    }
  }
  updateOrganizationSkill(folderCount) {
    const skill = this.plugin.statCardData.skills.find((s) => s.id === "organization");
    if (skill) {
      const result = this.getLevelForCount(folderCount, 3, 4);
      this.setSkillLevel(skill, result.level, result.progress);
    }
  }
  setSkillLevel(skill, newLevel, xpPercentage) {
    const oldLevel = skill.level;
    skill.level = newLevel;
    skill.xp = Math.floor(xpPercentage);
    if (newLevel > oldLevel) {
      const pointsGained = (newLevel - oldLevel) * 2;
      this.plugin.statCardData.points += pointsGained;
      new import_obsidian3.Notice(`Your ${skill.name} skill has increased to level ${skill.level}!`);
    }
  }
  updateSkill(skill, xpAmount) {
    var _a;
    if (xpAmount <= 0) return;
    if ((_a = this.plugin.statCardData.activeEffects) == null ? void 0 : _a.xpMultiplier) {
      const multiplier = this.plugin.statCardData.activeEffects.xpMultiplier;
      const now = Date.now();
      if (multiplier.expiresAt > now) {
        xpAmount = Math.floor(xpAmount * multiplier.value);
      }
    }
    skill.xp += xpAmount;
    const nextLevel = skill.level + 1;
    const xpForNextLevel = Math.floor(100 + 25 * nextLevel + Math.pow(nextLevel, 2) * 2);
    if (skill.xp >= xpForNextLevel) {
      skill.level = nextLevel;
      skill.xp = 0;
      new import_obsidian3.Notice(`Your ${skill.name} skill has increased to level ${skill.level}!`);
      this.plugin.statCardData.points += nextLevel * 2;
    }
  }
  async executeTask(instruction) {
    try {
      this.plugin.processingIndicatorService.startProcessing("llm");
      if (instruction.toLowerCase().includes("create theme") || instruction.toLowerCase().includes("generate theme")) {
        return this.generateTheme(instruction);
      }
      const pointsCost = await this.determineTaskCost(instruction);
      new import_obsidian3.Notice(`${pointsCost} points will be expended for the task.`);
      if (this.plugin.statCardData.points < pointsCost) {
        throw new Error(`Not enough points. You need ${pointsCost} points to perform this action.`);
      }
      try {
        this.plugin.statCardData.points -= pointsCost;
        const theme = this.plugin.themeService.getCurrentTheme();
        const systemMessage = theme.flavor.systemMessage;
        const functions = [
          {
            "name": "perform_task",
            "description": "Perform a task requested by the user",
            "parameters": {
              "type": "object",
              "properties": {
                "result": {
                  "type": "string",
                  "description": "The result of the task execution"
                },
                "task_type": {
                  "type": "string",
                  "enum": ["answer", "code_generation", "analysis", "creative"],
                  "description": "The type of task performed"
                },
                "title": {
                  "type": "string",
                  "description": "A short title describing the task result"
                }
              },
              "required": ["result"]
            }
          }
        ];
        const messages = [
          {
            "role": "system",
            "content": systemMessage
          },
          {
            "role": "user",
            "content": `I'd like you to perform this task: ${instruction}`
          }
        ];
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 6e5);
        const response = await fetch(`${this.plugin.settings.apiUrl}/v1/chat/completions`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${this.plugin.settings.apiKey}`
          },
          body: JSON.stringify({
            model: this.plugin.settings.selectedLLMModel,
            messages,
            tools: [{ "type": "function", "function": functions[0] }],
            tool_choice: { "type": "function", "function": { "name": "perform_task" } }
          }),
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`API error: ${response.status} - ${errorText}`);
        }
        const data = await response.json();
        let result = "";
        let title = "Untitled Task";
        if (data.choices && data.choices[0] && data.choices[0].message) {
          const message = data.choices[0].message;
          if (message.tool_calls && message.tool_calls[0]) {
            try {
              const toolCall = message.tool_calls[0];
              const functionArgs = JSON.parse(toolCall.function.arguments);
              if (functionArgs.result) {
                result = functionArgs.result;
                title = functionArgs.title || "Untitled Task";
              }
            } catch (e) {
              console.warn("Error parsing tool_calls arguments", e);
            }
          }
          if (!result && message.parameters && message.parameters.result) {
            result = message.parameters.result;
            title = message.parameters.title || "Untitled Task";
          }
          if (!result) {
            const responseStr = JSON.stringify(data);
            const resultRegex = /"result"\s*:\s*"((?:\\"|[^"])+)"/;
            const match = responseStr.match(resultRegex);
            if (match && match[1]) {
              result = match[1].replace(/\\"/g, '"').replace(/\\n/g, "\n");
              const titleRegex = /"title"\s*:\s*"((?:\\"|[^"])+)"/;
              const titleMatch = responseStr.match(titleRegex);
              if (titleMatch && titleMatch[1]) {
                title = titleMatch[1].replace(/\\"/g, '"');
              }
            }
          }
          if (!result && message.name === "perform_task" && message.parameters) {
            if (message.parameters.result) {
              result = message.parameters.result;
              title = message.parameters.title || "Untitled Task";
            }
          }
          if (!result && message.content) {
            result = message.content;
          }
        }
        if (!result) {
          console.error("Unexpected response format", data);
          throw new Error("Could not extract result from LLM response");
        }
        this.plugin.statCardData.stats.tasksCompleted++;
        await this.saveResultToVault(result, title, pointsCost);
        return result;
      } catch (error) {
        console.error("Error executing LLM task:", error);
        this.plugin.statCardData.points += pointsCost;
        if (error.name === "AbortError") {
          throw new Error("The request timed out. The powers are not responding.");
        }
        throw error;
      }
    } finally {
      await this.plugin.saveStatCardData();
      this.plugin.processingIndicatorService.endProcessing();
    }
  }
  async determineTaskCost(instruction) {
    var _a;
    try {
      const functions = [
        {
          "name": "determine_cost",
          "description": "Determine the point cost for executing a task based on complexity",
          "parameters": {
            "type": "object",
            "properties": {
              "points": {
                "type": "number",
                "description": "The number of points required for the task"
              },
              "reasoning": {
                "type": "string",
                "description": "Explanation of how points were calculated"
              },
              "complexity": {
                "type": "string",
                "enum": ["trivial", "simple", "moderate", "complex", "extreme"],
                "description": "Assessment of the task's complexity"
              }
            },
            "required": ["points", "reasoning", "complexity"]
          }
        }
      ];
      const messages = [
        {
          "role": "system",
          "content": "You need to assign a point cost for completing a task. Assign points based on complexity: trivial (1-5 points), simple (5-10 points), moderate (10-30 points), complex (30-50 points), extreme (50-1000 points). Be fair in your assessment."
        },
        {
          "role": "user",
          "content": `I request your judgement for this task: "${instruction}". What is the cost?`
        }
      ];
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 6e4 * 2);
      const response = await fetch(`${this.plugin.settings.apiUrl}/v1/chat/completions`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.plugin.settings.apiKey}`
        },
        body: JSON.stringify({
          model: this.plugin.settings.selectedLLMModel,
          messages,
          temperature: 0.5,
          tools: [{ "type": "function", "function": functions[0] }],
          tool_choice: { "type": "function", "function": { "name": "determine_cost" } }
        }),
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`API error: ${response.status} - ${errorText}`);
      }
      const data = await response.json();
      if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.tool_calls && data.choices[0].message.tool_calls[0]) {
        const toolCall = data.choices[0].message.tool_calls[0];
        const functionArgs = JSON.parse(toolCall.function.arguments);
        let cost = Math.round(functionArgs.points);
        if ((_a = this.plugin.statCardData.activeEffects) == null ? void 0 : _a.storeDiscount) {
          const discount = this.plugin.statCardData.activeEffects.storeDiscount;
          const now = Date.now();
          if (discount.expiresAt > now) {
            cost = Math.max(1, Math.floor(cost * (1 - discount.value)));
          }
        }
        return cost;
      }
      throw new Error("Could not determine task cost");
    } catch (error) {
      console.error("Error determining task cost:", error);
      if (error.name === "AbortError") {
        throw new Error("The request timed out. The dark powers are not responding.");
      }
      return 10;
    }
  }
  async generateTheme(instruction) {
    const pointsCost = 500;
    if (this.plugin.statCardData.points < pointsCost) {
      throw new Error(`Not enough points. You need ${pointsCost} points to create a custom theme.`);
    }
    try {
      this.plugin.statCardData.points -= pointsCost;
      const themeService = new ThemeService(this.plugin);
      const newTheme = await themeService.generateCustomTheme(instruction);
      themeService.switchTheme("custom");
      if (this.plugin.statCardService) {
        this.plugin.statCardService.refreshUI();
      }
      return `Custom theme "${newTheme.name}" has been created and activated. The UI will now use this theme's terminology and style.`;
    } catch (error) {
      console.error("Error generating theme:", error);
      this.plugin.statCardData.points += pointsCost;
      throw new Error(`Failed to generate theme: ${error.message}`);
    }
  }
  getEnhancedFunctionDefinitions() {
    return [
      {
        "name": "perform_task",
        "description": "Perform a task requested by the user",
        "parameters": {
          "type": "object",
          "properties": {
            "result": {
              "type": "string",
              "description": "The result of the task execution"
            },
            "task_type": {
              "type": "string",
              "enum": ["answer", "code_execution", "analysis", "creative"],
              "description": "The type of task performed"
            },
            "title": {
              "type": "string",
              "description": "A short title describing the task result"
            }
          },
          "required": ["result"]
        }
      },
      {
        "name": "generate_creative_content",
        "description": "Generate creative content like stories, poems, or descriptions",
        "parameters": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "description": "The creative content generated"
            },
            "title": {
              "type": "string",
              "description": "Title for the creative work"
            },
            "genre": {
              "type": "string",
              "description": "Genre or type of creative work"
            }
          },
          "required": ["content", "title"]
        }
      },
      {
        "name": "answer_question",
        "description": "Provide a direct answer to a question",
        "parameters": {
          "type": "object",
          "properties": {
            "answer": {
              "type": "string",
              "description": "The answer to the question"
            },
            "confidence": {
              "type": "string",
              "enum": ["high", "medium", "low"],
              "description": "Confidence level in the answer"
            }
          },
          "required": ["answer"]
        }
      },
      {
        "name": "provide_code",
        "description": "Generate code in response to a programming request",
        "parameters": {
          "type": "object",
          "properties": {
            "code": {
              "type": "string",
              "description": "The generated code"
            },
            "language": {
              "type": "string",
              "description": "Programming language of the code"
            },
            "explanation": {
              "type": "string",
              "description": "Explanation of how the code works"
            }
          },
          "required": ["code"]
        }
      }
    ];
  }
  extractContentFromResponse(data) {
    let content = "";
    let title = "Untitled Task";
    if (!data || !data.choices || !data.choices[0] || !data.choices[0].message) {
      return { content, title };
    }
    const message = data.choices[0].message;
    if (message.tool_calls && message.tool_calls.length > 0) {
      try {
        const toolCall = message.tool_calls[0];
        const functionName = toolCall.function.name;
        const args = JSON.parse(toolCall.function.arguments);
        switch (functionName) {
          case "perform_task":
            content = args.result || "";
            title = args.title || "Task Result";
            break;
          case "generate_creative_content":
            content = args.content || "";
            title = args.title || "Creative Content";
            break;
          case "answer_question":
            content = args.answer || "";
            title = "Question Answer";
            break;
          case "provide_code":
            content = args.code || "";
            if (args.explanation) {
              content += "\n\n" + args.explanation;
            }
            title = `Code (${args.language || "unknown"})`;
            break;
          default:
            for (const key in args) {
              if (typeof args[key] === "string" && args[key].length > 0) {
                content = args[key];
                break;
              }
            }
        }
      } catch (parseError) {
        console.warn("Error parsing tool call arguments", parseError);
      }
    }
    if (!content && message.content) {
      content = message.content;
      title = "Direct Response";
    }
    return { content, title };
  }
  async saveResultToVault(content, title, pointsCost) {
    try {
      const folderPath = "QuestLog";
      const folder = this.plugin.app.vault.getAbstractFileByPath(folderPath);
      if (!folder) {
        await this.plugin.app.vault.createFolder(folderPath);
      }
      const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[-:.TZ]/g, "");
      const randomStr = Math.random().toString(36).substring(2, 8);
      const safeTitle = title ? title.replace(/[^a-zA-Z0-9]/g, "_").substring(0, 20) : "untitled";
      const filename = `${folderPath}/${timestamp}_${safeTitle}_${randomStr}.md`;
      const fileContent = `---
title: ${title}
created: ${(/* @__PURE__ */ new Date()).toISOString()}
points_cost: ${pointsCost}
---

# ${title}

${content} 

*the portal closes....*
`;
      await this.plugin.app.vault.create(filename, fileContent);
      new import_obsidian3.Notice(`Task result saved to ${filename}`);
    } catch (error) {
      console.error("Error saving result to vault:", error);
      new import_obsidian3.Notice("Error saving task result to vault.");
    }
  }
  destroy() {
    document.removeEventListener("keydown", this.keyboardListener);
    if (this.intervalId !== null) {
      window.clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
};
var RedeemTaskModal = class extends import_obsidian3.Modal {
  constructor(app, plugin) {
    super(app);
    this.instruction = "";
    this.plugin = plugin;
  }
  onOpen() {
    var _a;
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("redeem-task-modal");
    const theme = this.plugin.themeService.getCurrentTheme();
    const header = contentEl.createDiv({ cls: "redeem-header" });
    header.createEl("h2", { text: "Beseech Unknown Powers" });
    const pointsContainer = contentEl.createDiv({ cls: "points-display" });
    const pointsValue = pointsContainer.createSpan({ cls: "points-value" });
    pointsValue.setText(`${this.plugin.statCardData.points}`);
    const pointsLabel = pointsContainer.createSpan({ cls: "points-label" });
    pointsLabel.setText(` ${((_a = theme == null ? void 0 : theme.uiElements) == null ? void 0 : _a.points) || "Points"} Available`);
    const inputSection = contentEl.createDiv({ cls: "input-section" });
    inputSection.createEl("label", {
      text: "What do you wish to request?",
      cls: "input-label"
    });
    const instructionInput = new import_obsidian3.TextComponent(inputSection).setPlaceholder("Enter your request here...").onChange((value) => {
      this.instruction = value;
    });
    instructionInput.inputEl.classList.add("redeem-input");
    instructionInput.inputEl.style.minHeight = "120px";
    instructionInput.inputEl.style.width = "100%";
    setTimeout(() => {
      instructionInput.inputEl.focus();
    }, 50);
    const buttonContainer = contentEl.createDiv({ cls: "redeem-buttons" });
    const requestButton = new import_obsidian3.ButtonComponent(buttonContainer).setButtonText("Request").setCta().onClick(async () => {
      var _a2;
      if (!this.instruction) {
        new import_obsidian3.Notice("You must specify your request.");
        return;
      }
      try {
        this.close();
        const processingNotice = new import_obsidian3.Notice("Transmitting through the ether...", 0);
        const llmService = new LLMTaskService(this.plugin);
        const cost = await llmService.determineTaskCost(this.instruction);
        if (this.plugin.statCardData.points < cost) {
          processingNotice.hide();
          new import_obsidian3.Notice(`Not enough ${((_a2 = theme == null ? void 0 : theme.uiElements) == null ? void 0 : _a2.points) || "points"}. You need ${cost} to perform this action.`);
          new StatCardModal(this.app, this.plugin).open();
          return;
        }
        const result = await llmService.executeTask(this.instruction);
        processingNotice.hide();
        if (this.plugin.statCardService) {
          this.plugin.statCardService.refreshUI();
        }
        const resultModal = new TaskResultModal(this.app, this.plugin, result);
        resultModal.open();
      } catch (error) {
        console.error("Error executing task:", error);
        new import_obsidian3.Notice(`The request failed. ${error.message}`);
        new StatCardModal(this.app, this.plugin).open();
      }
    });
    instructionInput.inputEl.addEventListener("keydown", (event) => {
      if (event.key === "Enter" && (event.ctrlKey || event.metaKey)) {
        requestButton.buttonEl.click();
      }
    });
    const dismissButton = new import_obsidian3.ButtonComponent(buttonContainer).setButtonText("Dismiss").onClick(() => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var TaskResultModal = class extends import_obsidian3.Modal {
  constructor(app, plugin, result) {
    super(app);
    this.plugin = plugin;
    this.result = result;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Response" });
    const resultContainer = contentEl.createDiv({ cls: "task-result-container" });
    const MarkdownIt = window.markdownit;
    if (MarkdownIt) {
      const md = new MarkdownIt();
      const renderedMarkdown = md.render(this.result);
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = renderedMarkdown;
      while (tempDiv.firstChild) {
        resultContainer.appendChild(tempDiv.firstChild);
      }
    } else {
      this.result.split("\n").forEach((line) => {
        const p = resultContainer.createEl("p", { text: line });
      });
    }
    const buttonContainer = contentEl.createDiv({ cls: "task-result-buttons" });
    new import_obsidian3.ButtonComponent(buttonContainer).setButtonText("Return").onClick(() => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// features/task-assessment-service.ts
var import_obsidian4 = require("obsidian");
var TaskAssessmentService = class {
  constructor(plugin) {
    this.requestQueue = [];
    this.isProcessing = false;
    this.lastRequestTime = 0;
    this.taskStoragePath = "QuestLog/task_storage.json";
    this.taskLogPath = "QuestLog/task_activity_log.json";
    this.taskStateListeners = [];
    this.plugin = plugin;
  }
  async initializeStorage() {
    const { adapter } = this.plugin.app.vault;
    if (!await adapter.exists(this.taskStoragePath)) {
      await adapter.write(
        this.taskStoragePath,
        JSON.stringify({ processedTasks: [] })
      );
    }
    if (!await adapter.exists(this.taskLogPath)) {
      await adapter.write(
        this.taskLogPath,
        JSON.stringify({ taskChanges: [] })
      );
    }
  }
  registerTaskStateListener(callback) {
    this.taskStateListeners.push(callback);
  }
  notifyStateChange(change) {
    this.taskStateListeners.forEach((listener) => listener(change));
  }
  async logTaskStateChange(change) {
    const { adapter } = this.plugin.app.vault;
    let log = { taskChanges: [] };
    if (await adapter.exists(this.taskLogPath)) {
      try {
        const data = await adapter.read(this.taskLogPath);
        log = JSON.parse(data);
      } catch (e) {
        console.error("Error parsing task log:", e);
      }
    }
    log.taskChanges.push(change);
    await adapter.write(this.taskLogPath, JSON.stringify(log));
    this.notifyStateChange(change);
  }
  async loadTaskStorage() {
    const { adapter } = this.plugin.app.vault;
    if (await adapter.exists(this.taskStoragePath)) {
      try {
        const data = await adapter.read(this.taskStoragePath);
        const parsed = JSON.parse(data);
        return parsed.processedTasks || [];
      } catch (e) {
        console.error("Error parsing task storage:", e);
        return [];
      }
    }
    return [];
  }
  async saveTaskStorage(tasks) {
    await this.plugin.app.vault.adapter.write(
      this.taskStoragePath,
      JSON.stringify({ processedTasks: tasks })
    );
  }
  async isTaskProcessed(filePath, taskText) {
    const tasks = await this.loadTaskStorage();
    return tasks.some(
      (task) => task.filePath === filePath && task.taskText === taskText && task.completed === true
    );
  }
  async getTask(filePath, taskText) {
    const tasks = await this.loadTaskStorage();
    return tasks.find(
      (task) => task.filePath === filePath && task.taskText === taskText
    ) || null;
  }
  async addProcessedTask(filePath, taskText, points, tags) {
    const tasks = await this.loadTaskStorage();
    const existingTaskIndex = tasks.findIndex(
      (task) => task.filePath === filePath && task.taskText === taskText
    );
    const now = Date.now();
    if (existingTaskIndex >= 0) {
      tasks[existingTaskIndex] = {
        ...tasks[existingTaskIndex],
        completed: true,
        lastUpdated: now,
        points,
        tags
      };
    } else {
      tasks.push({
        filePath,
        taskText,
        completed: true,
        lastUpdated: now,
        points,
        tags
      });
    }
    await this.saveTaskStorage(tasks);
    await this.logTaskStateChange({
      taskText,
      filePath,
      newState: "completed",
      timestamp: now,
      points
    });
  }
  async markTaskUncompleted(filePath, taskText) {
    const tasks = await this.loadTaskStorage();
    const existingTaskIndex = tasks.findIndex(
      (task) => task.filePath === filePath && task.taskText === taskText
    );
    if (existingTaskIndex >= 0 && tasks[existingTaskIndex].completed) {
      const points = tasks[existingTaskIndex].points;
      const now = Date.now();
      tasks[existingTaskIndex].completed = false;
      tasks[existingTaskIndex].lastUpdated = now;
      await this.saveTaskStorage(tasks);
      await this.logTaskStateChange({
        taskText,
        filePath,
        newState: "uncompleted",
        timestamp: now,
        points
      });
      if (this.plugin.settings.deductPointsForUnchecking) {
        this.plugin.statCardData.points -= points;
        this.plugin.statCardData.stats.tasksUnchecked++;
        this.plugin.statCardData.stats.totalPointsDeducted += points;
        this.plugin.statCardService.refreshUI();
        new import_obsidian4.Notice(`Task unchecked. Deducted ${points} points.`);
      }
    }
  }
  async processNoteTasks(content, filePath) {
    const currentTasks = this.extractTasksFromNote(content);
    const storedTasks = await this.loadTaskStorage();
    const fileTasks = storedTasks.filter((task) => task.filePath === filePath);
    for (const task of currentTasks) {
      if (task.completed) {
        const isAlreadyProcessed = await this.isTaskProcessed(filePath, task.taskText);
        if (!isAlreadyProcessed) {
          const tags = this.plugin.extractTags(task.taskText);
          this.queueTaskAssessment(filePath, task.taskText, tags);
        }
      } else {
        const wasCompleted = fileTasks.some(
          (storedTask) => storedTask.taskText === task.taskText && storedTask.completed === true
        );
        if (wasCompleted) {
          await this.markTaskUncompleted(filePath, task.taskText);
        }
      }
    }
  }
  extractTasksFromNote(content) {
    const taskRegex = /- \[([ xX])\]\s+(.*?)(?:\n|$)/g;
    const tasks = [];
    let match;
    while ((match = taskRegex.exec(content)) !== null) {
      tasks.push({
        taskText: match[2].trim(),
        completed: match[1].toLowerCase() === "x"
      });
    }
    return tasks;
  }
  async assessCompletedTasks() {
    const { settings, app, statCardData, statCardService } = this.plugin;
    if (settings.trackedNotes.length === 0) {
      new import_obsidian4.Notice('No notes are being tracked. Add notes using the "Track Current Note for Tasks" command.');
      return;
    }
    let newTasksAssessing = 0;
    for (const notePath of settings.trackedNotes) {
      const file = app.vault.getAbstractFileByPath(notePath);
      if (file instanceof import_obsidian4.TFile) {
        const content = await app.vault.read(file);
        await this.processNoteTasks(content, file.path);
        const tasks = this.extractTasksFromNote(content);
        const completedTasks = tasks.filter((task) => task.completed);
        for (const task of completedTasks) {
          if (!await this.isTaskProcessed(file.path, task.taskText)) {
            newTasksAssessing++;
          }
        }
      }
    }
    if (newTasksAssessing > 0) {
      new import_obsidian4.Notice(`Assessment started for ${newTasksAssessing} new completed tasks.`);
      statCardData.stats.tasksCompleted += 1;
      this.plugin.updateStreak();
      this.plugin.achievementsService.checkForAchievements();
      statCardService.refreshUI();
    }
  }
  queueTaskAssessment(filePath, taskText, tags) {
    const { processingIndicatorService, statCardData, statCardService } = this.plugin;
    const task = async () => {
      try {
        const points = await this.plugin.calculatePointsForTask(taskText, tags);
        statCardData.points += points;
        statCardData.stats.tasksCompleted++;
        statCardData.stats.totalPointsEarned += points;
        this.plugin.achievementsService.checkForAchievements();
        await this.addProcessedTask(filePath, taskText, points, tags);
        statCardService.refreshUI();
        new import_obsidian4.Notice(`Task assessed! Earned ${points} points.`);
      } catch (error) {
        console.error("Error assessing task:", error);
        new import_obsidian4.Notice("Error assessing task. See console for details.");
      }
    };
    processingIndicatorService.startProcessing("assessment");
    this.requestQueue.push(task);
    try {
      if (!this.isProcessing) {
        this.processQueue();
      }
    } finally {
      processingIndicatorService.endProcessing();
    }
  }
  async processQueue() {
    var _a;
    if (this.requestQueue.length === 0) {
      this.isProcessing = false;
      return;
    }
    this.isProcessing = true;
    const { settings } = this.plugin;
    if ((_a = settings.rateLimiting) == null ? void 0 : _a.enabled) {
      const now = Date.now();
      const minTimeGap = 6e4 / settings.rateLimiting.requestsPerMinute;
      const timeElapsed = now - this.lastRequestTime;
      if (timeElapsed < minTimeGap) {
        await new Promise((resolve) => setTimeout(resolve, minTimeGap - timeElapsed));
      }
    }
    const task = this.requestQueue.shift();
    if (task) {
      this.lastRequestTime = Date.now();
      await task();
    }
    this.processQueue();
  }
  async handleFileModified(file) {
    if (this.plugin.settings.trackedNotes.includes(file.path)) {
      const content = await this.plugin.app.vault.read(file);
      await this.processNoteTasks(content, file.path);
    }
  }
  async deleteTask(filePath, taskText) {
    const tasks = await this.loadTaskStorage();
    const filteredTasks = tasks.filter(
      (task) => !(task.filePath === filePath && task.taskText === taskText)
    );
    await this.saveTaskStorage(filteredTasks);
  }
  async getRecentTaskActivity(limit = 10) {
    const { adapter } = this.plugin.app.vault;
    if (await adapter.exists(this.taskLogPath)) {
      try {
        const data = await adapter.read(this.taskLogPath);
        const log = JSON.parse(data);
        return (log.taskChanges || []).sort((a, b) => b.timestamp - a.timestamp).slice(0, limit);
      } catch (e) {
        console.error("Error parsing task log:", e);
        return [];
      }
    }
    return [];
  }
};

// views/task-storage-viewer.ts
var import_obsidian5 = require("obsidian");
var TASK_STORAGE_VIEW_TYPE = "task-storage-view";
var TaskStorageViewer = class extends import_obsidian5.ItemView {
  constructor(leaf, plugin, taskAssessmentService) {
    super(leaf);
    this.filterOptions = {
      text: "",
      status: "all"
    };
    this.plugin = plugin;
    this.taskAssessmentService = taskAssessmentService;
  }
  getViewType() {
    return TASK_STORAGE_VIEW_TYPE;
  }
  getDisplayText() {
    return "Task Storage";
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("vq-task-storage-viewer");
    contentEl.createEl("h2", { text: "Task Storage Viewer" });
    this.createFilterSection(contentEl);
    this.createActionButtons(contentEl);
    this.activityLogSection = contentEl.createDiv({ cls: "vq-activity-log-container" });
    this.activityLogSection.createEl("h3", { text: "Recent Activity" });
    this.taskListContainer = contentEl.createDiv({ cls: "vq-task-list-container" });
    this.taskAssessmentService.registerTaskStateListener(this.handleTaskStateChange.bind(this));
    await this.refreshView();
  }
  createFilterSection(containerEl) {
    const filterContainer = containerEl.createDiv({ cls: "vq-filter-container" });
    this.textFilter = new import_obsidian5.TextComponent(filterContainer).setPlaceholder("Filter by text or file path").onChange(async (value) => {
      this.filterOptions.text = value;
      await this.renderTaskList();
    });
    const statusOptions = [
      { value: "all", display: "All" },
      { value: "completed", display: "Completed" },
      { value: "uncompleted", display: "Uncompleted" }
    ];
    new import_obsidian5.Setting(filterContainer).setName("Status").addDropdown((dropdown) => {
      statusOptions.forEach((option) => {
        dropdown.addOption(option.value, option.display);
      });
      dropdown.setValue(this.filterOptions.status);
      dropdown.onChange(async (value) => {
        this.filterOptions.status = value;
        await this.renderTaskList();
      });
      return dropdown;
    });
  }
  createActionButtons(containerEl) {
    const actionContainer = containerEl.createDiv({ cls: "vq-action-container" });
    new import_obsidian5.ButtonComponent(actionContainer).setButtonText("Refresh").setClass("mod-primary").onClick(() => this.refreshView());
    new import_obsidian5.ButtonComponent(actionContainer).setButtonText("Clear All Data").setClass("mod-warning").onClick(async () => {
      if (confirm("Are you sure you want to clear all task data? This action cannot be undone.")) {
        await this.taskAssessmentService.saveTaskStorage([]);
        await this.refreshView();
      }
    });
  }
  handleTaskStateChange(change) {
    this.refreshView();
  }
  async refreshView() {
    await Promise.all([
      this.renderActivityLog(),
      this.renderTaskList()
    ]);
  }
  async renderActivityLog() {
    this.activityLogSection.empty();
    this.activityLogSection.createEl("h3", { text: "Recent Activity" });
    const recentActivity = await this.taskAssessmentService.getRecentTaskActivity(5);
    if (recentActivity.length === 0) {
      this.activityLogSection.createEl("p", { text: "No recent activity." });
      return;
    }
    const activityList = this.activityLogSection.createEl("ul", { cls: "vq-activity-list" });
    for (const activity of recentActivity) {
      const item = activityList.createEl("li", { cls: "vq-activity-item" });
      const statusClass = activity.newState === "completed" ? "vq-completed" : "vq-uncompleted";
      const statusIcon = activity.newState === "completed" ? "\u2713" : "\u25CB";
      const statusIndicator = item.createSpan({ cls: `vq-status ${statusClass}`, text: statusIcon });
      const filePathParts = activity.filePath.split("/");
      const fileName = filePathParts[filePathParts.length - 1];
      const formattedTime = new Date(activity.timestamp).toLocaleTimeString();
      item.createSpan({
        text: ` Task ${activity.newState} at ${formattedTime}: "${this.truncateText(activity.taskText, 40)}" in ${fileName}`
      });
    }
  }
  async renderTaskList() {
    if (!this.taskListContainer) return;
    this.taskListContainer.empty();
    const tasks = await this.taskAssessmentService.loadTaskStorage();
    const filteredTasks = tasks.filter((task) => {
      const textMatch = !this.filterOptions.text || task.taskText.toLowerCase().includes(this.filterOptions.text.toLowerCase()) || task.filePath.toLowerCase().includes(this.filterOptions.text.toLowerCase());
      let statusMatch = true;
      if (this.filterOptions.status === "completed") {
        statusMatch = task.completed;
      } else if (this.filterOptions.status === "uncompleted") {
        statusMatch = !task.completed;
      }
      return textMatch && statusMatch;
    });
    filteredTasks.sort((a, b) => b.lastUpdated - a.lastUpdated);
    const statsEl = this.taskListContainer.createEl("div", { cls: "vq-stats-container" });
    statsEl.createEl("p", {
      text: `Showing ${filteredTasks.length} of ${tasks.length} tasks`
    });
    if (filteredTasks.length === 0) {
      this.taskListContainer.createEl("p", { text: "No tasks found." });
      return;
    }
    this.createTaskTable(this.taskListContainer, filteredTasks);
  }
  createTaskTable(container, tasks) {
    const table = container.createEl("table", { cls: "vq-task-table" });
    const headerRow = table.createEl("thead").createEl("tr");
    ["Status", "Task", "File", "Points", "Tags", "Last Updated", "Actions"].forEach((header) => headerRow.createEl("th", { text: header }));
    const tbody = table.createEl("tbody");
    tasks.forEach((task) => this.createTaskRow(tbody, task));
  }
  createTaskRow(tbody, task) {
    const row = tbody.createEl("tr");
    const statusCell = row.createEl("td");
    statusCell.createEl("span", {
      cls: `vq-status ${task.completed ? "vq-completed" : "vq-uncompleted"}`,
      text: task.completed ? "\u2713" : "\u25CB"
    });
    row.createEl("td", {
      cls: "vq-task-text",
      text: this.truncateText(task.taskText, 50)
    }).setAttribute("title", task.taskText);
    const filePathParts = task.filePath.split("/");
    const fileName = filePathParts[filePathParts.length - 1];
    row.createEl("td", { text: fileName }).setAttribute("title", task.filePath);
    row.createEl("td", { cls: "vq-points", text: task.points.toString() });
    const tagsCell = row.createEl("td", { cls: "vq-tags" });
    if (task.tags && task.tags.length > 0) {
      task.tags.forEach((tag) => {
        tagsCell.createEl("span", { cls: "vq-tag", text: tag });
      });
    } else {
      tagsCell.setText("None");
    }
    const date = new Date(task.lastUpdated);
    row.createEl("td", {
      text: date.toLocaleDateString() + " " + date.toLocaleTimeString()
    });
    const actionsCell = row.createEl("td", { cls: "vq-actions" });
    new import_obsidian5.ButtonComponent(actionsCell).setButtonText("Delete").setClass("mod-warning").onClick(async () => {
      if (confirm(`Are you sure you want to delete this task record?`)) {
        await this.taskAssessmentService.deleteTask(task.filePath, task.taskText);
        await this.renderTaskList();
      }
    });
  }
  truncateText(text, maxLength) {
    return text.length > maxLength ? text.slice(0, maxLength) + "..." : text;
  }
  async onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var TaskStorageRibbonIcon = class {
  constructor(plugin, taskAssessmentService) {
    plugin.addRibbonIcon(
      "list-checks",
      "View Task Storage",
      () => {
        plugin.activateTaskStorageTab();
      }
    );
  }
};

// features/itemStore.ts
var import_obsidian8 = require("obsidian");

// features/initializeStoreItems.ts
var import_obsidian6 = require("obsidian");
async function initializeStoreItems(plugin) {
  const items = [
    {
      id: "store_app",
      name: "Commerce Card",
      description: "Allows you to open the store from the inventory.",
      cost: 10,
      category: "artifact",
      owned: false,
      levelRequired: 1,
      hidden: false,
      effectType: "enable_feature",
      effectParams: {
        featureId: "store_app"
      }
    },
    {
      id: "theme_toggler",
      name: "Theme Toggler",
      description: "Allows you to switch themes.",
      cost: 10,
      category: "cosmetic",
      owned: false,
      levelRequired: 1,
      hidden: false,
      effectType: "enable_feature",
      effectParams: {
        featureId: "theme_toggler"
      }
    },
    {
      id: "mysterious_tablet",
      name: "Mysterious Tablet",
      description: "A mysterious tablet that resonates with an ethereal hum. It feels like a communicator...?",
      cost: 100,
      category: "artifact",
      owned: false,
      levelRequired: 0,
      effectType: "custom",
      effectParams: {
        customCode: `
					new Notice('A mysterious tablet falls into your hands. A new icon appears in the Ribbon. A new command enters your mind.');
                `
      }
    },
    {
      id: "minor_xp_boost",
      name: "Experience Potion (Minor)",
      description: "Gain 100 immediate XP.",
      cost: 25,
      category: "boost",
      owned: false,
      levelRequired: 0,
      effectType: "xp_boost",
      effectParams: {
        value: 100
      }
    },
    {
      id: "major_xp_boost",
      name: "Experience Potion (Major)",
      description: "Gain 500 immediate XP.",
      cost: 100,
      category: "boost",
      owned: false,
      levelRequired: 10,
      hidden: true,
      effectType: "xp_boost",
      effectParams: {
        value: 500
      }
    },
    {
      id: "writing_skill_boost",
      name: "Quill of Dark Scriptures I",
      description: "Gain 1 level in Writing skill.",
      cost: 75,
      category: "boost",
      owned: false,
      skillRequired: { skillId: "writing", level: 2 },
      hidden: false,
      effectType: "skill_boost",
      effectParams: {
        skillId: "writing",
        value: 1
      }
    },
    {
      id: "research_skill_boost",
      name: "Tome of Forbidden Knowledge I",
      description: "Gain 1 level in Research skill.",
      cost: 75,
      category: "boost",
      owned: false,
      skillRequired: { skillId: "research", level: 2 },
      hidden: false,
      effectType: "skill_boost",
      effectParams: {
        skillId: "research",
        value: 1
      }
    },
    {
      id: "organization_skill_boost",
      name: "Cataloguing System I",
      description: "Gain 1 level in Organization skill.",
      cost: 75,
      category: "boost",
      owned: false,
      skillRequired: { skillId: "organization", level: 2 },
      hidden: false,
      effectType: "skill_boost",
      effectParams: {
        skillId: "organization",
        value: 1
      }
    },
    {
      id: "dark_ritual_discount",
      name: "Blood Pact I",
      description: "All requests cost 20% less for 24 hours.",
      cost: 150,
      category: "ritual",
      owned: false,
      levelRequired: 10,
      hidden: false,
      effectType: "store_discount",
      effectParams: {
        value: 0.2,
        duration: 24
      }
    },
    {
      id: "demonic_theme",
      name: "Demonic Pact",
      description: "The Grimoire emits a disturbing light.",
      cost: 200,
      category: "cosmetic",
      owned: false,
      levelRequired: 5,
      hidden: false,
      effectType: "custom",
      effectParams: {
        customCode: `new Notice('You hear the echoes of demonic screams.');`
      }
    },
    {
      id: "celestial_theme",
      name: "Celestial Codex",
      description: "A radiant transformation, aligning your interface with the heavens.",
      cost: 200,
      category: "cosmetic",
      owned: false,
      levelRequired: 5,
      hidden: false,
      effectType: "custom",
      effectParams: {
        customCode: `new Notice('Your interface now shimmers with cosmic brilliance.');`
      }
    },
    {
      id: "cybernetic_theme",
      name: "Neural Interface",
      description: "A sleek, high-tech upgrade, turning your UI into a cybernetic control hub.",
      cost: 200,
      category: "cosmetic",
      owned: false,
      levelRequired: 10,
      hidden: false,
      effectType: "custom",
      effectParams: {
        customCode: `new Notice('System update complete. Cybernetic enhancements activated.');`
      }
    },
    {
      id: "arcane_theme",
      name: "Arcane Tome",
      description: "A mystical upgrade, bathing your interface in ancient magic.",
      cost: 200,
      category: "cosmetic",
      owned: false,
      levelRequired: 10,
      hidden: true,
      effectType: "custom",
      effectParams: {
        customCode: `new Notice('Arcane glyphs swirl around you as your Tome of Elders awakens.');`
      }
    },
    {
      id: "eldritch_theme",
      name: "Necronomicon",
      description: "A disturbing, otherworldly theme, for fans of eldritch horror.",
      cost: 200,
      category: "cosmetic",
      owned: false,
      levelRequired: 10,
      hidden: true,
      effectType: "custom",
      effectParams: {
        customCode: `new Notice('The shadows deepen. You hear whispers in forgotten tongues...');`
      }
    },
    {
      id: "rogue_theme",
      name: "Phantom's Veil",
      description: "A shadowy, assassin-inspired theme for those who thrive in secrecy.",
      cost: 200,
      category: "cosmetic",
      owned: false,
      levelRequired: 10,
      hidden: true,
      effectType: "custom",
      effectParams: {
        customCode: `new Notice('You vanish into the shadows, your interface adapting to the underworld.');`
      }
    },
    {
      id: "xp_multiplier",
      name: "Soul Binding Contract",
      description: "Gain 1.5x XP from all activities for 24 hours.",
      cost: 175,
      category: "ritual",
      owned: false,
      levelRequired: 15,
      effectType: "xp_multiplier",
      effectParams: {
        value: 1.5,
        duration: 24
      }
    },
    {
      id: "familiar",
      name: "Familiar",
      description: "Summon a small familiar that provides random bonuses each day.",
      cost: 300,
      category: "artifact",
      owned: false,
      levelRequired: 50,
      hidden: false,
      effectType: "summon_familiar"
    },
    {
      id: "infinite_inventory",
      name: "Infinite Inventory",
      description: "A storage tab to store your items.",
      cost: 500,
      category: "artifact",
      owned: false,
      levelRequired: 1,
      hidden: true,
      effectType: "enable_feature",
      effectParams: {
        featureId: "infinite_inventory"
      }
    },
    {
      id: "system_control",
      name: "Administrative Dominion",
      description: "Gain administrative access to the system.",
      cost: 500,
      category: "artifact",
      owned: false,
      levelRequired: 100,
      hidden: false,
      effectType: "unlock_title",
      effectParams: {
        titleId: "system_control",
        titleName: "Administrator",
        titleDesc: "A title given to those with control over the system.",
        featureId: "administrator_rights"
      }
    },
    {
      id: "debugger",
      name: "Debugger Rights",
      description: "Unlocks hidden developer tools.",
      cost: 500,
      category: "artifact",
      owned: false,
      levelRequired: 10,
      hidden: true,
      effectType: "unlock_title",
      effectParams: {
        titleId: "debugger",
        titleName: "Debugger",
        titleDesc: "A title granted to those who uncover and resolve hidden issues.",
        featureId: "debugger_tools"
      }
    },
    {
      id: "tagger",
      name: "Tag Editor",
      description: "Unlocks ability to add and edit tags.",
      cost: 100,
      category: "artifact",
      owned: false,
      levelRequired: 3,
      hidden: false,
      effectType: "enable_feature",
      effectParams: {
        featureId: "tagger"
      }
    },
    {
      "id": "experience_stone",
      "name": "Experience Stone",
      "description": "A mystical stone required to craft XP Boost items.",
      "cost": 100,
      "category": "material",
      "owned": false,
      "levelRequired": 20,
      "effectType": "custom",
      "effectParams": {}
    },
    {
      "id": "ritual_gem",
      "name": "Ritual Gem",
      "description": "A gem imbued with ritual energy, essential for crafting Ritual items.",
      "cost": 150,
      "category": "material",
      "owned": false,
      "levelRequired": 15,
      "effectType": "custom",
      "effectParams": {}
    },
    {
      "id": "component",
      "name": "Component",
      "description": "A vital component required to craft Artifact items.",
      "cost": 200,
      "category": "material",
      "owned": false,
      "levelRequired": 10,
      "effectType": "custom",
      "effectParams": {}
    },
    {
      "id": "container",
      "name": "Container",
      "description": "A specialized container used in the crafting of Cosmetic items.",
      "cost": 50,
      "category": "material",
      "owned": false,
      "levelRequired": 0,
      "effectType": "custom",
      "effectParams": {}
    }
  ];
  await loadCustomItems(plugin, items);
  return items;
}
async function loadCustomItems(plugin, items) {
  const folderPath = "QuestLog/StoreInventory";
  const files = plugin.app.vault.getFiles().filter(
    (file) => file.path.startsWith(folderPath) && file.extension === "json"
  );
  for (const file of files) {
    try {
      const content = await plugin.app.vault.read(file);
      const customItems = JSON.parse(content);
      customItems.forEach((item) => {
        if (!items.find((existingItem) => existingItem.id === item.id)) {
          const newItem = {
            ...item,
            effectType: item.effectType || "custom",
            effectParams: item.effectParams || { customCode: typeof item.effect === "string" ? item.effect : "" }
          };
          if (typeof item.effect === "string") {
            newItem.effect = createEffectFunction(item.effect);
          }
          items.push(newItem);
        }
      });
    } catch (error) {
      console.error(`Failed to load custom item from ${file.path}:`, error);
    }
  }
}
function createEffectFunction(effect) {
  return (plugin) => {
    try {
    } catch (error) {
      console.error("Invalid effect code in JSON:", error);
      new Notice5("Error executing custom item effect.");
    }
  };
}

// features/effectService.ts
var import_obsidian7 = require("obsidian");
var EffectService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  applyEffect(type, params = {}) {
    switch (type) {
      case "xp_boost":
        this.applyXPBoost(params.value || 0);
        break;
      case "points_boost":
        this.applyPointsBoost(params.value || 0);
        break;
      case "store_discount":
        this.applyStoreDiscount(params.value || 0.1, params.duration || 24);
        break;
      case "xp_multiplier":
        this.applyXPMultiplier(params.value || 1.5, params.duration || 24);
        break;
      case "skill_boost":
        this.applySkillBoost(params.skillId || "", params.value || 1);
        break;
      case "unlock_title":
        this.unlockTitle(params.titleId || "", params.titleName || "", params.titleDesc || "", params.featureId || "");
        break;
      case "enable_feature":
        this.enableFeature(params.featureId || "");
        break;
      case "summon_familiar":
        this.summonFamiliar();
        break;
      case "custom":
        if (params.customCode) {
          this.applyCustomEffect(params.customCode);
        }
        break;
    }
  }
  applyXPBoost(amount) {
    this.plugin.statCardData.xp += amount;
    new import_obsidian7.Notice(`Your soul absorbs ${amount} experience points!`);
  }
  applyPointsBoost(amount) {
    this.plugin.statCardData.points += amount;
    new import_obsidian7.Notice(`You've received ${amount} tokens!`);
  }
  applyStoreDiscount(discountRate, durationHours) {
    this.plugin.statCardData.activeEffects = this.plugin.statCardData.activeEffects || {};
    this.plugin.statCardData.activeEffects.storeDiscount = {
      value: discountRate,
      expiresAt: Date.now() + durationHours * 60 * 60 * 1e3
    };
    const discountPercent = Math.round(discountRate * 100);
    new import_obsidian7.Notice(`All items are now ${discountPercent}% cheaper for ${durationHours} hours!`);
  }
  applyXPMultiplier(multiplier, durationHours) {
    this.plugin.statCardData.activeEffects = this.plugin.statCardData.activeEffects || {};
    this.plugin.statCardData.activeEffects.xpMultiplier = {
      value: multiplier,
      expiresAt: Date.now() + durationHours * 60 * 60 * 1e3
    };
    new import_obsidian7.Notice(`You now gain ${multiplier}x XP for ${durationHours} hours!`);
  }
  applySkillBoost(skillId, levels) {
    const skill = this.plugin.statCardData.skills.find((s) => s.id === skillId);
    if (skill) {
      skill.level += levels;
      new import_obsidian7.Notice(`Your ${skill.name} skill has increased by ${levels} level${levels > 1 ? "s" : ""}!`);
    } else {
      new import_obsidian7.Notice(`Error: Skill ${skillId} not found.`);
    }
  }
  unlockTitle(titleId, titleName, titleDesc, effectId = "") {
    if (!this.plugin.statCardData.titles.some((title) => title.id === titleId)) {
      const newTitle = {
        id: titleId,
        name: titleName,
        description: titleDesc,
        unlockedAt: (/* @__PURE__ */ new Date()).toISOString(),
        effect: effectId ? [effectId] : []
      };
      this.plugin.statCardData.titles.push(newTitle);
      new import_obsidian7.Notice(`You've earned the "${titleName}" title!`);
    }
  }
  enableFeature(featureId) {
    switch (featureId) {
      case "store_app":
        new import_obsidian7.Notice("You can now access the store from the inventory!");
        break;
      case "theme_toggler":
        new import_obsidian7.Notice("You can now change themes from the stats menu!");
        break;
      case "tagger":
        new import_obsidian7.Notice("You have been granted Tag editing rights!");
        break;
      case "infinite_inventory":
        new import_obsidian7.Notice("You bought an Inventory Box!");
        break;
      default:
        new import_obsidian7.Notice(`Feature ${featureId} has been enabled!`);
    }
  }
  summonFamiliar() {
    this.plugin.statCardData.hasFamiliar = true;
    this.setupFamiliarDailyBonus();
    new import_obsidian7.Notice("A small creature materializes, bound to your service!");
  }
  setupFamiliarDailyBonus() {
    const now = /* @__PURE__ */ new Date();
    const today = now.toDateString();
    if (this.plugin.statCardData.lastFamiliarBonusDate !== today) {
      const bonusType = Math.floor(Math.random() * 2);
      const randomBonus = Math.floor(Math.random() * 100);
      switch (bonusType) {
        case 0:
          this.plugin.statCardData.xp += randomBonus;
          new import_obsidian7.Notice(`Your familiar brings you a gift of ${randomBonus} XP!`);
          break;
        case 1:
          this.plugin.statCardData.points += randomBonus;
          new import_obsidian7.Notice(`Your familiar has collected ${randomBonus} tokens for you!`);
          break;
      }
      this.plugin.statCardData.lastFamiliarBonusDate = today;
    }
  }
  applyCustomEffect(code) {
    try {
      const plugin = this.plugin;
      const Notice16 = require("obsidian").Notice;
      const app = this.plugin.app;
      const execFunction = new Function("plugin", "Notice", "app", `
				try {
					${code}
				} catch (innerError) {
					console.error("Error in custom code:", innerError);
					new Notice("Error in custom code execution.");
				}
			`);
      execFunction(this.plugin, Notice16, this.plugin.app);
    } catch (error) {
      console.error("Error executing custom effect:", error);
      const Notice16 = require("obsidian").Notice;
      new Notice16("Error executing custom item effect.");
    }
  }
};

// features/itemStore.ts
var ItemStoreService = class {
  constructor(plugin) {
    this.items = [];
    this.debugMode = false;
    this.plugin = plugin;
    this.effectService = new EffectService(plugin);
    this.initializeStore();
  }
  async initializeStore() {
    this.items = await initializeStoreItems(this.plugin);
    this.syncOwnedItems();
  }
  syncOwnedItems() {
    if (!this.plugin.statCardData.ownedItems) {
      this.plugin.statCardData.ownedItems = [];
      return;
    }
    for (const item of this.items) {
      item.owned = this.plugin.statCardData.ownedItems.includes(item.id);
    }
  }
  getAllItems() {
    return this.items;
  }
  getItem(itemId) {
    return this.items.find((item) => item.id === itemId) || null;
  }
  getItems() {
    if (this.debugMode) {
      return this.items;
    }
    return this.items.filter(
      (item) => !(item.hidden && !this.meetsRequirements(item))
    );
  }
  meetsRequirements(item) {
    if (this.debugMode) {
      return true;
    }
    if (item.levelRequired && this.plugin.statCardData.level < item.levelRequired) {
      return false;
    }
    if (item.skillRequired) {
      const skill = this.plugin.statCardData.skills.find((s) => {
        var _a;
        return s.id === ((_a = item.skillRequired) == null ? void 0 : _a.skillId);
      });
      if (!skill || skill.level < item.skillRequired.level) {
        return false;
      }
    }
    return true;
  }
  getRequirementText(item) {
    var _a;
    if (this.debugMode) {
      return "Debug Mode Active";
    }
    const requirements = [];
    if (item.levelRequired && this.plugin.statCardData.level < item.levelRequired) {
      requirements.push(`Level ${item.levelRequired} required`);
    }
    if (item.skillRequired) {
      const skill = this.plugin.statCardData.skills.find((s) => {
        var _a2;
        return s.id === ((_a2 = item.skillRequired) == null ? void 0 : _a2.skillId);
      });
      const skillName = skill ? skill.name : (_a = item.skillRequired) == null ? void 0 : _a.skillId;
      if (!skill || skill.level < item.skillRequired.level) {
        requirements.push(`${skillName} level ${item.skillRequired.level} required`);
      }
    }
    return requirements.join(", ");
  }
  async purchaseItem(itemId) {
    const item = this.items.find((i) => i.id === itemId);
    if (!item) {
      new import_obsidian8.Notice("Item not found in the catalogue.");
      return false;
    }
    if (item.category !== "boost" && item.category !== "ritual") {
      if (this.plugin.statCardData.items.some((items) => items.id === item.id)) {
        new import_obsidian8.Notice("You already own this artifact.");
        return false;
      }
    }
    if (this.plugin.statCardData.points < item.cost) {
      new import_obsidian8.Notice(`Not enough tokens. You need ${item.cost} tokens to purchase this item.`);
      return false;
    }
    if (!this.meetsRequirements(item)) {
      new import_obsidian8.Notice(`You do not meet the requirements: ${this.getRequirementText(item)}`);
      return false;
    }
    if (this.plugin.statCardData.activeEffects.storeDiscount) {
      const discountPercent = Math.round(this.plugin.statCardData.activeEffects.storeDiscount.value * 100);
      new import_obsidian8.Notice(`Discount active: ${discountPercent}%!`);
      this.plugin.statCardData.points -= Math.round(item.cost * (1 - discountPercent / 100));
    } else {
      this.plugin.statCardData.points -= item.cost;
    }
    if (item.category === "artifact") {
      item.owned = true;
      if (!this.plugin.statCardData.ownedItems.includes(item.id)) {
        this.plugin.statCardData.ownedItems.push(item.id);
        this.plugin.statCardData.items.push({
          id: item.id,
          name: item.name,
          cost: item.cost,
          description: item.description,
          unlockedAt: (/* @__PURE__ */ new Date()).toISOString(),
          effect: [""]
        });
      }
    }
    if (item.category === "cosmetic") {
      item.owned = true;
      this.plugin.themeService.switchTheme(item.id);
      if (!this.plugin.statCardData.items.some((items) => items.id === item.id)) {
        this.plugin.statCardData.items.push({
          id: item.id,
          name: item.name,
          description: item.description,
          cost: item.cost,
          unlockedAt: (/* @__PURE__ */ new Date()).toISOString(),
          effect: ["Set theme."]
        });
      }
    }
    this.applyItemEffect(item);
    this.plugin.checkForLevelUp();
    this.plugin.statCardData.stats.itemsPurchased = (this.plugin.statCardData.stats.itemsPurchased || 0) + 1;
    this.plugin.app.workspace.trigger("layout-change");
    await this.plugin.statCardService.refreshUI();
    return true;
  }
  applyItemEffect(item) {
    try {
      if (item.effectType) {
        this.effectService.applyEffect(item.effectType, item.effectParams || {});
        return;
      }
      if (item.effect && typeof item.effect === "function") {
        item.effect(this.plugin);
        return;
      }
      new import_obsidian8.Notice(`You have acquired: ${item.name}`);
    } catch (error) {
      console.error("Error applying item effect:", error);
      new import_obsidian8.Notice(`Error applying effect for item: ${item.name}`);
    }
  }
};
var ItemStoreModal = class extends import_obsidian8.Modal {
  constructor(app, plugin, storeService) {
    super(app);
    this.selectedCategory = "all";
    this.sortOption = "default";
    this.plugin = plugin;
    this.storeService = storeService;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gamify-store-modal");
    contentEl.createEl("h2", { text: "Item Store", cls: "gamify-modal-title" });
    contentEl.createEl("div", {
      text: `Available Tokens: ${this.plugin.statCardData.points}`,
      cls: "gamify-points-display"
    });
    this.renderFilterControls(contentEl);
    const itemsContainer = contentEl.createDiv({ cls: "gamify-store-items" });
    itemsContainer.id = "store-items-container";
    this.storeService.initializeStore();
    this.renderItems();
    contentEl.createDiv({ cls: "gamify-store-buttons" });
  }
  renderFilterControls(contentEl) {
    const filterContainer = contentEl.createDiv({ cls: "gamify-store-filter" });
    const categoryLabel = filterContainer.createSpan({ text: "Category:", cls: "gamify-filter-label" });
    const categoryDropdown = new import_obsidian8.DropdownComponent(filterContainer);
    categoryDropdown.selectEl.addClass("gamify-dropdown");
    categoryDropdown.addOption("all", "All Items");
    categoryDropdown.addOption("boost", "Boosts");
    categoryDropdown.addOption("ritual", "Rituals");
    categoryDropdown.addOption("artifact", "Artifacts");
    categoryDropdown.addOption("cosmetic", "Cosmetics");
    categoryDropdown.addOption("material", "Materials");
    categoryDropdown.setValue(this.selectedCategory);
    categoryDropdown.onChange((value) => {
      this.selectedCategory = value;
      this.renderItems();
    });
    const divider = filterContainer.createSpan({ text: "|", cls: "gamify-filter-divider" });
    const sortLabel = filterContainer.createSpan({ text: "Sort by:", cls: "gamify-filter-label" });
    const sortDropdown = new import_obsidian8.DropdownComponent(filterContainer);
    sortDropdown.selectEl.addClass("gamify-dropdown");
    sortDropdown.addOption("default", "Default");
    sortDropdown.addOption("cost_asc", "Cost (Low to High)");
    sortDropdown.addOption("cost_desc", "Cost (High to Low)");
    sortDropdown.addOption("name_asc", "Name (A to Z)");
    sortDropdown.addOption("name_desc", "Name (Z to A)");
    sortDropdown.setValue(this.sortOption);
    sortDropdown.onChange((value) => {
      this.sortOption = value;
      this.renderItems();
    });
  }
  renderItems() {
    const itemsContainer = document.getElementById("store-items-container");
    if (!itemsContainer) return;
    itemsContainer.empty();
    let items = this.storeService.getItems().filter(
      (item) => this.selectedCategory === "all" || item.category === this.selectedCategory
    );
    items = this.sortItems(items);
    if (items.length === 0) {
      itemsContainer.createEl("p", {
        text: "No items available in this category.",
        cls: "gamify-no-items"
      });
      return;
    }
    items.forEach((item) => this.renderItemElement(itemsContainer, item));
  }
  renderItemElement(container, item) {
    const itemEl = container.createDiv({ cls: "gamify-store-item" });
    const itemHeader = itemEl.createDiv({ cls: "gamify-item-header" });
    itemHeader.createEl("h3", { text: item.name, cls: "gamify-item-title" });
    itemHeader.createEl("span", {
      text: `${item.cost} tokens`,
      cls: "gamify-item-cost"
    });
    itemEl.createEl("p", {
      text: item.description,
      cls: "gamify-item-description"
    });
    const categoryNames = {
      "boost": "Boost",
      "ritual": "Ritual",
      "artifact": "Artifact",
      "cosmetic": "Cosmetic Upgrade",
      "material": "Material"
    };
    itemEl.createEl("span", {
      text: categoryNames[item.category],
      cls: `gamify-item-category gamify-category-${item.category}`
    });
    this.renderRequirements(itemEl, item);
    this.renderPurchaseButton(itemEl, item);
  }
  renderRequirements(container, item) {
    const meetsRequirements = this.storeService.meetsRequirements(item);
    if (!meetsRequirements) {
      const reqText = this.storeService.getRequirementText(item);
      const reqLabel = container.createEl("div", {
        text: reqText,
        cls: "gamify-item-requirement"
      });
    }
  }
  renderPurchaseButton(container, item) {
    const isOwned = this.plugin.statCardData.items.some((i) => i.id === item.id) && (item.category === "artifact" || item.category === "cosmetic");
    const purchaseButton = new import_obsidian8.ButtonComponent(container).setButtonText(isOwned ? "Owned" : "Purchase").onClick(async () => {
      const success = await this.storeService.purchaseItem(item.id);
      if (success) {
        const pointsDisplay = document.querySelector(".gamify-points-display");
        if (pointsDisplay) {
          pointsDisplay.textContent = `Available Tokens: ${this.plugin.statCardData.points}`;
        }
        if (item.category === "artifact" || item.category === "cosmetic") {
          this.renderItems();
        }
      }
    });
    if (isOwned) {
      purchaseButton.setDisabled(true);
    }
  }
  sortItems(items) {
    switch (this.sortOption) {
      case "cost_asc":
        return [...items].sort((a, b) => a.cost - b.cost);
      case "cost_desc":
        return [...items].sort((a, b) => b.cost - a.cost);
      case "name_asc":
        return [...items].sort((a, b) => a.name.localeCompare(b.name));
      case "name_desc":
        return [...items].sort((a, b) => b.name.localeCompare(a.name));
      default:
        return items;
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// features/itemCrafter.ts
var import_obsidian9 = require("obsidian");
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
var ItemCrafterModal = class extends import_obsidian9.Modal {
  constructor(app, plugin) {
    super(app);
    this.baseCost = 50;
    this.effectsConfig = {
      boost: {
        maxXP: 2e3,
        conversionRate: 4,
        discountThresholds: [
          { threshold: 800, multiplier: 0.9 },
          { threshold: 1200, multiplier: 0.8 },
          { threshold: 1600, multiplier: 0.7 }
        ]
      },
      ritual: {
        maxMultiplier: 5,
        maxDuration: 180,
        // in hours
        costScaleFactor: 250,
        effectTypes: [
          { value: "xp_multiplier", label: "XP Multiplier" },
          { value: "store_discount", label: "Store Discount" },
          { value: "points_boost", label: "Points Boost" }
        ]
      },
      artifact: {
        effectTypes: [
          { value: "unlock_title", label: "Custom Title" },
          { value: "skill_boost", label: "Skill Boost" },
          { value: "item", label: "Item" },
          { value: "custom", label: "Custom Effect" }
        ],
        maxCustomLength: 500
      },
      cosmetic: {
        effectTypes: [
          { value: "title", label: "Cosmetic Title" }
        ]
      }
    };
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gamify-item-crafter-modal");
    contentEl.createEl("h2", {
      text: "Item Crafter",
      cls: "gamify-modal-title"
    });
    const nameInput = this.createTextInput(contentEl, "Item Name:", true, {
      required: true,
      maxLength: 50,
      validators: [
        (value) => value.trim().length > 2 || "Name must be at least 3 characters"
      ]
    });
    const descInput = this.createTextArea(contentEl, "Description:", true, {
      required: true,
      maxLength: 300,
      validators: [
        (value) => value.trim().length > 10 || "Description must be at least 10 characters"
      ]
    });
    const categoryDropdown = new import_obsidian9.DropdownComponent(contentEl);
    this.populateCategoryDropdown(categoryDropdown);
    const effectContainer = contentEl.createDiv("gamify-effect-container");
    const effectInfoDiv = contentEl.createDiv("gamify-effect-info");
    categoryDropdown.onChange((category) => {
      effectContainer.empty();
      effectInfoDiv.empty();
      this.renderEffectDetails(category, effectContainer, effectInfoDiv);
    });
    const requirementsSection = contentEl.createDiv("gamify-requirements-section");
    requirementsSection.createEl("h3", { text: "Item Requirements" });
    const levelReqInput = this.createNumberInput(requirementsSection, "Level Required:", false, 0, 50, 0);
    const skillReqContainer = requirementsSection.createDiv("gamify-skill-req-container");
    const skillDropdown = new import_obsidian9.DropdownComponent(skillReqContainer);
    skillDropdown.addOption("none", "No Skill Required");
    this.plugin.statCardData.skills.forEach((skill) => {
      skillDropdown.addOption(skill.id, skill.name);
    });
    const skillLevelInput = this.createNumberInput(skillReqContainer, "Required Skill Level:", false, 1, 20, 1);
    const costSection = contentEl.createDiv("gamify-cost-section");
    const maxCostInput = this.createNumberInput(costSection, "Max Spending Limit (Tokens):", true, 10, 1e4, 500);
    const storageOptions = new import_obsidian9.Setting(contentEl).setName("Item Storage").setDesc("Choose how you want to save the created item");
    const saveLocationDropdown = new import_obsidian9.DropdownComponent(storageOptions.controlEl);
    saveLocationDropdown.addOptions({
      "existing": "Add to Existing Inventory",
      "separate": "Create Standalone Item File"
    });
    const createButton = new import_obsidian9.ButtonComponent(contentEl).setButtonText("Forge Custom Item").setCta().onClick(() => this.validateAndConfirmCreation(
      nameInput.value,
      descInput.value,
      categoryDropdown.getValue(),
      effectContainer,
      parseInt(maxCostInput.value),
      saveLocationDropdown.getValue(),
      parseInt(levelReqInput.value) || 0,
      skillDropdown.getValue() !== "none" ? { skillId: skillDropdown.getValue(), level: parseInt(skillLevelInput.value) || 1 } : void 0
    ));
  }
  populateCategoryDropdown(dropdown) {
    dropdown.addOption("none", " ");
    dropdown.addOption("boost", "XP Boost");
    dropdown.addOption("ritual", "Ritual Effect");
    dropdown.addOption("artifact", "Artifact");
    dropdown.addOption("cosmetic", "Cosmetic");
  }
  updateCostPreview(value, display) {
    const creationFactor = Math.exp(value / 25);
    display.innerHTML = `
            <strong>Cost Distribution Preview:</strong><br>
            \u2022 Item Cost Factor: ${(2 - creationFactor).toFixed(2)}x<br>
            \u2022 Creation Cost Factor: ${creationFactor.toFixed(2)}x
        `;
  }
  renderEffectDetails(category, container, infoContainer) {
    switch (category) {
      case "boost":
        const xpInput = this.createNumberInput(
          container,
          "XP Amount:",
          true,
          0,
          this.effectsConfig.boost.maxXP
        );
        infoContainer.createEl("small", {
          text: `Max XP: ${this.effectsConfig.boost.maxXP}, Conversion Rate: 1:${this.effectsConfig.boost.conversionRate}`
        });
        break;
      case "ritual":
        const effectTypeDropdown = new import_obsidian9.DropdownComponent(container);
        container.createEl("span", { text: "Effect Type:", cls: "setting-item-label" });
        this.effectsConfig.ritual.effectTypes.forEach((effect) => {
          effectTypeDropdown.addOption(effect.value, effect.label);
        });
        const multiplierInput = this.createNumberInput(
          container,
          "Effect Value:",
          true,
          1,
          this.effectsConfig.ritual.maxMultiplier,
          1.5
        );
        const durationInput = this.createNumberInput(
          container,
          "Duration (hours):",
          true,
          1,
          this.effectsConfig.ritual.maxDuration,
          24
        );
        infoContainer.createEl("small", {
          text: `Max Value: ${this.effectsConfig.ritual.maxMultiplier}, Max Duration: ${this.effectsConfig.ritual.maxDuration} hours`
        });
        break;
      case "artifact":
        const artifactEffectDropdown = new import_obsidian9.DropdownComponent(container);
        container.createEl("span", { text: "Artifact Effect:", cls: "setting-item-label" });
        this.effectsConfig.artifact.effectTypes.forEach((effect) => {
          artifactEffectDropdown.addOption(effect.value, effect.label);
        });
        const secondaryFieldContainer = container.createDiv("secondary-effect-fields");
        artifactEffectDropdown.onChange((effectType) => {
          secondaryFieldContainer.empty();
          switch (effectType) {
            case "unlock_title":
              this.createTextInput(secondaryFieldContainer, "Title ID:", true, {
                required: true,
                placeholder: "unique_title_id"
              });
              this.createTextInput(secondaryFieldContainer, "Title Name:", true, {
                required: true,
                placeholder: "Master Crafter"
              });
              this.createTextArea(secondaryFieldContainer, "Title Description:", true, {
                required: true,
                placeholder: "Earned through item creation mastery"
              });
              break;
            case "skill_boost":
              const skillSelect = new import_obsidian9.DropdownComponent(secondaryFieldContainer);
              secondaryFieldContainer.createEl("span", { text: "Skill to Boost:", cls: "setting-item-label" });
              this.plugin.statCardData.skills.forEach((skill) => {
                skillSelect.addOption(skill.id, skill.name);
              });
              this.createNumberInput(secondaryFieldContainer, "Levels to Add:", true, 1, 5, 1);
              break;
            case "item":
              this.createTextArea(
                secondaryFieldContainer,
                "Custom Effect Code:",
                true,
                {
                  maxLength: this.effectsConfig.artifact.maxCustomLength,
                  placeholder: 'Example: new Notice("Custom effect activated!");\nplugin.statCardData.points += 10;'
                }
              );
              break;
            case "custom":
              this.createTextArea(
                secondaryFieldContainer,
                "Custom Effect Code:",
                true,
                {
                  maxLength: this.effectsConfig.artifact.maxCustomLength,
                  placeholder: 'Example: new Notice("Custom effect activated!");\nplugin.statCardData.points += 10;'
                }
              );
              break;
          }
        });
        break;
      case "cosmetic":
        const cosmeticTypeDropdown = new import_obsidian9.DropdownComponent(container);
        container.createEl("span", { text: "Cosmetic Type:", cls: "setting-item-label" });
        this.effectsConfig.cosmetic.effectTypes.forEach((effect) => {
          cosmeticTypeDropdown.addOption(effect.value, effect.label);
        });
        const titleNameInput = this.createTextInput(container, "Title Name:", true, {
          required: true,
          placeholder: "The Crafter"
        });
        const titleDescInput = this.createTextArea(container, "Title Description:", true, {
          required: true,
          placeholder: "What does this title signify"
        });
        break;
    }
  }
  validateAndConfirmCreation(name, description, category, effectContainer, maxCost, saveLocation, levelRequired = 0, skillRequired) {
    if (!name || !description || category === "none") {
      new import_obsidian9.Notice("Please fill in all required fields and select a category.");
      return;
    }
    if (category === "boost") {
      const xpInput = effectContainer.querySelector("input");
      const xpAmount = parseInt(xpInput.value);
      const maxAllowedXP = this.effectsConfig.boost.maxXP;
      const hasBypass = this.plugin.statCardData.ownedItems.includes("philosopher_stone") || this.plugin.statCardData.titles.some((title) => title.id === "alchemist");
      if (xpAmount > maxAllowedXP && !hasBypass) {
        new import_obsidian9.Notice(`XP exceeds the maximum allowed (${maxAllowedXP}). Possess a Philosopher\u2019s Stone or have the alchemist title to bypass.`);
        return;
      }
    }
    const requiredItems = {
      "boost": "Experience Stone",
      "ritual": "Ritual Gem",
      "artifact": "Component",
      "cosmetic": "Container"
    };
    if (requiredItems[category] && !this.plugin.statCardData.ownedItems.includes(requiredItems[category])) {
      new import_obsidian9.Notice(`Crafting a ${category} item requires a ${requiredItems[category]}.`);
      return;
    }
    const finalCost = this.calculateCost(category, effectContainer, maxCost);
    const creationCost = Math.round(finalCost * 1.6);
    const hasCostBypass = this.plugin.statCardData.ownedItems.includes("alkhest") || this.plugin.statCardData.titles.some((title) => title.id === "Creator");
    if (maxCost < finalCost && !hasCostBypass) {
      new import_obsidian9.Notice("Insufficient limit. Offer an equivalent price.");
      return;
    }
    const { effectType, effectParams } = this.extractEffects(category, effectContainer);
    this.showConfirmationModal(
      name,
      description,
      category,
      finalCost,
      creationCost,
      effectType,
      effectParams,
      saveLocation,
      levelRequired,
      skillRequired
    );
  }
  showConfirmationModal(name, description, category, finalCost, creationCost, effectType, effectParams, saveLocation, levelRequired = 0, skillRequired) {
    const confirmModal = new import_obsidian9.Modal(this.app);
    confirmModal.contentEl.createEl("h3", { text: "Confirm Item Creation" });
    confirmModal.contentEl.createEl("p", { text: `Item: ${name}` });
    confirmModal.contentEl.createEl("p", { text: `Category: ${category}` });
    confirmModal.contentEl.createEl("p", { text: `Effect Type: ${effectType}` });
    confirmModal.contentEl.createEl("p", { text: `Item Cost: ${finalCost} tokens` });
    confirmModal.contentEl.createEl("p", { text: `Creation Cost: ${creationCost} tokens` });
    if (levelRequired > 0) {
      confirmModal.contentEl.createEl("p", { text: `Level Required: ${levelRequired}` });
    }
    if (skillRequired) {
      const skill = this.plugin.statCardData.skills.find((s) => s.id === skillRequired.skillId);
      const skillName = skill ? skill.name : skillRequired.skillId;
      confirmModal.contentEl.createEl("p", { text: `Requires ${skillName} Level ${skillRequired.level}` });
    }
    if (this.plugin.statCardData.points < creationCost) {
      confirmModal.contentEl.createEl("p", {
        text: `Warning: You don't have enough tokens for creation (${this.plugin.statCardData.points}/${creationCost})`,
        cls: "gamify-warning"
      });
    }
    new import_obsidian9.ButtonComponent(confirmModal.contentEl).setButtonText("Confirm").setCta().onClick(() => {
      if (this.plugin.statCardData.points < creationCost) {
        new import_obsidian9.Notice("Not enough tokens to create this item!");
        return;
      }
      this.plugin.statCardData.points -= creationCost;
      this.createItem(
        name,
        description,
        category,
        finalCost,
        creationCost,
        effectType,
        effectParams,
        saveLocation,
        levelRequired,
        skillRequired
      );
      confirmModal.close();
    });
    new import_obsidian9.ButtonComponent(confirmModal.contentEl).setButtonText("Cancel").onClick(() => confirmModal.close());
    confirmModal.open();
  }
  extractEffects(category, container) {
    let effectType;
    const effectParams = {};
    switch (category) {
      case "boost":
        const xpInput = container.querySelector("input");
        const xpAmount = parseInt(xpInput.value);
        effectType = "xp_boost";
        effectParams.value = xpAmount;
        break;
      case "ritual":
        const typeDropdown = container.querySelector("select");
        const valueInput = container.querySelectorAll("input")[0];
        const durationInput = container.querySelectorAll("input")[1];
        effectType = typeDropdown.value;
        effectParams.value = parseFloat(valueInput.value);
        effectParams.duration = parseInt(durationInput.value);
        break;
      case "artifact":
        const artifactEffectDropdown = container.querySelector("select");
        effectType = artifactEffectDropdown.value;
        const secondaryContainer = container.querySelector(".secondary-effect-fields");
        if (secondaryContainer) {
          switch (effectType) {
            case "unlock_title":
              const inputs = secondaryContainer.querySelectorAll("input");
              const textArea = secondaryContainer.querySelector("textarea");
              if (inputs && inputs.length >= 2 && textArea) {
                effectParams.titleId = inputs[0].value;
                effectParams.titleName = inputs[1].value;
                effectParams.titleDesc = textArea.value;
              }
              break;
            case "skill_boost":
              const skillDropdown = secondaryContainer.querySelector("select");
              const levelInput = secondaryContainer.querySelector("input");
              if (skillDropdown && levelInput) {
                effectParams.skillId = skillDropdown.value;
                effectParams.value = parseInt(levelInput.value);
              }
              break;
            case "enable_feature":
              const featureDropdown = secondaryContainer.querySelector("select");
              if (featureDropdown) {
                if (featureDropdown.value === "custom") {
                  const customInput = secondaryContainer.querySelector("input");
                  effectParams.featureId = customInput ? customInput.value : "";
                } else {
                  effectParams.featureId = featureDropdown.value;
                }
              }
              break;
            case "custom":
              const codeTextarea = secondaryContainer.querySelector("textarea");
              effectParams.customCode = codeTextarea ? codeTextarea.value : "";
              break;
          }
        }
        break;
      case "cosmetic":
        effectType = "unlock_title";
        const titleNameInput = container.querySelectorAll("input")[0];
        const titleDescTextarea = container.querySelector("textarea");
        if (titleNameInput && titleDescTextarea) {
          const uniqueId = `cosmetic_title_${Date.now()}`;
          effectParams.titleId = uniqueId;
          effectParams.titleName = titleNameInput.value;
          effectParams.titleDesc = titleDescTextarea.value;
        }
        break;
      default:
        effectType = "custom";
        break;
    }
    return { effectType, effectParams };
  }
  calculateCost(category, container, maxCost) {
    let baseCost = this.baseCost;
    let effectMultiplier = 1;
    switch (category) {
      case "boost":
        const xpInput = container.querySelector("input");
        const xpAmount = parseInt(xpInput.value);
        baseCost = xpAmount / this.effectsConfig.boost.conversionRate;
        this.effectsConfig.boost.discountThresholds.forEach((threshold) => {
          if (xpAmount >= threshold.threshold) {
            baseCost *= threshold.multiplier;
          }
        });
        effectMultiplier = 1 + xpAmount / this.effectsConfig.boost.maxXP;
        break;
      case "ritual":
        const valueInput = container.querySelectorAll("input")[0];
        const durationInput = container.querySelectorAll("input")[1];
        baseCost = 200 + parseFloat(valueInput.value) * this.effectsConfig.ritual.costScaleFactor + parseInt(durationInput.value) / 10 * 50;
        effectMultiplier = parseFloat(valueInput.value);
        break;
      case "artifact":
        baseCost = 500 + maxCost / 2;
        effectMultiplier = 1.2;
        break;
      case "cosmetic":
        baseCost = 300;
        effectMultiplier = 1.1;
        break;
    }
    return Math.min(Math.round(baseCost * effectMultiplier), maxCost);
  }
  createItem(name, description, category, cost, creationCost, effectType, effectParams, saveLocation, levelRequired = 0, skillRequired) {
    const newItem = {
      id: `custom_${category}_${Date.now()}`,
      name,
      description,
      cost,
      category,
      owned: false,
      levelRequired: levelRequired > 0 ? levelRequired : void 0,
      skillRequired,
      effectType,
      effectParams,
      hidden: false
    };
    saveLocation === "existing" ? this.saveItemToInventory(newItem) : this.saveItemToSeparateFile(newItem);
  }
  saveItemToInventory(item) {
    try {
      const vaultPath = this.app.vault.adapter.getBasePath();
      const folderPath = path.join(vaultPath, "QuestLog", "StoreInventory");
      const itemsFilePath = path.join(folderPath, "items.json");
      let items = [];
      try {
        const existingContent = fs.readFileSync(itemsFilePath, "utf8");
        items = JSON.parse(existingContent);
      } catch (error) {
        console.log("No existing items file found, creating new one");
      }
      items.push(item);
      if (!fs.existsSync(folderPath)) fs.mkdirSync(folderPath, { recursive: true });
      fs.writeFileSync(itemsFilePath, JSON.stringify(items, null, 4), "utf8");
      new import_obsidian9.Notice(`Item "${item.name}" added to existing inventory!`);
      this.close();
    } catch (error) {
      console.error("Error saving item to inventory:", error);
      new import_obsidian9.Notice("Failed to create item. Check console for details.");
    }
  }
  saveItemToSeparateFile(item) {
    try {
      const vaultPath = this.app.vault.adapter.getBasePath();
      const folderPath = path.join(vaultPath, "QuestLog", "StoreInventory");
      const itemFilePath = path.join(folderPath, `${item.id}.json`);
      if (!fs.existsSync(folderPath)) fs.mkdirSync(folderPath, { recursive: true });
      fs.writeFileSync(itemFilePath, JSON.stringify(item, null, 4), "utf8");
      new import_obsidian9.Notice(`Item "${item.name}" saved as a separate file!`);
      this.close();
    } catch (error) {
      console.error("Error saving item to separate file:", error);
      new import_obsidian9.Notice("Failed to create item file. Check console for details.");
    }
  }
  createTextInput(container, label, required = false, options = {}) {
    const setting = new import_obsidian9.Setting(container).setName(label).addText((text) => {
      text.setValue(options.defaultValue || "");
      text.setPlaceholder(options.placeholder || `Enter ${label.toLowerCase()}`);
      const inputEl = text.inputEl;
      if (options.maxLength) {
        inputEl.maxLength = options.maxLength;
      }
      if (required || options.required) {
        inputEl.required = true;
      }
      return text;
    });
    return setting.controlEl.querySelector("input");
  }
  createTextArea(container, label, required = false, options = {}) {
    const setting = new import_obsidian9.Setting(container).setName(label).addTextArea((text) => {
      text.setValue(options.defaultValue || "");
      text.setPlaceholder(options.placeholder || `Enter ${label.toLowerCase()}`);
      const textAreaEl = text.inputEl;
      if (options.maxLength) {
        textAreaEl.maxLength = options.maxLength;
      }
      if (required || options.required) {
        textAreaEl.required = true;
      }
      return text;
    });
    return setting.controlEl.querySelector("textarea");
  }
  createNumberInput(container, label, required = false, min = 0, max = Infinity, defaultValue = 0) {
    const setting = new import_obsidian9.Setting(container).setName(label).addText(
      (text) => text.setValue(defaultValue.toString()).setPlaceholder(`Enter ${label.toLowerCase()}`).then((input2) => {
        input2.inputEl.type = "number";
        input2.inputEl.min = min.toString();
        if (max !== Infinity) {
          input2.inputEl.max = max.toString();
        }
      })
    );
    const input = setting.controlEl.querySelector("input");
    if (required) {
      input.setAttribute("required", "true");
    }
    return input;
  }
};

// support/indicator.ts
var import_obsidian10 = require("obsidian");
var ProcessingIndicatorService = class {
  constructor(plugin) {
    this.statusBarItem = null;
    this.ribbonIconEl = null;
    this.isProcessing = false;
    this.animationInterval = null;
    this.dots = 0;
    this.processingType = null;
    this.plugin = plugin;
    this.initializeIcons();
    this.createStatusBarItem();
  }
  initializeIcons() {
    (0, import_obsidian10.addIcon)("processing-indicator", `<svg viewBox="0 0 100 100" width="100" height="100" xmlns="http://www.w3.org/2000/svg">
            <circle cx="50" cy="50" r="45" fill="none" stroke="currentColor" stroke-width="10" stroke-linecap="round">
                <animate attributeName="stroke-dasharray" from="0 283" to="283 0" dur="1.5s" repeatCount="indefinite"/>
                <animate attributeName="stroke-dashoffset" from="0" to="-283" dur="1.5s" repeatCount="indefinite"/>
            </circle>
        </svg>`);
  }
  createStatusBarItem() {
    this.statusBarItem = this.plugin.addStatusBarItem();
    this.statusBarItem.addClass("processing-indicator-status");
    this.statusBarItem.style.display = "none";
  }
  createRibbonIcon() {
    this.ribbonIconEl = this.plugin.addRibbonIcon("processing-indicator", "Processing", () => {
      return;
    });
    this.ribbonIconEl.addClass("processing-indicator-ribbon");
  }
  startProcessing(type = "default") {
    this.isProcessing = true;
    this.processingType = type;
    this.dots = 0;
    if (this.plugin.settings.useStatusBarIndicator !== false) {
      this.showStatusBarIndicator();
    }
    if (this.plugin.settings.useRibbonIndicator !== false) {
      this.createRibbonIcon();
      this.showRibbonIndicator();
    }
    if (this.animationInterval === null) {
      this.animationInterval = window.setInterval(() => {
        this.updateAnimation();
      }, 500);
    }
  }
  showStatusBarIndicator() {
    if (!this.statusBarItem) return;
    const theme = this.plugin.themeService.getCurrentTheme();
    const label = this.getProcessingLabel(theme);
    this.statusBarItem.setText(label);
    this.statusBarItem.style.display = "block";
  }
  showRibbonIndicator() {
    if (!this.ribbonIconEl) return;
    this.ribbonIconEl.style.display = "block";
    this.ribbonIconEl.setAttribute("aria-label", this.getProcessingText());
  }
  getProcessingLabel(theme) {
    var _a;
    let baseText = "";
    if (this.processingType === "llm") {
      baseText = ((_a = theme == null ? void 0 : theme.flavor) == null ? void 0 : _a.processingMessage) || "Consulting the powers";
    } else {
      baseText = "Processing";
    }
    return baseText + ".".repeat(this.dots);
  }
  getProcessingText() {
    if (this.processingType === "llm") {
      return "Consulting mystical powers...";
    }
    return "Processing...";
  }
  updateAnimation() {
    if (!this.isProcessing) return;
    const theme = this.plugin.themeService.getCurrentTheme();
    this.dots = (this.dots + 1) % 4;
    if (this.statusBarItem && this.plugin.settings.useStatusBarIndicator !== false) {
      this.statusBarItem.setText(this.getProcessingLabel(theme));
    }
    if (this.ribbonIconEl && this.plugin.settings.useRibbonIndicator !== false && this.isProcessing) {
      const rotation = Date.now() / 10 % 360;
      this.ribbonIconEl.style.transform = `rotate(${rotation}deg)`;
    }
  }
  endProcessing() {
    this.isProcessing = false;
    this.processingType = null;
    if (this.animationInterval !== null) {
      window.clearInterval(this.animationInterval);
      this.animationInterval = null;
    }
    if (this.statusBarItem) {
      this.statusBarItem.style.display = "none";
    }
    if (this.ribbonIconEl) {
      this.ribbonIconEl.remove();
      this.ribbonIconEl = null;
    }
  }
  destroy() {
    this.endProcessing();
    if (this.statusBarItem) {
      this.statusBarItem.remove();
      this.statusBarItem = null;
    }
  }
};

// views/inventory.ts
var import_obsidian11 = require("obsidian");
var RARITY = {
  LEGENDARY: ["system_control", "infinite_inventory", "debugger"],
  UNIQUE: ["ring_of_power", "familiar"],
  RARE: ["sword", "shield", "magic_scroll", "helmet", "armor"]
};
var ICON_MAP = {
  "infinite_inventory": "backpack",
  "potion": "droplet",
  "sword": "sword",
  "shield": "shield",
  "gold_coin": "coins",
  "magic_scroll": "scroll",
  "helmet": "helmet",
  "armor": "vest",
  "ring_of_power": "gem",
  "system_control": "key",
  "debugger": "bug",
  "familiar": "cat",
  "store_app": "credit-card"
};
var DEFAULT_ICONS = ["star", "circle", "cube", "package", "box", "bookmark"];
var InventoryTabView = class extends import_obsidian11.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return "inventory-view";
  }
  getDisplayText() {
    return this.plugin.themeService.getThemedTerm("inventory", "Inventory");
  }
  getIcon() {
    return "package";
  }
  refreshUI() {
    this.renderInventory();
  }
  async onOpen() {
    this.containerEl = this.contentEl.createDiv({ cls: "inventory-container" });
    this.createHeader();
    this.inventoryGrid = this.containerEl.createDiv({ cls: "inventory-grid" });
    this.detailsEl = this.containerEl.createDiv({ cls: "inventory-details" });
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("layout-change", () => {
        this.renderInventory();
        this.updateTitle();
      })
    );
    this.renderInventory();
  }
  createHeader() {
    const headerEl = this.containerEl.createDiv({ cls: "inventory-header" });
    headerEl.createEl("h3", { text: this.plugin.themeService.getThemedTerm("inventory", "Inventory") });
    const controlsEl = headerEl.createDiv({ cls: "inventory-controls" });
    const searchEl = controlsEl.createEl("input", {
      type: "text",
      attr: { placeholder: "Search items..." },
      cls: "inventory-search"
    });
    searchEl.addEventListener("input", () => this.filterItems(searchEl.value));
  }
  updateTitle() {
    const headerEl = this.containerEl.querySelector(".inventory-header h3");
    if (headerEl) {
      headerEl.textContent = this.plugin.themeService.getThemedTerm("inventory", "Inventory");
    }
  }
  renderInventory() {
    this.inventoryGrid.empty();
    const items = this.getInventoryItems();
    if (items.length === 0) {
      this.renderEmptyInventory();
      return;
    }
    this.renderInventoryGrid(items);
  }
  getInventoryItems() {
    if (!Array.isArray(this.plugin.statCardData.items)) {
      return [];
    }
    return this.plugin.statCardData.items.map((item) => {
      if (typeof item === "string") {
        return {
          id: item,
          name: item.replace(/_/g, " "),
          description: "",
          icon: this.getIconForItem(item)
        };
      } else {
        return {
          id: item.id,
          name: item.name,
          description: item.description,
          icon: this.getIconForItem(item.id),
          effect: item.effect
        };
      }
    });
  }
  renderEmptyInventory() {
    this.inventoryGrid.createEl("p", {
      text: "Your inventory is empty. Complete tasks to earn points and purchase items!",
      cls: "inventory-empty"
    });
  }
  renderInventoryGrid(items) {
    const rows = Math.max(4, Math.ceil(items.length / 6));
    const cols = 6;
    const assigned = /* @__PURE__ */ new Set();
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const slotEl = this.inventoryGrid.createDiv({ cls: "inventory-slot" });
        slotEl.dataset.row = row.toString();
        slotEl.dataset.col = col.toString();
        const itemForSlot = this.findItemForPosition(items, row, col, assigned);
        if (itemForSlot) {
          this.createItemElement(slotEl, itemForSlot);
        }
      }
    }
  }
  findItemForPosition(items, row, col, assigned) {
    const storedPositions = this.plugin.settings.inventoryPositions || {};
    const positionedItem = items.find(
      (item) => !assigned.has(item.id) && storedPositions[item.id] && storedPositions[item.id].row === row && storedPositions[item.id].col === col
    );
    if (positionedItem) {
      assigned.add(positionedItem.id);
      return {
        ...positionedItem,
        position: { row, col }
      };
    }
    const unassignedItem = items.find((item) => !assigned.has(item.id));
    if (unassignedItem) {
      assigned.add(unassignedItem.id);
      return {
        ...unassignedItem,
        position: { row, col }
      };
    }
    return null;
  }
  createItemElement(slotEl, item) {
    const itemEl = slotEl.createDiv({ cls: "inventory-item gamify-inventory-item" });
    itemEl.dataset.id = item.id;
    const rarityClass = this.getItemRarityClass(item.id);
    if (rarityClass) {
      itemEl.addClass(rarityClass);
    }
    this.createItemIcon(itemEl, item);
    this.createItemName(itemEl, item);
    itemEl.addEventListener("click", () => this.handleItemClick(item));
  }
  createItemIcon(itemEl, item) {
    const iconEl = itemEl.createDiv({ cls: "item-icon" });
    try {
      (0, import_obsidian11.setIcon)(iconEl, item.icon);
    } catch (e) {
      (0, import_obsidian11.setIcon)(iconEl, "circle");
    }
  }
  createItemName(itemEl, item) {
    const nameEl = itemEl.createDiv({ cls: "item-name", text: item.name });
    itemEl.setAttribute("title", item.description);
  }
  handleItemClick(item) {
    if (item.id === "infinite_inventory") {
      this.plugin.activateInventoryTab();
      return;
    }
    if (item.id === "mysterious_tablet") {
      new RedeemTaskModal(this.plugin.app, this.plugin).open();
      return;
    }
    if (item.id === "store_app") {
      new ItemStoreModal(this.app, this.plugin, this.plugin.itemStoreService).open();
      return;
    }
    if (item.effect) {
      if (item.effect.includes("Set theme.")) {
        const themeId = item.id.replace("_theme", "");
        this.plugin.themeService.switchTheme(themeId);
        new StatCardModal(this.app, this.plugin).open();
        const existingLeaves = this.app.workspace.getLeavesOfType("inventory-view");
        if (existingLeaves.length > 0) {
          existingLeaves[0].detach();
          this.plugin.activateInventoryTab();
        }
        return;
      }
      try {
        const effectFunction = this.createEffectFunction(item.effect);
        effectFunction(this.plugin);
        new import_obsidian11.Notice(`Activated: ${item.name}`);
      } catch (error) {
        console.error("Error executing item effect:", error);
        new import_obsidian11.Notice("Error activating item effect.");
      }
    }
  }
  createEffectFunction(effect) {
    try {
      return new Function("plugin", effect);
    } catch (error) {
      console.error("Invalid effect code:", error);
      return () => new import_obsidian11.Notice("Error executing item effect.");
    }
  }
  getItemRarityClass(itemId) {
    if (RARITY.LEGENDARY.includes(itemId)) {
      return "legendary-item";
    } else if (RARITY.UNIQUE.includes(itemId) || itemId.includes("_theme")) {
      return "unique-item";
    } else if (RARITY.RARE.includes(itemId)) {
      return "rare-item";
    } else {
      return "common-item";
    }
  }
  getIconForItem(itemId) {
    if (itemId.includes("_theme")) {
      return "book";
    }
    return ICON_MAP[itemId] || DEFAULT_ICONS[itemId.length % DEFAULT_ICONS.length];
  }
  filterItems(query) {
    const items = this.inventoryGrid.querySelectorAll("inventory-item");
    query = query.toLowerCase();
    items.forEach((item) => {
      var _a;
      const itemEl = item;
      const nameEl = itemEl.querySelector("item-name");
      const name = nameEl ? ((_a = nameEl.textContent) == null ? void 0 : _a.toLowerCase()) || "" : "";
    });
  }
  async onClose() {
  }
};

// debug/DebugMenu.ts
var import_obsidian12 = require("obsidian");
var DebugMenu = class extends import_obsidian12.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Debug Menu" });
    this.createStatsSection(contentEl);
    this.createSkillsSection(contentEl);
    this.createItemsSection(contentEl);
    this.createStatsManipulationSection(contentEl);
    this.createTitlesSection(contentEl);
    this.createDebugTools(contentEl);
    const saveBtn = contentEl.createEl("button", {
      text: "Save All Changes",
      cls: "mod-cta debug-button"
    });
    saveBtn.addEventListener("click", async () => {
      await this.plugin.saveStatCardData();
      new import_obsidian12.Notice("Debug changes saved successfully!");
      this.close();
    });
  }
  createStatsSection(parent) {
    const section = parent.createDiv("debug-section");
    section.createEl("h3", { text: "Core Stats" });
    this.createStatControl(section, "XP", () => this.plugin.statCardData.xp, (val) => {
      this.plugin.statCardData.xp = val;
      this.plugin.checkForLevelUp();
    });
    this.createStatControl(section, "Level", () => this.plugin.statCardData.level, (val) => {
      this.plugin.statCardData.level = val;
      this.plugin.statCardData.nextLevelXp = Math.round(100 * Math.pow(1.1 + val * 0.05, val - 1));
    });
    this.createStatControl(section, "Points", () => this.plugin.statCardData.points, (val) => {
      this.plugin.statCardData.points = val;
    });
  }
  createSkillsSection(parent) {
    const section = parent.createDiv("debug-section");
    section.createEl("h3", { text: "Skills" });
    const skillSelector = section.createEl("select");
    this.plugin.statCardData.skills.forEach((skill) => {
      const option = skillSelector.createEl("option");
      option.value = skill.id;
      option.text = skill.name;
    });
    const selectedSkillDiv = section.createDiv("selected-skill-controls");
    const updateSelectedSkillControls = () => {
      const selectedSkillId = skillSelector.value;
      const selectedSkill = this.plugin.statCardData.skills.find((s) => s.id === selectedSkillId);
      if (!selectedSkill) return;
      selectedSkillDiv.empty();
      this.createStatControl(selectedSkillDiv, "Skill Level", () => selectedSkill.level, (val) => selectedSkill.level = val);
      this.createStatControl(selectedSkillDiv, "Skill XP", () => selectedSkill.xp, (val) => selectedSkill.xp = val);
    };
    skillSelector.addEventListener("change", updateSelectedSkillControls);
    updateSelectedSkillControls();
  }
  createItemsSection(parent) {
    const section = parent.createDiv("debug-section");
    section.createEl("h3", { text: "Owned Items" });
    const itemInputContainer = section.createDiv("item-input-container");
    const itemInput = itemInputContainer.createEl("input", {
      type: "text",
      placeholder: "Enter item id to add"
    });
    const addItemButton = itemInputContainer.createEl("button", { text: "Add Item", cls: "debug-button" });
    addItemButton.addEventListener("click", () => {
      const itemId = itemInput.value.trim();
      if (itemId && !this.plugin.statCardData.ownedItems.includes(itemId)) {
        this.plugin.statCardData.ownedItems.push(itemId);
        this.renderOwnedItems(itemsListDiv);
        itemInput.value = "";
      }
    });
    const itemsListDiv = section.createDiv("items-list");
    this.renderOwnedItems(itemsListDiv);
  }
  createStatsManipulationSection(parent) {
    const section = parent.createDiv("debug-section");
    section.createEl("h3", { text: "Stats & Counters" });
    this.createStatControl(section, "Tasks Completed", () => this.plugin.statCardData.stats.tasksCompleted, (val) => this.plugin.statCardData.stats.tasksCompleted = val);
    this.createStatControl(section, "Total Points Earned", () => this.plugin.statCardData.stats.totalPointsEarned, (val) => this.plugin.statCardData.stats.totalPointsEarned = val);
  }
  createTitlesSection(parent) {
    const section = parent.createDiv("debug-section");
    section.createEl("h3", { text: "Manage Titles" });
    const titleIdInput = section.createEl("input", { type: "text", placeholder: "Enter Title ID" });
    const titleNameInput = section.createEl("input", { type: "text", placeholder: "Enter Title Name" });
    const titleDescInput = section.createEl("input", { type: "text", placeholder: "Enter Title Description" });
    const addTitleButton = section.createEl("button", { text: "Add Title", cls: "debug-button" });
    addTitleButton.addEventListener("click", () => {
      const id = titleIdInput.value.trim();
      const name = titleNameInput.value.trim();
      const description = titleDescInput.value.trim();
      if (!id || !name || !description) {
        new import_obsidian12.Notice("Please fill in all fields before adding a title.");
        return;
      }
      if (this.plugin.statCardData.titles.some((title) => title.id === id)) {
        new import_obsidian12.Notice(`Title "${name}" already exists.`);
        return;
      }
      const newTitle = {
        id,
        name,
        description,
        unlockedAt: (/* @__PURE__ */ new Date()).toISOString(),
        effect: []
      };
      this.plugin.statCardData.titles.push(newTitle);
      this.renderTitlesList(titlesListDiv);
      titleIdInput.value = "";
      titleNameInput.value = "";
      titleDescInput.value = "";
    });
    const titlesListDiv = section.createDiv("titles-list");
    this.renderTitlesList(titlesListDiv);
  }
  createDebugTools(parent) {
    const section = parent.createDiv("debug-section");
    section.createEl("h3", { text: "Debug Tools" });
    const forceSaveBtn = section.createEl("button", { text: "Force Save Data", cls: "debug-button" });
    forceSaveBtn.addEventListener("click", async () => {
      await this.plugin.saveStatCardData();
      new import_obsidian12.Notice("Data force-saved successfully");
    });
  }
  createStatControl(containerEl, label, getValue, setValue) {
    const controlDiv = containerEl.createDiv("stat-control");
    const labelEl = controlDiv.createEl("span", { text: label, cls: "stat-label" });
    const buttonContainer = controlDiv.createDiv("stat-button-container");
    const buttons = [
      { text: "-10", change: -10, cls: "decrease-button" },
      { text: "-1", change: -1, cls: "decrease-button" },
      { text: "+1", change: 1, cls: "increase-button" },
      { text: "+10", change: 10, cls: "increase-button" }
    ];
    const leftButtonGroup = buttonContainer.createDiv("stat-button-group");
    buttons.slice(0, 2).forEach(({ text, change, cls }) => {
      const btn = leftButtonGroup.createEl("button", { text, cls: `debug-button ${cls}` });
      btn.addEventListener("click", () => {
        const newVal = Math.max(0, getValue() + change);
        setValue(newVal);
        valueSpan.textContent = `${newVal}`;
      });
    });
    const valueSpan = buttonContainer.createEl("span", { text: `${getValue()}`, cls: "stat-value" });
    const rightButtonGroup = buttonContainer.createDiv("stat-button-group");
    buttons.slice(2).forEach(({ text, change, cls }) => {
      const btn = rightButtonGroup.createEl("button", { text, cls: `debug-button ${cls}` });
      btn.addEventListener("click", () => {
        const newVal = Math.max(0, getValue() + change);
        setValue(newVal);
        valueSpan.textContent = `${newVal}`;
      });
    });
  }
  renderOwnedItems(containerEl) {
    containerEl.empty();
    this.plugin.statCardData.ownedItems.forEach((itemId) => {
      const div = containerEl.createDiv("owned-item");
      div.createEl("span", { text: itemId });
      const removeBtn = div.createEl("button", { text: "Remove", cls: "debug-button" });
      removeBtn.addEventListener("click", () => {
        this.plugin.statCardData.ownedItems = this.plugin.statCardData.ownedItems.filter((id) => id !== itemId);
        this.renderOwnedItems(containerEl);
      });
    });
  }
  renderTitlesList(containerEl) {
    containerEl.empty();
    if (this.plugin.statCardData.titles.length === 0) {
      containerEl.createEl("p", { text: "No titles unlocked yet.", cls: "debug-empty-message" });
      return;
    }
    this.plugin.statCardData.titles.forEach((title) => {
      const titleDiv = containerEl.createDiv("title-item");
      titleDiv.createEl("h4", { text: title.name });
      titleDiv.createEl("p", { text: title.description, cls: "title-description" });
      const unlockDate = new Date(title.unlockedAt).toLocaleDateString();
      titleDiv.createEl("p", { text: `Unlocked on: ${unlockDate}`, cls: "title-unlock-date" });
      if (title.effect.length > 0) {
        const effectsList = titleDiv.createEl("ul", { cls: "title-effects-list" });
        title.effect.forEach((effect) => {
          effectsList.createEl("li", { text: effect });
        });
      }
      const removeBtn = titleDiv.createEl("button", { text: "Remove", cls: "debug-button" });
      removeBtn.addEventListener("click", () => {
        this.plugin.statCardData.titles = this.plugin.statCardData.titles.filter((t) => t.id !== title.id);
        this.renderTitlesList(containerEl);
      });
      titleDiv.appendChild(removeBtn);
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// settings/settings-tab.ts
var import_obsidian14 = require("obsidian");

// support/notificationListener.ts
var import_obsidian13 = require("obsidian");
var NotificationModal = class extends import_obsidian13.Modal {
  constructor(app, notificationListener) {
    super(app);
    this.notificationListener = notificationListener;
  }
  onOpen() {
    const { contentEl } = this;
    this.createNotificationViewer(contentEl);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  createNotificationViewer(containerEl) {
    containerEl.empty();
    containerEl.createEl("h2", { text: "Notification History" });
    const notifications = this.notificationListener.getNotifications();
    const notificationContainer = containerEl.createEl("div", { cls: "notification-container" });
    if (notifications.length === 0) {
      notificationContainer.createEl("p", {
        text: "No notifications have been captured yet.",
        cls: "no-notifications"
      });
      return;
    }
    notifications.forEach((notification) => {
      const card = notificationContainer.createEl("div", { cls: "notification-card" });
      card.createEl("div", {
        text: notification.text,
        cls: "notification-message"
      });
      card.createEl("div", {
        text: notification.timestamp,
        cls: "notification-timestamp"
      });
    });
  }
};
var NotificationListener = class {
  constructor(plugin, settings) {
    this.observers = [];
    this.storedNotifications = [];
    this.plugin = plugin;
    this.settings = settings;
    this.app = plugin.app;
  }
  initialize() {
    const parent = document.querySelector("body");
    this.startObserving(parent, "notice");
  }
  cleanup() {
    this.observers.forEach((obs) => {
      obs.disconnect();
    });
    this.observers = [];
  }
  startObserving(domNode, classToLookFor) {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        const elementAdded = Array.from(mutation.addedNodes).some(
          (element) => {
            if (element.classList) {
              return element.classList.contains(classToLookFor);
            }
            return false;
          }
        );
        if (elementAdded && this.settings.enableNotificationCapture) {
          mutation.addedNodes.forEach((notice) => {
            var _a;
            if ((_a = notice.classList) == null ? void 0 : _a.contains(classToLookFor)) {
              this.captureNotification(notice.textContent || "");
            }
          });
        }
      });
    });
    observer.observe(domNode, {
      childList: true,
      attributes: false,
      characterData: false,
      subtree: true
    });
    this.observers.push(observer);
  }
  captureNotification(text) {
    if (!text || /^\d+$/.test(text.trim())) {
      return;
    }
    const messagesToIgnore = [
      "Scan complete! No new completed tasks found.",
      "Manual scan started.",
      "0 tasks currently processing",
      "Connection successful!"
    ];
    if (messagesToIgnore.includes(text.trim())) {
      return;
    }
    const notification = {
      text,
      timestamp: (0, import_obsidian13.moment)().format("YYYY-MM-DD HH:mm:ss")
    };
    this.storedNotifications.unshift(notification);
    if (this.storedNotifications.length > this.settings.maxNotificationsToStore) {
      this.storedNotifications = this.storedNotifications.slice(
        0,
        this.settings.maxNotificationsToStore
      );
    }
    this.saveNotifications();
  }
  async saveNotifications() {
    const existingData = await this.plugin.loadData() || {};
    await this.plugin.saveData({
      ...existingData,
      notifications: this.storedNotifications
    });
  }
  async loadNotifications() {
    const data = await this.plugin.loadData();
    this.storedNotifications = (data == null ? void 0 : data.notifications) || [];
  }
  getNotifications() {
    return this.storedNotifications;
  }
  clearNotifications() {
    this.storedNotifications = [];
    this.saveNotifications();
  }
  getLastNotifications(count) {
    return this.storedNotifications.slice(0, count);
  }
  openNotificationModal() {
    new NotificationModal(this.app, this).open();
  }
};
function addNotificationSettingsUI(containerEl, plugin, notificationListener, settings, saveSettings) {
  new import_obsidian13.Setting(containerEl).setName("Enable notification capture").setDesc("Capture and store notifications for later viewing").addToggle((toggle) => toggle.setValue(settings.enableNotificationCapture).onChange(async (value) => {
    settings.enableNotificationCapture = value;
    await saveSettings();
  }));
  new import_obsidian13.Setting(containerEl).setName("Maximum notifications to store").setDesc("Set the number of most recent notifications to keep").addSlider((slider) => slider.setLimits(10, 500, 10).setValue(settings.maxNotificationsToStore).setDynamicTooltip().onChange(async (value) => {
    settings.maxNotificationsToStore = value;
    await saveSettings();
  }));
  new import_obsidian13.Setting(containerEl).setName("View notification history").setDesc("Open a window showing all captured notifications").addButton((button) => button.setButtonText("View History").onClick(() => {
    notificationListener.openNotificationModal();
  }));
  new import_obsidian13.Setting(containerEl).setName("Clear stored notifications").setDesc("Remove all currently stored notifications").addButton((button) => button.setButtonText("Clear").onClick(() => {
    notificationListener.clearNotifications();
    new import_obsidian13.Notice("Notification history cleared");
  }));
}

// settings/settings-tab.ts
var GamifySettingTab = class extends import_obsidian14.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.achievementsService = this.plugin.achievementsService;
  }
  hasSystemControlAccess() {
    return this.plugin.statCardData.ownedItems && this.plugin.statCardData.ownedItems.includes("system_control");
  }
  hasTagAccess() {
    return this.plugin.statCardData.ownedItems && this.plugin.statCardData.ownedItems.includes("tagger");
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian14.Setting(containerEl).setName("Tracked Notes").setHeading();
    const trackedNotesContainer = containerEl.createDiv();
    if (this.plugin.settings.trackedNotes.length === 0) {
      trackedNotesContainer.createEl("p", {
        text: 'No notes are currently being tracked. Use the "Track Current Note for Tasks" command to start tracking notes.'
      });
    } else {
      const ul = trackedNotesContainer.createEl("ul", { cls: "gamify-tracked-notes" });
      this.plugin.settings.trackedNotes.forEach((path2) => {
        const li = ul.createEl("li", { cls: "gamify-tracked-note" });
        li.createEl("span", { text: path2 });
        const removeButton = li.createEl("button", {
          text: "Remove",
          cls: "gamify-remove-button"
        });
        removeButton.addEventListener("click", async () => {
          this.plugin.settings.trackedNotes = this.plugin.settings.trackedNotes.filter((p) => p !== path2);
          await this.plugin.saveSettings();
          this.display();
        });
      });
    }
    new import_obsidian14.Setting(containerEl).setName("XP/Point Modifier").setHeading();
    if (!this.hasSystemControlAccess()) {
      const notice = containerEl.createEl("div", {
        cls: "setting-item-description",
        text: "You do not have permission to modify this settings."
      });
    }
    new import_obsidian14.Setting(containerEl).setName("XP per character").setDesc("How much XP is earned for each character typed.").addText((text) => {
      text.setValue(this.plugin.settings.xpPerCharacter.toString());
      if (!this.hasSystemControlAccess()) {
        text.setDisabled(true);
        text.inputEl.title = "Permission Required.";
      } else {
        text.onChange(async (value) => {
          this.plugin.settings.xpPerCharacter = parseFloat(value) || 0.1;
          await this.plugin.saveSettings();
        });
      }
    });
    new import_obsidian14.Setting(containerEl).setName("Base points value").setDesc("Base points awarded for completing a task.").addText((text) => {
      text.setValue(this.plugin.settings.pointsBaseValue.toString());
      if (!this.hasSystemControlAccess()) {
        text.setDisabled(true);
        text.inputEl.title = "Permission Required.";
      } else {
        text.onChange(async (value) => {
          this.plugin.settings.pointsBaseValue = parseInt(value) || 10;
          await this.plugin.saveSettings();
        });
      }
    });
    new import_obsidian14.Setting(containerEl).setName("Tag Multipliers").setHeading();
    if (!(this.hasSystemControlAccess() || this.hasTagAccess())) {
      const notice = containerEl.createEl("div", {
        cls: "setting-item-description",
        text: "You do not have permission to modify this settings."
      });
    }
    Object.entries(this.plugin.settings.tagMultipliers).forEach(([tag, multiplier]) => {
      const setting = new import_obsidian14.Setting(containerEl).setName(`Multiplier for ${tag}`).setDesc(`Multiplier for tasks with the ${tag} tag.`).addText((text) => {
        text.setValue(multiplier.toString());
        if (!(this.hasSystemControlAccess() || this.hasTagAccess())) {
          text.setDisabled(true);
          text.inputEl.title = "Permission Required.";
        } else {
          text.onChange(async (value) => {
            this.plugin.settings.tagMultipliers[tag] = parseFloat(value) || 1;
            await this.plugin.saveSettings();
          });
        }
      });
      if (this.hasSystemControlAccess() || !this.hasTagAccess()) {
        setting.addButton((button) => button.setButtonText("Remove").onClick(async () => {
          delete this.plugin.settings.tagMultipliers[tag];
          await this.plugin.saveSettings();
          this.display();
        }));
      }
    });
    if (this.hasSystemControlAccess() || !this.hasTagAccess()) {
      const newTagSetting = new import_obsidian14.Setting(containerEl).setName("Add new tag multiplier").setDesc("Add a new tag and its point multiplier.");
      let newTagInput = null;
      let newMultiplierInput = null;
      newTagSetting.addText((text) => {
        text.setPlaceholder("#tag");
        text.setValue("");
        newTagInput = text.inputEl;
      });
      newTagSetting.addText((text) => {
        text.setPlaceholder("multiplier");
        text.setValue("1.0");
        newMultiplierInput = text.inputEl;
        newMultiplierInput.addEventListener("input", () => {
          if (!this.hasSystemControlAccess()) {
            let value = parseFloat(newMultiplierInput.value) || 1;
            if (value > 10) {
              newMultiplierInput.value = "10";
            }
          }
        });
      });
      newTagSetting.addButton((button) => button.setButtonText("Add").onClick(async () => {
        if (newTagInput && newMultiplierInput) {
          const tag = newTagInput.value;
          let multiplier = parseFloat(newMultiplierInput.value) || 1;
          if (!this.hasSystemControlAccess() && multiplier > 10) {
            multiplier = 10;
            new import_obsidian14.Notice("Maximum tag multiplier limit is 10.");
          }
          const cost = multiplier * 10;
          if (this.plugin.statCardData.points >= cost) {
            if (tag && tag.startsWith("#")) {
              this.plugin.statCardData.points -= cost;
              this.plugin.settings.tagMultipliers[tag] = multiplier;
              await this.plugin.saveSettings();
              this.display();
              new import_obsidian14.Notice(`New tag added for ${cost} points!`);
            }
          } else {
            new import_obsidian14.Notice("Not enough points to add this tag!");
          }
        }
      }));
    }
    new import_obsidian14.Setting(containerEl).setName("Task Assessment").setHeading();
    new import_obsidian14.Setting(containerEl).setName("Scan Completed Tasks").setDesc("Find and assess all completed tasks that have not been logged.").addButton((button) => button.setButtonText("Scan Completed").onClick(async () => {
      await this.plugin.taskAssessmentService.assessCompletedTasks();
    }));
    new import_obsidian14.Setting(containerEl).setName("Scan Interval (minutes)").setDesc("Set how often progress is saved and completed tasks are scanned.").addDropdown((dropdown) => {
      ["1", "5", "10", "15", "30", "60"].forEach((value) => {
        dropdown.addOption(value, `${value} minutes`);
      });
      dropdown.setValue(this.plugin.settings.scanInterval.toString());
      dropdown.onChange(async (value) => {
        this.plugin.settings.scanInterval = parseInt(value);
        await this.plugin.saveSettings();
        this.plugin.startPeriodicScanning();
      });
    });
    new import_obsidian14.Setting(containerEl).setName("Deduct Points for Unchecking Tasks").setDesc("When a completed task is unchecked, deduct the awarded points.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.deductPointsForUnchecking);
      if (!this.hasSystemControlAccess()) {
        toggle.setDisabled(true);
        toggle.toggleEl.title = "Permission Required.";
      } else {
        toggle.onChange(async (value) => {
          this.plugin.settings.deductPointsForUnchecking = value;
          await this.plugin.saveSettings();
        });
      }
    });
    new import_obsidian14.Setting(containerEl).setName("LLM API").setHeading();
    new import_obsidian14.Setting(containerEl).setName("API URL").setDesc("URL of your local LLM API.").addText((text) => text.setValue(this.plugin.settings.apiUrl).onChange(async (value) => {
      this.plugin.settings.apiUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("API Key").setDesc("API key for authentication (if required).").addText((text) => text.setValue(this.plugin.settings.apiKey).setPlaceholder("your-api-key").onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Test Connection").setDesc("Test the connection to your LLM API.").addButton((button) => button.setButtonText("Test Connection").onClick(async () => {
      const connectionTest = await this.plugin.testConnection();
      if (connectionTest) {
        new import_obsidian14.Notice("Connection successful!");
        const models = await this.plugin.fetchAvailableModels();
        this.plugin.availableModels = models;
        this.updateModelDropdown();
      } else {
        new import_obsidian14.Notice("Connection failed. Please check your API URL and key.");
      }
    }));
    const modelSetting = new import_obsidian14.Setting(containerEl).setName("LLM Model").setDesc("Select which LLM model to use for task assessment.");
    this.modelDropdown = document.createElement("select");
    this.modelDropdown.classList.add("dropdown");
    this.modelDropdown.value = this.plugin.settings.selectedLLMModel;
    this.modelDropdown.addEventListener("change", async () => {
      this.plugin.settings.selectedLLMModel = this.modelDropdown.value;
      await this.plugin.saveSettings();
    });
    const defaultOption = document.createElement("option");
    defaultOption.value = this.plugin.settings.selectedLLMModel;
    defaultOption.text = this.plugin.settings.selectedLLMModel;
    this.modelDropdown.appendChild(defaultOption);
    modelSetting.controlEl.appendChild(this.modelDropdown);
    new import_obsidian14.Setting(containerEl).setName("Enable LLM").setDesc("Turn on LLM-powered features.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.LLM_param.enabled).onChange(async (value) => {
        this.plugin.settings.LLM_param.enabled = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.LLM_param.enabled) {
      const llmSettingsContainer = containerEl.createDiv({ cls: "llm-settings-container" });
      new import_obsidian14.Setting(llmSettingsContainer).setName("Temperature").setDesc("Controls randomness of LLM responses (0 = deterministic, 1 = very random).").addText(
        (text) => text.setPlaceholder("0.7").setValue(this.plugin.settings.LLM_param.temp.toString()).onChange(async (value) => {
          const parsedValue = parseFloat(value);
          if (!isNaN(parsedValue)) {
            this.plugin.settings.LLM_param.temp = parsedValue;
            await this.plugin.saveSettings();
          }
        })
      );
      new import_obsidian14.Setting(llmSettingsContainer).setName("Max Tokens").setDesc("Set the maximum number of tokens the LLM should generate per request.").addText(
        (text) => text.setPlaceholder("300").setDisabled(true).setValue(this.plugin.settings.LLM_param.max_tokens.toString()).onChange(async (value) => {
          const parsedValue = parseInt(value);
          if (!isNaN(parsedValue)) {
            this.plugin.settings.LLM_param.max_tokens = parsedValue;
            await this.plugin.saveSettings();
          }
        })
      );
      new import_obsidian14.Setting(llmSettingsContainer).setName("Enable Streaming").setDesc("Stream LLM responses in real-time.").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.LLM_param.stream).setDisabled(true).onChange(async (value) => {
          this.plugin.settings.LLM_param.stream = value;
          await this.plugin.saveSettings();
        })
      );
    }
    new import_obsidian14.Setting(containerEl).setName("Enable Rate Limiting").setDesc("Limit the rate of requests to the LLM API to avoid issues.").addToggle((toggle) => toggle.setValue(this.plugin.settings.rateLimiting.enabled).onChange(async (value) => {
      this.plugin.settings.rateLimiting.enabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Requests Per Minute").setDesc("Maximum number of requests to send per minute (1-60).").addSlider((slider) => slider.setLimits(1, 60, 1).setValue(this.plugin.settings.rateLimiting.requestsPerMinute).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.rateLimiting.requestsPerMinute = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Support").setHeading();
    new import_obsidian14.Setting(containerEl).setName("Task Scan Button").setDesc("Toggle the Task Scan button in the ribbon").addToggle((toggle) => toggle.setValue(this.plugin.settings.ribbonButtons.taskScan).onChange(async (value) => {
      this.plugin.settings.ribbonButtons.taskScan = value;
      await this.plugin.saveSettings();
      this.plugin.ribbonManager.updateRibbonIcons();
    }));
    new import_obsidian14.Setting(containerEl).setName("Inventory Button").setDesc("Toggle the Inventory button in the ribbon").addToggle((toggle) => toggle.setValue(this.plugin.settings.ribbonButtons.inventory).onChange(async (value) => {
      this.plugin.settings.ribbonButtons.inventory = value;
      await this.plugin.saveSettings();
      this.plugin.ribbonManager.updateRibbonIcons();
    }));
    new import_obsidian14.Setting(containerEl).setName("Store Button").setDesc("Toggle the Store button in the ribbon").addToggle((toggle) => toggle.setValue(this.plugin.settings.ribbonButtons.store).onChange(async (value) => {
      this.plugin.settings.ribbonButtons.store = value;
      await this.plugin.saveSettings();
      this.plugin.ribbonManager.updateRibbonIcons();
    }));
    new import_obsidian14.Setting(containerEl).setName("Request Button").setDesc("Toggle the Request button in the ribbon").addToggle((toggle) => toggle.setValue(this.plugin.settings.ribbonButtons.request).onChange(async (value) => {
      this.plugin.settings.ribbonButtons.request = value;
      await this.plugin.saveSettings();
      this.plugin.ribbonManager.updateRibbonIcons();
    }));
    new import_obsidian14.Setting(containerEl).setName("Achievements Button").setDesc("Toggle the Achievements button in the ribbon").addToggle((toggle) => toggle.setValue(this.plugin.settings.ribbonButtons.achievements).onChange(async (value) => {
      this.plugin.settings.ribbonButtons.achievements = value;
      await this.plugin.saveSettings();
      this.plugin.ribbonManager.updateRibbonIcons();
    }));
    new import_obsidian14.Setting(containerEl).setName("Refresh Button").setDesc("Toggle the Refresh UI button in the ribbon").addToggle((toggle) => toggle.setValue(this.plugin.settings.ribbonButtons.refresh).onChange(async (value) => {
      this.plugin.settings.ribbonButtons.refresh = value;
      await this.plugin.saveSettings();
      this.plugin.ribbonManager.updateRibbonIcons();
    }));
    new import_obsidian14.Setting(containerEl).setName("Reload Plugin Button").setDesc("Toggle the Reload Plugin button in the ribbon").addToggle((toggle) => toggle.setValue(this.plugin.settings.ribbonButtons.reload).onChange(async (value) => {
      this.plugin.settings.ribbonButtons.reload = value;
      await this.plugin.saveSettings();
      this.plugin.ribbonManager.updateRibbonIcons();
    }));
    new import_obsidian14.Setting(containerEl).setName("Settings Button").setDesc("Toggle the Settings button in the ribbon").addToggle((toggle) => toggle.setValue(this.plugin.settings.ribbonButtons.settings).onChange(async (value) => {
      this.plugin.settings.ribbonButtons.settings = value;
      await this.plugin.saveSettings();
      this.plugin.ribbonManager.updateRibbonIcons();
    }));
    new import_obsidian14.Setting(containerEl).setName("Notification Logging").setHeading();
    addNotificationSettingsUI(
      containerEl,
      this.plugin,
      this.plugin.notificationListener,
      this.plugin.settings.notification,
      async () => await this.plugin.saveSettings()
    );
    new import_obsidian14.Setting(containerEl).setName("Data Reset").setHeading();
    new import_obsidian14.Setting(containerEl).setName("Reset Completed Tasks").setDesc("Clear the list of completed tasks.").addButton((button) => {
      button.setButtonText("Reset Task Completion Count").setWarning();
      if (!this.hasSystemControlAccess()) {
        button.setDisabled(true);
        button.buttonEl.title = "Permission Required.";
      } else {
        button.onClick(async () => {
          if (this.plugin.statCardData && this.plugin.statCardData.stats) {
            const confirm2 = await new Promise((resolve) => {
              const modal = new ConfirmationModal(
                this.app,
                "Reset Completed Tasks",
                "Are you sure you want to reset completed tasks? This cannot be undone!",
                resolve
              );
              modal.open();
            });
            if (confirm2) {
              this.plugin.statCardData.stats.tasksCompleted = 0;
              await this.plugin.saveStatCardData();
              this.display();
              new import_obsidian14.Notice("Task completion history has been reset.");
              this.plugin.statCardService.refreshUI();
            }
          } else {
            new import_obsidian14.Notice("Stats data not available.");
          }
        });
      }
    });
    new import_obsidian14.Setting(containerEl).setName("Reset Progress").setDesc("Warning: This will reset all your progress!").addButton((button) => button.setButtonText("Reset All Progress").setWarning().onClick(async () => {
      const confirm2 = await new Promise((resolve) => {
        const modal = new ConfirmationModal(
          this.app,
          "Reset Progress",
          "Are you sure you want to reset all progress? This cannot be undone!",
          resolve
        );
        modal.open();
      });
      if (confirm2) {
        this.plugin.initializeDefaultStatCardData();
        await this.plugin.saveStatCardData();
        this.display();
        new import_obsidian14.Notice("All progress has been reset.");
        this.plugin.statCardService.refreshUI();
      }
    }));
    containerEl.createEl("h2", { text: "Debug Settings" });
    new import_obsidian14.Setting(containerEl).setName("Enable Debug Mode").setDesc("Enables debug features.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.debugMode);
      if (!this.hasSystemControlAccess()) {
        toggle.setDisabled(true);
        toggle.toggleEl.title = "Permission Required.";
      } else {
        toggle.onChange(async (value) => {
          this.plugin.settings.debugMode = value;
          await this.plugin.saveSettings();
        });
      }
    });
    if (this.plugin.settings.debugMode) {
      const debugDesc = containerEl.createEl("div", {
        cls: "setting-item-description",
        text: "Debug mode is enabled."
      });
      if (this.plugin.hasDebugPermission()) {
        const openDebugBtn = containerEl.createEl("button", {
          text: "Open Debug Menu",
          cls: "mod-cta"
        });
        openDebugBtn.addEventListener("click", () => {
          new DebugMenu(this.app, this.plugin).open();
        });
      } else {
        const warningDiv = containerEl.createEl("div", {
          cls: "setting-item-description",
          text: "You need be a Debugger to access debug features."
        });
      }
    }
  }
  updateModelDropdown() {
    if (!this.modelDropdown) return;
    while (this.modelDropdown.firstChild) {
      this.modelDropdown.removeChild(this.modelDropdown.firstChild);
    }
    if (this.plugin.availableModels && this.plugin.availableModels.length > 0) {
      this.plugin.availableModels.forEach((model) => {
        const option = document.createElement("option");
        option.value = model.id;
        option.text = model.id;
        if (model.id === this.plugin.settings.selectedLLMModel) {
          option.selected = true;
        }
        this.modelDropdown.appendChild(option);
      });
      if (!this.plugin.availableModels.some((m) => m.id === this.plugin.settings.selectedLLMModel)) {
        const option = document.createElement("option");
        option.value = this.plugin.settings.selectedLLMModel;
        option.text = this.plugin.settings.selectedLLMModel + " (not found)";
        option.selected = true;
        this.modelDropdown.appendChild(option);
      }
    } else {
      const option = document.createElement("option");
      option.value = this.plugin.settings.selectedLLMModel;
      option.text = this.plugin.settings.selectedLLMModel;
      this.modelDropdown.appendChild(option);
    }
  }
};
var ConfirmationModal = class extends import_obsidian14.Modal {
  constructor(app, title, message, result) {
    super(app);
    this.result = result;
    this.message = message;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Confirmation" });
    contentEl.createEl("p", { text: this.message });
    const buttonContainer = contentEl.createDiv();
    buttonContainer.addClass("modal-button-container");
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.result(false);
      this.close();
    });
    const confirmButton = buttonContainer.createEl("button", { text: "Confirm" });
    confirmButton.addClass("mod-warning");
    confirmButton.addEventListener("click", () => {
      this.result(true);
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// features/achievements.ts
var import_obsidian15 = require("obsidian");
var ACHIEVEMENT_VIEW_TYPE = "gamify-achievements-view";
var ACHIEVEMENTS_ICON = `<svg viewBox="0 0 100 100" width="100" height="100" xmlns="http://www.w3.org/2000/svg">
  <circle cx="50" cy="50" r="40" fill="none" stroke="currentColor" stroke-width="5"/>
  <polygon points="50,20 58,38 78,40 64,54 68,74 50,64 32,74 36,54 22,40 42,38" fill="currentColor"/>
</svg>`;
var AchievementsView = class extends import_obsidian15.ItemView {
  constructor(leaf, plugin, achievementsService) {
    super(leaf);
    this.plugin = plugin;
    this.achievementsService = achievementsService;
  }
  getViewType() {
    return ACHIEVEMENT_VIEW_TYPE;
  }
  getDisplayText() {
    return "Achievements";
  }
  async onOpen() {
    this.displayAchievements();
  }
  async onClose() {
  }
  displayAchievements() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gamify-achievements-view");
    const header = contentEl.createEl("h2", { text: "Achievements" });
    const achievementsContainer = contentEl.createDiv("gamify-achievements-container");
    const achievementsList = achievementsContainer.createEl("ul", { cls: "gamify-achievements-list" });
    const allAchievements = [
      ...this.achievementsService.getDefaultAchievements(),
      ...this.achievementsService.getCustomAchievements()
    ];
    allAchievements.sort((a, b) => {
      const isAUnlocked = this.plugin.statCardData.achievements.some((ach) => ach.id === a.id);
      const isBUnlocked = this.plugin.statCardData.achievements.some((ach) => ach.id === b.id);
      return Number(isBUnlocked) - Number(isAUnlocked);
    });
    allAchievements.forEach((achievement) => {
      const isUnlocked = this.plugin.statCardData.achievements.some((a) => a.id === achievement.id);
      const achievementItem = achievementsList.createEl("li", { cls: "gamify-achievement-item" });
      if (isUnlocked) {
        achievementItem.addClass("unlocked");
      } else {
        achievementItem.addClass("locked");
      }
      const achievementHeader = achievementItem.createDiv("gamify-achievement-header");
      achievementHeader.createEl("span", {
        text: achievement.name,
        cls: "gamify-achievement-name"
      });
      achievementItem.createEl("p", {
        text: achievement.description,
        cls: "gamify-achievement-description"
      });
      const tooltipContent = this.createTooltipContent(achievement, isUnlocked);
      let activeMenu = null;
      achievementItem.addEventListener("mouseenter", (event) => {
        activeMenu = new import_obsidian15.Menu();
        activeMenu.addItem((item) => {
          item.setTitle(tooltipContent);
          item.setDisabled(true);
        });
        activeMenu.showAtMouseEvent(event);
      });
      achievementItem.addEventListener("mouseleave", () => {
        if (activeMenu) {
          activeMenu.hide();
        }
      });
    });
  }
  createTooltipContent(achievement, isUnlocked) {
    if (isUnlocked) {
      let content = `Condition: `;
      switch (achievement.condition.type) {
        case "writing":
          content += `Write ${achievement.condition.value} characters`;
          break;
        case "tasks_completed":
          content += `Complete ${achievement.condition.value} tasks`;
          break;
        case "streak":
          content += `Maintain a streak of ${achievement.condition.value} days`;
          break;
        case "level":
          content += `Reach level ${achievement.condition.value}`;
          break;
        case "notes_created":
          content += `Create ${achievement.condition.value} notes`;
          break;
        case "items_purchased":
          content += `Purchase ${achievement.condition.value} items`;
          break;
        case "point_collected":
          content += `Collect ${achievement.condition.value} points`;
          break;
        default:
          content += `Unknown condition type: ${achievement.condition.type}`;
      }
      content += `, Reward: `;
      switch (achievement.reward.type) {
        case "xp":
          content += `${achievement.reward.value} XP`;
          break;
        case "points":
          content += `${achievement.reward.value} Points`;
          break;
        case "title":
          content += `Title: ${achievement.reward.value}`;
          break;
        case "temp_xp_multiplier":
          content += `+${Math.round((achievement.reward.value - 1) * 100)}% XP for 24 hours`;
          break;
        case "perm_xp_multiplier":
          content += `+${Math.round((achievement.reward.value - 1) * 100)}% XP (365 days)`;
          break;
        case "temp_discount":
          content += `${Math.round(achievement.reward.value * 100)}% store discount for 24 hours`;
          break;
        case "perm_discount":
          content += `${Math.round(achievement.reward.value * 100)}% store discount (365 days)`;
          break;
        default:
          content += `Unknown reward type: ${achievement.reward.type}`;
      }
      return content;
    } else {
      return `Locked`;
    }
  }
};
var AchievementsService = class {
  constructor(plugin) {
    this.customAchievements = [];
    this.defaultAchievements = [];
    this.plugin = plugin;
  }
  async initialize() {
    await this.loadCustomAchievements();
    await this.createDefaultAchievementsIfNeeded();
    this.checkForAchievements();
    this.registerAchievementsView();
  }
  registerAchievementsView() {
    this.plugin.registerView(
      ACHIEVEMENT_VIEW_TYPE,
      (leaf) => new AchievementsView(leaf, this.plugin, this)
    );
    this.plugin.addCommand({
      id: "open-achievements-view",
      name: "Open Achievements View",
      callback: () => this.openAchievementsView()
    });
    (0, import_obsidian15.addIcon)("achievements-icon", ACHIEVEMENTS_ICON);
  }
  async openAchievementsView() {
    const { workspace } = this.plugin.app;
    const existing = workspace.getLeavesOfType(ACHIEVEMENT_VIEW_TYPE);
    if (existing.length) {
      workspace.revealLeaf(existing[0]);
      return;
    }
    const leaf = workspace.getRightLeaf(false);
    if (leaf) {
      await leaf.setViewState({
        type: ACHIEVEMENT_VIEW_TYPE,
        active: true
      });
      workspace.revealLeaf(leaf);
    }
  }
  async loadCustomAchievements() {
    this.customAchievements = [];
    const folderPath = "QuestLog/Achievements";
    try {
      const files = this.plugin.app.vault.getFiles().filter(
        (file) => file.path.startsWith(folderPath) && file.extension === "json"
      );
      for (const file of files) {
        try {
          const content = await this.plugin.app.vault.read(file);
          const parsedData = JSON.parse(content);
          if (Array.isArray(parsedData)) {
            this.customAchievements.push(...parsedData);
          } else {
            console.warn(`Invalid JSON format in ${file.path}`);
          }
        } catch (error) {
          console.error(`Failed to load custom achievements from ${file.path}:`, error);
        }
      }
      if (this.customAchievements.length === 0) {
        console.warn("No achievements found. Creating default Achievements.json...");
        await this.createDefaultAchievementsFile();
      }
    } catch (error) {
      console.error("Error loading Achievements:", error);
    }
  }
  async createDefaultAchievementsFile() {
    const defaultAchievements = JSON.stringify([
      {
        "id": "Hello World",
        "name": "Hello World",
        "description": "Write something",
        "condition": { "type": "writing", "value": 1 },
        "reward": { "type": "points", "value": 100 }
      }
    ], null, 2);
    try {
      await this.plugin.app.vault.create("QuestLog/Achievements/Achievements_0.json", defaultAchievements);
      console.log("Default Achievements.json created.");
    } catch (error) {
      console.error("Error creating default Achievements.json:", error);
    }
  }
  async createDefaultAchievementsIfNeeded() {
    this.defaultAchievements = [];
  }
  checkForAchievements() {
    const allAchievements = [
      ...this.defaultAchievements,
      ...this.customAchievements
    ];
    allAchievements.forEach((achievement) => {
      if (!this.plugin.statCardData.achievements.some((a) => a.id === achievement.id) && this.isAchievementConditionMet(achievement.condition)) {
        this.plugin.statCardData.achievements.push(achievement);
        this.applyAchievementReward(achievement.reward);
        new import_obsidian15.Notice(`\u{1F389} Achievement Unlocked: ${achievement.name}!`);
      }
    });
  }
  isAchievementConditionMet(condition) {
    switch (condition.type) {
      case "writing":
        return this.plugin.statCardData.writingStats.totalCharactersTyped >= condition.value;
      case "tasks_completed":
        return this.plugin.statCardData.stats.tasksCompleted >= condition.value;
      case "streak":
        return this.plugin.statCardData.streaks.currentStreak >= condition.value;
      case "level":
        return this.plugin.statCardData.level >= condition.value;
      case "notes_created":
        return this.plugin.statCardData.stats.lastFileCount >= condition.value;
      case "items_purchased":
        return this.plugin.statCardData.stats.itemsPurchased >= condition.value;
      case "point_collected":
        return this.plugin.statCardData.stats.totalPointsEarned >= condition.value;
      default:
        return false;
    }
  }
  applyAchievementReward(reward) {
    this.plugin.statCardData.activeEffects = this.plugin.statCardData.activeEffects || {};
    switch (reward.type) {
      case "xp":
        this.plugin.statCardData.xp += reward.value;
        this.plugin.checkForLevelUp();
        break;
      case "points":
        this.plugin.statCardData.points += reward.value;
        break;
      case "title":
        if (!this.plugin.statCardData.titles.some((t) => t.id === reward.value)) {
          this.plugin.statCardData.titles.push({
            id: reward.value,
            name: reward.value,
            description: `Unlocked by an achievement`,
            unlockedAt: (/* @__PURE__ */ new Date()).toISOString(),
            effect: []
          });
        }
        break;
      case "temp_xp_multiplier":
        this.plugin.statCardData.activeEffects.xpMultiplier = {
          value: reward.value,
          expiresAt: Date.now() + 24 * 60 * 60 * 1e3
        };
        new import_obsidian15.Notice(`\u{1F389} XP Boost Activated! +${(reward.value - 1) * 100}% XP for 24 hours!`);
        break;
      case "perm_xp_multiplier":
        this.plugin.statCardData.activeEffects.xpMultiplier = {
          value: reward.value,
          expiresAt: Date.now() + 24 * 60 * 60 * 1e3 * 365
        };
        new import_obsidian15.Notice(`Semi-Permanent XP Boost! You now gain +${(reward.value - 1) * 100}% more XP for 365 days.`);
        break;
      case "temp_discount":
        this.plugin.statCardData.activeEffects.storeDiscount = {
          value: reward.value,
          expiresAt: Date.now() + 24 * 60 * 60 * 1e3
        };
        new import_obsidian15.Notice(`\u{1F4B0} You unlocked a ${reward.value * 100}% discount on purchases for 24 hours!`);
        break;
      case "perm_discount":
        this.plugin.statCardData.activeEffects.storeDiscount = {
          value: reward.value,
          expiresAt: Date.now() + 24 * 60 * 60 * 1e3 * 365
        };
        new import_obsidian15.Notice(`\u{1F6D2} Semi-Permanent Discount! All items are now ${reward.value * 100}% cheaper for 365 days.`);
        break;
      default:
        new import_obsidian15.Notice(`You obtained an unknown reward.`);
        console.warn(`Unknown reward type: ${reward.type}`);
    }
  }
  getCustomAchievements() {
    return this.customAchievements;
  }
  getDefaultAchievements() {
    return this.defaultAchievements;
  }
};

// core/ribbon.ts
var import_obsidian16 = require("obsidian");
var RibbonManager = class {
  constructor(plugin) {
    this.ribbonIcons = /* @__PURE__ */ new Map();
    this.plugin = plugin;
  }
  async initialize() {
    if (this.plugin.settings.ribbonButtons.taskScan) {
      await this.addTaskScanButton();
    }
    if (this.plugin.settings.ribbonButtons.inventory) {
      await this.addInventoryButton();
    }
    if (this.plugin.settings.ribbonButtons.store) {
      await this.addStoreButton();
    }
    if (this.plugin.settings.ribbonButtons.request) {
      await this.addRequestButton();
    }
    if (this.plugin.settings.ribbonButtons.achievements) {
      await this.addAchievementsRibbonIcon();
    }
    if (this.plugin.settings.ribbonButtons.refresh) {
      await this.addRefreshButton();
    }
    if (this.plugin.settings.ribbonButtons.reload) {
      await this.addReloadButton();
    }
    if (this.plugin.settings.ribbonButtons.settings) {
      await this.addSettingsButton();
    }
    if (this.plugin.settings.ribbonButtons.notifications) {
      this.addNotificationsButton();
    }
    this.addCrafterButton();
  }
  updateRibbonIcons() {
    this.removeAllRibbonIcons();
    this.initialize();
  }
  removeAllRibbonIcons() {
    for (const [id, element] of this.ribbonIcons) {
      element.remove();
    }
    this.ribbonIcons.clear();
  }
  addRibbonIconWithTracking(icon, title, callback) {
    const ribbonIcon = this.plugin.addRibbonIcon(icon, title, callback);
    this.ribbonIcons.set(title, ribbonIcon);
    return ribbonIcon;
  }
  async addTaskScanButton() {
    this.addRibbonIconWithTracking("check-circle", "Scan for Tasks", () => {
      this.plugin.taskAssessmentService.assessCompletedTasks();
      new import_obsidian16.Notice("Manual scan started.");
    });
  }
  addNotificationsButton() {
    this.addRibbonIconWithTracking("bell", "Notification History", () => {
      new NotificationModal(this.plugin.app, this.plugin.notificationListener).open();
    });
  }
  async addInventoryButton() {
    var _a;
    if ((_a = this.plugin.statCardData.ownedItems) == null ? void 0 : _a.includes("infinite_inventory")) {
      this.addRibbonIconWithTracking("package", "Open Inventory", () => {
        this.plugin.activateInventoryTab();
      });
    }
  }
  async addStoreButton() {
    this.addRibbonIconWithTracking("store", "Open Store", () => {
      new ItemStoreModal(this.plugin.app, this.plugin, this.plugin.itemStoreService).open();
    });
  }
  async addRequestButton() {
    var _a;
    if ((_a = this.plugin.statCardData.ownedItems) == null ? void 0 : _a.includes("mysterious_tablet")) {
      this.addRibbonIconWithTracking("zap", "Request", () => {
        new RedeemTaskModal(this.plugin.app, this.plugin).open();
      });
    }
  }
  addAchievementsRibbonIcon() {
    this.addRibbonIconWithTracking(
      "achievements-icon",
      "Achievements",
      async () => {
        await this.plugin.achievementsService.openAchievementsView();
      }
    );
  }
  async addRefreshButton() {
    this.addRibbonIconWithTracking("refresh-cw", "Refresh VaultQuest UI", () => {
      this.plugin.checkForLevelUp();
      this.plugin.achievementsService.checkForAchievements();
      this.plugin.statCardService.refreshUI();
    });
  }
  async addReloadButton() {
    this.addRibbonIconWithTracking("refresh-ccw-dot", "Reload Plugin", () => {
      this.plugin.app.plugins.disablePlugin(this.plugin.manifest.id);
      this.plugin.app.plugins.enablePlugin(this.plugin.manifest.id);
    });
  }
  async addCrafterButton() {
    this.addRibbonIconWithTracking("hammer", "Open Item Crafter", () => {
      new ItemCrafterModal(this.plugin.app, this.plugin).open();
    });
  }
  async addSettingsButton() {
    this.addRibbonIconWithTracking("settings", "Open Plugin Settings", () => {
      this.plugin.app.setting.open();
      this.plugin.app.setting.openTabById(this.plugin.manifest.id);
    });
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  xpPerCharacter: 0.1,
  pointsBaseValue: 10,
  tagMultipliers: {
    "#easy": 0.5,
    "#medium": 1,
    "#hard": 2,
    "#veryhard": 5
  },
  apiUrl: "http://localhost:1234",
  apiKey: "your-api-key",
  themeId: "gamesystem",
  useStatusBarIndicator: true,
  useRibbonIndicator: true,
  trackedNotes: [],
  selectedLLMModel: "local-model",
  rateLimiting: {
    enabled: true,
    requestsPerMinute: 10
    //minutes
  },
  LLM_param: {
    enabled: false,
    temp: 0.7,
    max_tokens: 300,
    stream: false
  },
  scanInterval: 5,
  //minutes
  deductPointsForUnchecking: true,
  debugMode: false,
  enableInventoryTab: true,
  inventoryPositions: {},
  ribbonButtons: {
    taskScan: true,
    inventory: true,
    store: true,
    request: true,
    achievements: true,
    refresh: true,
    reload: false,
    settings: true
  },
  notification: {
    maxNotificationsToStore: 50,
    enableNotificationCapture: true
  }
};
var GamifyPlugin = class extends import_obsidian17.Plugin {
  constructor() {
    super(...arguments);
    this.availableModels = [];
    this.requestQueue = [];
    this.processingQueue = false;
    this.lastRequestTime = 0;
    this.inventoryView = null;
    this.scanIntervalId = null;
    this.effectsCheckIntervalId = null;
    this.autoSaveIntervalId = null;
  }
  async loadVaultQuestStyles() {
    const styleFile = `${this.manifest.dir}/styles.css`;
    const existing = document.getElementById("vaultquest-stylesheet");
    if (existing) existing.remove();
    try {
      const file = this.app.vault.getAbstractFileByPath(styleFile);
      if (file && file instanceof import_obsidian17.TFile) {
        const content = await this.app.vault.read(file);
        const styleElement = document.createElement("style");
        styleElement.id = "vaultquest-stylesheet";
        styleElement.textContent = content;
        document.head.appendChild(styleElement);
      } else {
        console.warn(`VaultQuest: Stylesheet not found at ${styleFile}`);
      }
    } catch (error) {
      console.error("VaultQuest: Failed to load styles.css", error);
    }
  }
  startAutoSave() {
    if (this.autoSaveIntervalId) clearInterval(this.autoSaveIntervalId);
    this.autoSaveIntervalId = setInterval(() => {
      this.saveStatCardData();
    }, this.settings.scanInterval * 60 * 1e3);
  }
  startPeriodicScanning() {
    if (this.scanIntervalId) clearInterval(this.scanIntervalId);
    this.scanIntervalId = setInterval(() => {
      this.taskAssessmentService.assessCompletedTasks();
    }, this.settings.scanInterval * 60 * 1e3);
  }
  startPeriodicEffectsCheck() {
    if (this.effectsCheckIntervalId) clearInterval(this.effectsCheckIntervalId);
    this.effectsCheckIntervalId = setInterval(() => {
      this.checkForExpiredEffects();
    }, this.settings.scanInterval * 60 * 1e3);
  }
  hasDebugPermission() {
    return this.settings.debugMode && this.statCardData && this.statCardData.titles && this.statCardData.titles.some((titles) => titles.id === "debugger");
  }
  async onload() {
    this.app.workspace.onLayoutReady(async () => {
      await this.loadSettings();
      await this.loadStatCardData();
      this.achievementsService = new AchievementsService(this);
      await this.achievementsService.initialize();
      this.app.workspace.containerEl.classList.add("vaultquest-styles");
      this.statCardService = new StatCardService(this);
      this.llmTaskService = new LLMTaskService(this);
      this.itemStoreService = new ItemStoreService(this);
      this.themeService = new ThemeService(this);
      this.statCardService.initializeUI();
      this.statCardService.refreshUI();
      this.taskAssessmentService = new TaskAssessmentService(this);
      this.startPeriodicScanning();
      this.startPeriodicEffectsCheck();
      this.achievementsService.checkForAchievements();
      new TaskStorageRibbonIcon(this, this.taskAssessmentService);
      this.ribbonManager = new RibbonManager(this);
      await this.ribbonManager.initialize();
      this.processingIndicatorService = new ProcessingIndicatorService(this);
      this.notificationListener = new NotificationListener(this, this.settings.notification);
      await this.notificationListener.loadNotifications();
      this.notificationListener.initialize();
      this.addCommand({
        id: "open-item-crafter",
        name: "Open Item Crafter",
        callback: () => {
          new ItemCrafterModal(this.app, this).open();
        }
      });
      this.addCommand({
        id: "open-notification-history",
        name: "Show Notification History",
        callback: () => {
          new NotificationModal(this.app, this.notificationListener).open();
        }
      });
      this.registerView(
        "inventory-view",
        (leaf) => new InventoryTabView(leaf, this)
      );
      this.typing = {
        characterCount: 0,
        timeout: null
      };
      this.registerDomEvent(document, "keydown", (evt) => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian17.MarkdownView);
        if (view && this.isContentKey(evt)) {
          this.handleTyping();
        }
      });
      this.registerView(
        TASK_STORAGE_VIEW_TYPE,
        (leaf) => new TaskStorageViewer(leaf, this, this.taskAssessmentService)
      );
      this.addCommand({
        id: "open-task-storage",
        name: "Open Task Storage",
        callback: () => {
          this.activateTaskStorageTab();
        }
      });
      new TaskStorageRibbonIcon(this, this.taskAssessmentService);
      this.initializeCommands();
      this.addSettingTab(new GamifySettingTab(this.app, this));
      await this.statCardService.refreshUI();
      this.startAutoSave();
      window.addEventListener("beforeunload", async () => {
        await this.saveStatCardData();
      });
    });
  }
  initializeCommands() {
    this.addCommand({
      id: "track-current-note",
      name: "Track Current Note for Tasks",
      callback: () => this.trackCurrentNote()
    });
    this.addCommand({
      id: "untrack-note",
      name: "Remove Note from Task Tracking",
      callback: () => this.showUntrackNoteModal()
    });
    this.addCommand({
      id: "scan-tasks",
      name: "Scan Completed Tasks",
      callback: () => this.taskAssessmentService.assessCompletedTasks()
    });
    this.addCommand({
      id: "open-inventory",
      name: "Open Inventory",
      callback: () => this.activateInventoryTab()
    });
    this.addCommand({
      id: "open-vq-item-store",
      name: "Open Store",
      callback: () => new ItemStoreModal(this.app, this, this.itemStoreService).open()
    });
    this.addCommand({
      id: "open-debug-menu",
      name: "Open Debug Menu",
      callback: () => {
        if (this.hasDebugPermission()) {
          new DebugMenu(this.app, this).open();
        } else {
          new import_obsidian17.Notice("Debug access denied.");
        }
      }
    });
  }
  async onunload() {
    if (this.typing.timeout) {
      clearTimeout(this.typing.timeout);
      this.processTypingXp();
    }
    if (this.processingIndicatorService) {
      this.processingIndicatorService.destroy();
    }
    if (this.autoSaveIntervalId) {
      clearInterval(this.autoSaveIntervalId);
      this.autoSaveIntervalId = null;
    }
    if (this.scanIntervalId) {
      clearInterval(this.scanIntervalId);
      this.scanIntervalId = null;
    }
    const styleEl = document.getElementById("gamify-styles");
    if (styleEl) styleEl.remove();
    this.app.vault.offref(this.fileChangedEventRef);
    if (this.effectsCheckIntervalId) {
      clearInterval(this.effectsCheckIntervalId);
      this.effectsCheckIntervalId = null;
    }
    this.notificationListener.cleanup();
    await this.saveStatCardData();
  }
  hasInfiniteInventory() {
    var _a;
    return ((_a = this.statCardData.ownedItems) == null ? void 0 : _a.includes("infinite_inventory")) || false;
  }
  updateStreak() {
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    const lastActive = this.statCardData.streaks.lastActiveDate;
    if (lastActive === today) {
      return;
    }
    const yesterday = /* @__PURE__ */ new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayStr = yesterday.toISOString().split("T")[0];
    if (lastActive === yesterdayStr) {
      this.statCardData.streaks.currentStreak += 1;
    } else {
      this.statCardData.streaks.currentStreak = 1;
    }
    if (this.statCardData.streaks.currentStreak > this.statCardData.streaks.longestStreak) {
      this.statCardData.streaks.longestStreak = this.statCardData.streaks.currentStreak;
    }
    this.statCardData.streaks.lastActiveDate = today;
  }
  async activateTaskStorageTab() {
    const { workspace } = this.app;
    const existingLeaves = workspace.getLeavesOfType(TASK_STORAGE_VIEW_TYPE);
    if (existingLeaves.length > 0) {
      workspace.revealLeaf(existingLeaves[0]);
      return;
    }
    const leaf = workspace.getLeaf("tab");
    await leaf.setViewState({ type: TASK_STORAGE_VIEW_TYPE, active: true });
    workspace.revealLeaf(leaf);
  }
  async activateInventoryTab() {
    if (!this.settings.enableInventoryTab) {
      new import_obsidian17.Notice("Inventory tab is disabled in settings");
      return;
    }
    if (!this.hasInfiniteInventory()) {
      new import_obsidian17.Notice("You need to acquire the 'Infinite Inventory' item first!");
      return;
    }
    const existingLeaves = this.app.workspace.getLeavesOfType("inventory-view");
    if (existingLeaves.length > 0) {
      this.app.workspace.revealLeaf(existingLeaves[0]);
      return;
    }
    const leaf = this.app.workspace.getLeaf("tab");
    if (leaf) {
      await leaf.setViewState({
        type: "inventory-view",
        active: true
      });
      this.app.workspace.revealLeaf(leaf);
    }
  }
  isContentKey(evt) {
    return !evt.ctrlKey && !evt.altKey && !evt.metaKey && evt.key.length === 1 && !evt.repeat;
  }
  handleTyping() {
    this.typing.characterCount++;
    if (this.typing.timeout) {
      clearTimeout(this.typing.timeout);
    }
    this.typing.timeout = setTimeout(() => {
      this.processTypingXp();
    }, 2e3);
  }
  processTypingXp() {
    const xpGained = this.typing.characterCount * this.settings.xpPerCharacter;
    this.statCardData.xp += xpGained;
    this.statCardData.writingStats.totalCharactersTyped += this.typing.characterCount;
    this.typing.characterCount = 0;
    this.typing.timeout = null;
    this.checkForLevelUp();
    this.achievementsService.checkForAchievements();
    this.statCardService.refreshUI();
  }
  async trackCurrentNote() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian17.Notice("No active file to track.");
      return;
    }
    const filePath = activeFile.path;
    if (!this.settings.trackedNotes.includes(filePath)) {
      this.settings.trackedNotes.push(filePath);
      await this.saveSettings();
      new import_obsidian17.Notice(`Now tracking "${activeFile.basename}" for tasks.`);
      await this.saveStatCardData();
    } else {
      new import_obsidian17.Notice(`Already tracking "${activeFile.basename}".`);
    }
  }
  async showUntrackNoteModal() {
    if (this.settings.trackedNotes.length === 0) {
      new import_obsidian17.Notice("No notes are currently being tracked.");
      return;
    }
    const modal = new SelectNoteModal(
      this.app,
      this.settings.trackedNotes,
      async (selectedPath) => {
        this.settings.trackedNotes = this.settings.trackedNotes.filter((path2) => path2 !== selectedPath);
        await this.saveSettings();
        new import_obsidian17.Notice(`Stopped tracking "${selectedPath.split("/").pop()}".`);
        await this.saveStatCardData();
      }
    );
    modal.open();
  }
  extractTags(text) {
    const tagRegex = /#[\w-]+/g;
    return text.match(tagRegex) || [];
  }
  async calculatePointsForTask(taskText, tags) {
    try {
      return await this.calculatePointsWithLLM(taskText, tags);
    } catch (error) {
      console.error("Error calculating points with LLM:", error);
      return this.calculateBasicPoints(tags);
    }
  }
  calculateBasicPoints(tags) {
    let multiplier = 1;
    for (const tag of tags) {
      if (this.settings.tagMultipliers[tag]) {
        multiplier = Math.max(multiplier, this.settings.tagMultipliers[tag]);
      }
    }
    return Math.round(this.settings.pointsBaseValue * multiplier);
  }
  async calculatePointsWithLLM(taskText, tags) {
    const functions = [
      {
        "name": "assign_points",
        "description": "Assign points to a completed task based on its difficulty",
        "parameters": {
          "type": "object",
          "properties": {
            "points": {
              "type": "number",
              "description": "The number of points to award for the task"
            },
            "reasoning": {
              "type": "string",
              "description": "Explanation of how points were calculated"
            },
            "difficulty_assessment": {
              "type": "string",
              "enum": ["easy", "medium", "hard", "very_hard"],
              "description": "Assessment of the task's difficulty"
            }
          },
          "required": ["points", "reasoning", "difficulty_assessment"]
        }
      }
    ];
    const messages = [
      {
        "role": "system",
        "content": "You are a task assessment system that assigns points to completed tasks based on their difficulty. For difficulty, consider the complexity of the task and any tags."
      },
      {
        "role": "user",
        "content": `I just completed this task: "${taskText}". Tags: ${tags.join(", ") || "None"}. Please assign appropriate points.`
      }
    ];
    return await this.rateLimit(() => this.callLLMApi(functions, messages));
  }
  async rateLimit(fn) {
    if (!this.settings.rateLimiting.enabled) {
      return fn();
    }
    return new Promise((resolve, reject) => {
      this.requestQueue.push(async () => {
        try {
          const result = await fn();
          resolve(result);
          return result;
        } catch (error) {
          reject(error);
          throw error;
        }
      });
      if (!this.processingQueue) {
        this.processQueue();
      }
    });
  }
  async processQueue() {
    if (this.requestQueue.length === 0) {
      this.processingQueue = false;
      return;
    }
    this.processingQueue = true;
    const now = Date.now();
    const timeSinceLastRequest = now - this.lastRequestTime;
    const minDelay = 60 * 1e3 / this.settings.rateLimiting.requestsPerMinute;
    const delay = Math.max(0, minDelay - timeSinceLastRequest);
    if (delay > 0) {
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
    const nextRequest = this.requestQueue.shift();
    if (nextRequest) {
      this.lastRequestTime = Date.now();
      try {
        await nextRequest();
      } catch (error) {
        console.error("Error in rate-limited request:", error);
      }
    }
    this.processQueue();
  }
  async callLLMApi(functions, messages) {
    try {
      const response = await fetch(`${this.settings.apiUrl}/v1/chat/completions`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiKey}`
        },
        body: JSON.stringify({
          model: this.settings.selectedLLMModel,
          messages,
          tools: [{ "type": "function", "function": functions[0] }],
          tool_choice: { "type": "function", "function": { "name": "assign_points" } }
        })
      });
      if (!response.ok) {
        throw new Error(`API error: ${response.status} - ${await response.text()}`);
      }
      const data = await response.json();
      if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.tool_calls && data.choices[0].message.tool_calls[0]) {
        const toolCall = data.choices[0].message.tool_calls[0];
        const functionArgs = JSON.parse(toolCall.function.arguments);
        this.updateDifficultyStats(functionArgs.difficulty_assessment);
        return Math.round(functionArgs.points);
      }
      throw new Error("Could not extract points from LLM response");
    } catch (error) {
      console.error("Error calling LLM:", error);
      throw error;
    }
  }
  updateDifficultyStats(difficultyAssessment) {
    const difficultyMap = {
      "very_hard": 4,
      "hard": 3,
      "medium": 2,
      "easy": 1
    };
    const key = difficultyAssessment;
    const difficultyLevel = key in difficultyMap ? difficultyMap[key] : 0;
    if (difficultyLevel > this.statCardData.stats.highestDifficulty) {
      this.statCardData.stats.highestDifficulty = difficultyLevel;
    }
  }
  async checkForLevelUp() {
    while (this.statCardData.xp >= this.statCardData.nextLevelXp) {
      this.statCardData.xp -= this.statCardData.nextLevelXp;
      this.statCardData.level++;
      this.statCardData.nextLevelXp = Math.round(this.statCardData.nextLevelXp * (1.1 + this.statCardData.level * 0.05));
      new import_obsidian17.Notice(`Congratulations! You reached level ${this.statCardData.level}!`);
      const levelUpReward = Math.round(10 + this.statCardData.level * 2 + this.statCardData.level ** 1.5);
      this.statCardData.points += levelUpReward;
      new import_obsidian17.Notice(`You've been awarded ${levelUpReward} tokens!`);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async loadStatCardData() {
    try {
      const dataFile = this.app.vault.getAbstractFileByPath("QuestLog/data.json");
      if (dataFile instanceof import_obsidian17.TFile) {
        const content = await this.app.vault.read(dataFile);
        const parsedData = JSON.parse(content);
        this.statCardData = parsedData.statCardData || parsedData;
      } else {
        this.initializeDefaultStatCardData();
        await this.saveStatCardData();
      }
    } catch (error) {
      console.error("Error loading user data:", error);
      this.initializeDefaultStatCardData();
    }
  }
  checkForExpiredEffects() {
    if (!this.statCardData.activeEffects) return;
    const now = Date.now();
    let effectsChanged = false;
    for (const [key, effect] of Object.entries(this.statCardData.activeEffects)) {
      if (effect.expiresAt && effect.expiresAt < now) {
        delete this.statCardData.activeEffects[key];
        new import_obsidian17.Notice(`Your ${key} effect has expired.`);
        effectsChanged = true;
      }
    }
  }
  initializeDefaultStatCardData() {
    this.statCardData = {
      xp: 0,
      level: 1,
      points: 0,
      nextLevelXp: 100,
      skills: [
        {
          id: "writing",
          name: "Writing",
          level: 1,
          xp: 0
        },
        {
          id: "research",
          name: "Research",
          level: 1,
          xp: 0
        },
        {
          id: "organization",
          name: "Organization",
          level: 1,
          xp: 0
        }
      ],
      items: [],
      achievements: [],
      titles: [],
      stats: {
        tasksCompleted: 0,
        totalPointsEarned: 0,
        highestDifficulty: 0,
        tasksUnchecked: 0,
        totalPointsDeducted: 0,
        itemsPurchased: 0,
        lastFileCount: 0,
        lastFolderCount: 0
      },
      ownedItems: [],
      activeEffects: {},
      writingStats: { totalCharactersTyped: 0 },
      streaks: { currentStreak: 0, longestStreak: 0, lastActiveDate: "" }
    };
  }
  async saveStatCardData() {
    try {
      const folderPath = "QuestLog";
      const filePath = `${folderPath}/data.json`;
      const folder = this.app.vault.getAbstractFileByPath(folderPath);
      if (!folder) {
        await this.app.vault.createFolder(folderPath);
        console.log(`Created plugin data folder: ${folderPath}`);
      }
      const folderPath2 = "QuestLog/StoreInventory";
      const folder2 = this.app.vault.getAbstractFileByPath(folderPath2);
      if (!folder2) {
        await this.app.vault.createFolder(folderPath2);
        console.log(`Created plugin data folder: ${folderPath2}`);
        new import_obsidian17.Notice(`You can add custom items in '${folderPath2}'.`);
      }
      console.log(`Loading custom items from: ${folderPath2}`);
      const data = JSON.stringify({ statCardData: this.statCardData }, null, 2);
      const dataFile = this.app.vault.getAbstractFileByPath(filePath);
      if (dataFile instanceof import_obsidian17.TFile) {
        await this.app.vault.modify(dataFile, data);
      } else {
        await this.app.vault.create(filePath, data);
        new import_obsidian17.Notice(`Log: Database Created.`);
      }
    } catch (error) {
      console.error("Error saving user data:", error);
      new import_obsidian17.Notice("Error saving progress data.");
    }
  }
  async fetchAvailableModels() {
    try {
      const response = await fetch(`${this.settings.apiUrl}/v1/models`, {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.apiKey}`
        }
      });
      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }
      const data = await response.json();
      return data.data || [];
    } catch (error) {
      console.error("Error fetching models:", error);
      return [];
    }
  }
  async testConnection() {
    try {
      const response = await fetch(`${this.settings.apiUrl}/v1/models`, {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.apiKey}`
        }
      });
      return response.ok;
    } catch (error) {
      console.error("Error testing connection:", error);
      return false;
    }
  }
};
var SelectNoteModal = class extends import_obsidian17.Modal {
  constructor(app, options, onSelect) {
    super(app);
    this.options = options;
    this.onSelect = onSelect;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Select Note to Untrack" });
    const ul = contentEl.createEl("ul", { cls: "gamify-modal-list" });
    this.options.forEach((option) => {
      const li = ul.createEl("li");
      li.textContent = option;
      li.addEventListener("click", () => {
        this.onSelect(option);
        this.close();
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
