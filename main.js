/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// itemStore.ts
var import_obsidian, ItemStoreService, ItemStoreModal;
var init_itemStore = __esm({
  "itemStore.ts"() {
    import_obsidian = require("obsidian");
    ItemStoreService = class {
      constructor(plugin) {
        this.items = [];
        this.debugMode = false;
        this.plugin = plugin;
        this.initializeStoreItems();
        this.checkDebugStatus();
      }
      checkDebugStatus() {
        const debugTitle = "debugger";
        const titleToCheck = this.plugin.statCardData.titles || "";
        this.debugMode = typeof titleToCheck === "string" && titleToCheck === debugTitle;
        if (this.debugMode) {
          console.log("\u{1F525} Dark powers fully unleashed - Debug mode active");
        }
      }
      initializeStoreItems() {
        this.items = [
          {
            id: "minor_xp_boost",
            name: "Minor Soul Infusion",
            description: "Gain 100 immediate XP.",
            cost: 25,
            category: "boost",
            owned: false,
            levelRequired: 0,
            // Available from the start
            effect: (plugin) => {
              plugin.statCardData.xp += 100;
              this.checkLevelUp();
              plugin.saveStatCardData();
              new import_obsidian.Notice("Your soul absorbs dark energy, growing stronger...");
            }
          },
          {
            id: "major_xp_boost",
            name: "Major Soul Infusion",
            description: "Gain 500 immediate XP.",
            cost: 100,
            category: "boost",
            owned: false,
            levelRequired: 10,
            // Requires level 3
            hidden: true,
            // Hidden until level requirement is met
            effect: (plugin) => {
              plugin.statCardData.xp += 500;
              this.checkLevelUp();
              plugin.saveStatCardData();
              new import_obsidian.Notice("A surge of power courses through your essence!");
            }
          },
          {
            id: "writing_skill_boost",
            name: "Quill of Dark Scriptures I",
            description: "Gain 1 level in Writing skill.",
            cost: 75,
            category: "boost",
            owned: false,
            skillRequired: { skillId: "writing", level: 2 },
            effect: (plugin) => {
              const skill = plugin.statCardData.skills.find((s) => s.id === "writing");
              if (skill) {
                skill.level += 1;
                plugin.saveStatCardData();
                new import_obsidian.Notice("Your Writing skill has been augmented with demonic insight!");
              }
            }
          },
          {
            id: "research_skill_boost",
            name: "Tome of Forbidden Knowledge I",
            description: "Gain 1 level in Research skill.",
            cost: 75,
            category: "boost",
            owned: false,
            skillRequired: { skillId: "research", level: 2 },
            effect: (plugin) => {
              const skill = plugin.statCardData.skills.find((s) => s.id === "research");
              if (skill) {
                skill.level += 1;
                plugin.saveStatCardData();
                new import_obsidian.Notice("Your Research skill has been infused with eldritch wisdom!");
              }
            }
          },
          {
            id: "organization_skill_boost",
            name: "Demonic Cataloguing System I",
            description: "Gain 1 level in Organization skill.",
            cost: 75,
            category: "boost",
            owned: false,
            skillRequired: { skillId: "organization", level: 2 },
            effect: (plugin) => {
              const skill = plugin.statCardData.skills.find((s) => s.id === "organization");
              if (skill) {
                skill.level += 1;
                plugin.saveStatCardData();
                new import_obsidian.Notice("Your Organization skill has been enhanced with supernatural precision!");
              }
            }
          },
          {
            id: "dark_ritual_discount",
            name: "Blood Pact I",
            description: "All demonic requests cost 20% less for 24 hours. The demon demands tribute later.",
            cost: 150,
            category: "ritual",
            owned: false,
            levelRequired: 20,
            effect: (plugin) => {
              plugin.statCardData.activeEffects = plugin.statCardData.activeEffects || {};
              plugin.statCardData.activeEffects.taskDiscount = {
                value: 0.2,
                // 20% discount
                expiresAt: Date.now() + 24 * 60 * 60 * 1e3
              };
              plugin.saveStatCardData();
              new import_obsidian.Notice("The demons offer their services at reduced cost...for now.");
            }
          },
          {
            id: "grimoire_theme",
            name: "Grimoire of Shadows",
            description: "A cosmetic upgrade that gives your Grimoire a more imposing appearance.",
            cost: 200,
            category: "cosmetic",
            owned: false,
            levelRequired: 50,
            // Requires level 4
            hidden: true,
            effect: (plugin) => {
              plugin.statCardData.activeTheme = "shadows";
              plugin.saveStatCardData();
              new import_obsidian.Notice("Your Grimoire transforms, shadows dancing across its pages...");
            }
          },
          {
            id: "xp_multiplier",
            name: "Soul Binding Contract",
            description: "Gain 1.5x XP from all activities for 24 hours.",
            cost: 175,
            category: "ritual",
            owned: false,
            levelRequired: 15,
            effect: (plugin) => {
              plugin.statCardData.activeEffects = plugin.statCardData.activeEffects || {};
              plugin.statCardData.activeEffects.xpMultiplier = {
                value: 1.5,
                expiresAt: Date.now() + 24 * 60 * 60 * 1e3
              };
              plugin.saveStatCardData();
              new import_obsidian.Notice("Your soul now absorbs more energy from your labors...");
            }
          },
          {
            id: "demonic_familiar",
            name: "Demonic Familiar",
            description: "Summon a small demon that provides random bonuses each day.",
            cost: 300,
            category: "artifact",
            owned: false,
            levelRequired: 50,
            hidden: false,
            effect: (plugin) => {
              plugin.statCardData.hasFamiliar = true;
              this.setupFamiliarDailyBonus();
              plugin.saveStatCardData();
              new import_obsidian.Notice("A small shadowy creature materializes, bound to your service!");
            }
          },
          {
            id: "forbidden_scroll",
            name: "Forbidden Scroll of Efficiency I",
            description: "Complete the next 3 task automations without spending tokens.",
            cost: 250,
            category: "artifact",
            owned: false,
            skillRequired: { skillId: "organization", level: 25 },
            hidden: true,
            // Hidden until skill requirement is met
            effect: (plugin) => {
              plugin.statCardData.activeEffects = plugin.statCardData.activeEffects || {};
              plugin.statCardData.activeEffects.freeRequests = {
                value: 3,
                expiresAt: Date.now() + 7 * 24 * 60 * 60 * 1e3
                // 7 days
              };
              plugin.saveStatCardData();
              new import_obsidian.Notice("The ancient scroll unfurls, granting you efficiency beyond mortal means!");
            }
          }
        ];
        if (!this.plugin.statCardData.ownedItems) {
          this.plugin.statCardData.ownedItems = [];
        }
        if (this.plugin.statCardData.ownedItems) {
          for (const item of this.items) {
            if (this.plugin.statCardData.ownedItems.includes(item.id)) {
              item.owned = true;
            }
          }
        } else {
          this.plugin.statCardData.ownedItems = [];
        }
      }
      setupFamiliarDailyBonus() {
        const now = /* @__PURE__ */ new Date();
        const today = now.toDateString();
        if (this.plugin.statCardData.lastFamiliarBonusDate !== today) {
          const bonusType = Math.floor(Math.random() * 3);
          switch (bonusType) {
            case 0:
              this.plugin.statCardData.xp += 50;
              new import_obsidian.Notice("Your familiar brings you a gift of 50 XP!");
              break;
            case 1:
              this.plugin.statCardData.points += 15;
              new import_obsidian.Notice("Your familiar has collected 15 demonic tokens for you!");
              break;
            case 2:
              const skills = this.plugin.statCardData.skills;
              const randomSkill = skills[Math.floor(Math.random() * skills.length)];
              randomSkill.xp += 15;
              new import_obsidian.Notice(`Your familiar enhances your ${randomSkill.name} skill!`);
              break;
          }
          this.plugin.statCardData.lastFamiliarBonusDate = today;
          this.plugin.saveStatCardData();
        }
      }
      checkLevelUp() {
        while (this.plugin.statCardData.xp >= this.plugin.statCardData.nextLevelXp) {
          this.plugin.statCardData.xp -= this.plugin.statCardData.nextLevelXp;
          this.plugin.statCardData.level += 1;
          this.plugin.statCardData.nextLevelXp = Math.floor(this.plugin.statCardData.nextLevelXp * 1.5);
          const pointsAwarded = this.plugin.statCardData.level * 10;
          this.plugin.statCardData.points += pointsAwarded;
          new import_obsidian.Notice(`Level up! You are now level ${this.plugin.statCardData.level}. You've been awarded ${pointsAwarded} demonic tokens!`);
        }
      }
      getItems() {
        if (this.debugMode) {
          return this.items;
        }
        return this.items.filter((item) => {
          if (item.hidden && !this.meetsRequirements(item)) {
            return false;
          }
          return true;
        });
      }
      meetsRequirements(item) {
        if (item.levelRequired && this.plugin.statCardData.level < item.levelRequired) {
          return false;
        }
        if (item.skillRequired) {
          const skill = this.plugin.statCardData.skills.find((s) => {
            var _a;
            return s.id === ((_a = item.skillRequired) == null ? void 0 : _a.skillId);
          });
          if (!skill || skill.level < item.skillRequired.level) {
            return false;
          }
        }
        return true;
      }
      getRequirementText(item) {
        var _a;
        const requirements = [];
        if (item.levelRequired && this.plugin.statCardData.level < item.levelRequired) {
          requirements.push(`Level ${item.levelRequired} required`);
        }
        if (item.skillRequired) {
          const skill = this.plugin.statCardData.skills.find((s) => {
            var _a2;
            return s.id === ((_a2 = item.skillRequired) == null ? void 0 : _a2.skillId);
          });
          const skillName = skill ? skill.name : (_a = item.skillRequired) == null ? void 0 : _a.skillId;
          if (!skill || skill.level < item.skillRequired.level) {
            requirements.push(`${skillName} level ${item.skillRequired.level} required`);
          }
        }
        return requirements.join(", ");
      }
      checkForExpiredEffects() {
        if (!this.plugin.statCardData.activeEffects) return;
        const now = Date.now();
        let effectsChanged = false;
        for (const [key, effect] of Object.entries(this.plugin.statCardData.activeEffects)) {
          if (effect.expiresAt && effect.expiresAt < now) {
            delete this.plugin.statCardData.activeEffects[key];
            new import_obsidian.Notice(`Your ${key} effect has expired.`);
            effectsChanged = true;
          }
        }
        if (effectsChanged) {
          this.plugin.saveStatCardData();
        }
      }
      async purchaseItem(itemId) {
        const item = this.items.find((i) => i.id === itemId);
        if (!item) {
          new import_obsidian.Notice("Item not found in the catalogue.");
          return false;
        }
        if (item.owned && item.category !== "boost" && item.category !== "ritual") {
          new import_obsidian.Notice("You already own this unholy artifact.");
          return false;
        }
        if (this.plugin.statCardData.points < item.cost) {
          new import_obsidian.Notice(`Not enough demonic tokens. You need ${item.cost} tokens to purchase this item.`);
          return false;
        }
        if (!this.debugMode && !this.meetsRequirements(item)) {
          new import_obsidian.Notice(`You do not meet the requirements: ${this.getRequirementText(item)}`);
          return false;
        }
        this.plugin.statCardData.points -= item.cost;
        if (item.category === "artifact" || item.category === "cosmetic") {
          item.owned = true;
          if (!this.plugin.statCardData.ownedItems.includes(item.id)) {
            this.plugin.statCardData.ownedItems.push(item.id);
          }
        }
        item.effect(this.plugin);
        this.plugin.statCardData.stats.itemsPurchased = (this.plugin.statCardData.stats.itemsPurchased || 0) + 1;
        await this.plugin.saveStatCardData();
        return true;
      }
    };
    ItemStoreModal = class extends import_obsidian.Modal {
      constructor(app, plugin, storeService) {
        super(app);
        this.selectedCategory = "all";
        this.plugin = plugin;
        this.storeService = storeService;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass("gamify-store-modal");
        this.storeService.checkForExpiredEffects();
        contentEl.createEl("h2", { text: "Item Store", cls: "gamify-modal-title" });
        contentEl.createEl("div", {
          text: `Available Tokens: ${this.plugin.statCardData.points}`,
          cls: "gamify-points-display"
        });
        const filterContainer = contentEl.createDiv({ cls: "gamify-store-filter" });
        filterContainer.createEl("span", { text: "Filter items: " });
        const categoryDropdown = new import_obsidian.DropdownComponent(filterContainer);
        categoryDropdown.addOption("all", "All Items");
        categoryDropdown.addOption("boost", "Soul Boosts");
        categoryDropdown.addOption("ritual", "Dark Rituals");
        categoryDropdown.addOption("artifact", "Unholy Artifacts");
        categoryDropdown.addOption("cosmetic", "Cosmetic Upgrades");
        categoryDropdown.setValue(this.selectedCategory);
        categoryDropdown.onChange((value) => {
          this.selectedCategory = value;
          this.renderItems();
        });
        const itemsContainer = contentEl.createDiv({ cls: "gamify-store-items" });
        itemsContainer.id = "store-items-container";
        this.renderItems();
        const buttonContainer = contentEl.createDiv({ cls: "gamify-store-buttons" });
        new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Return to Grimoire").onClick(() => {
          this.close();
          const { StatCardModal: StatCardModal2 } = (init_services(), __toCommonJS(services_exports));
          new StatCardModal2(this.app, this.plugin).open();
        });
      }
      renderItems() {
        const itemsContainer = document.getElementById("store-items-container");
        if (!itemsContainer) return;
        itemsContainer.empty();
        const items = this.storeService.getItems().filter(
          (item) => this.selectedCategory === "all" || item.category === this.selectedCategory
        );
        if (items.length === 0) {
          itemsContainer.createEl("p", {
            text: "No items available in this category.",
            cls: "gamify-no-items"
          });
          return;
        }
        for (const item of items) {
          const itemEl = itemsContainer.createDiv({ cls: "gamify-store-item" });
          const itemHeader = itemEl.createDiv({ cls: "gamify-item-header" });
          itemHeader.createEl("h3", { text: item.name, cls: "gamify-item-title" });
          itemHeader.createEl("span", {
            text: `${item.cost} tokens`,
            cls: "gamify-item-cost"
          });
          itemEl.createEl("p", {
            text: item.description,
            cls: "gamify-item-description"
          });
          let categoryName = "";
          switch (item.category) {
            case "boost":
              categoryName = "Soul Boost";
              break;
            case "ritual":
              categoryName = "Dark Ritual";
              break;
            case "artifact":
              categoryName = "Unholy Artifact";
              break;
            case "cosmetic":
              categoryName = "Cosmetic Upgrade";
              break;
          }
          itemEl.createEl("span", {
            text: categoryName,
            cls: `gamify-item-category gamify-category-${item.category}`
          });
          const meetsRequirements = this.storeService.meetsRequirements(item);
          if (!meetsRequirements) {
            const reqText = this.storeService.getRequirementText(item);
            const reqLabel = itemEl.createEl("div", {
              text: reqText,
              cls: "gamify-item-requirement"
            });
            reqLabel.style.color = "crimson";
            reqLabel.style.fontStyle = "italic";
            reqLabel.style.margin = "5px 0";
          }
          const purchaseButton = new import_obsidian.ButtonComponent(itemEl).setButtonText(item.owned && (item.category === "artifact" || item.category === "cosmetic") ? "Owned" : "Purchase").onClick(async () => {
            const success = await this.storeService.purchaseItem(item.id);
            if (success) {
              const pointsDisplay = document.querySelector(".gamify-points-display");
              if (pointsDisplay) {
                pointsDisplay.textContent = `Available Tokens: ${this.plugin.statCardData.points}`;
              }
              if (item.category === "artifact" || item.category === "cosmetic") {
                this.renderItems();
              }
            }
          });
          if (item.owned && (item.category === "artifact" || item.category === "cosmetic")) {
            purchaseButton.setDisabled(true);
          }
          if (this.plugin.statCardData.points < item.cost || !meetsRequirements) {
            purchaseButton.setDisabled(true);
          }
        }
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
  }
});

// services.ts
var services_exports = {};
__export(services_exports, {
  LLMTaskService: () => LLMTaskService,
  RedeemTaskModal: () => RedeemTaskModal,
  StatCardModal: () => StatCardModal,
  StatCardService: () => StatCardService,
  TaskResultModal: () => TaskResultModal
});
var import_obsidian2, StatCardService, LLMTaskService, RedeemTaskModal, TaskResultModal, StatCardModal;
var init_services = __esm({
  "services.ts"() {
    import_obsidian2 = require("obsidian");
    init_itemStore();
    StatCardService = class {
      constructor(plugin) {
        this.statusBarItem = null;
        this.plugin = plugin;
      }
      initializeUI() {
        this.plugin.addRibbonIcon("shield", "Open Grimoire", (evt) => {
          new StatCardModal(this.plugin.app, this.plugin).open();
        });
        this.statusBarItem = this.plugin.addStatusBarItem();
        this.updateStatusBar();
      }
      updateStatusBar() {
        if (this.statusBarItem) {
          this.statusBarItem.setText(
            `XP: ${Math.floor(this.plugin.statCardData.xp)} | Level: ${this.plugin.statCardData.level} | Points: ${this.plugin.statCardData.points} | Tasks Completed: ${this.plugin.statCardData.stats.tasksCompleted}`
          );
        }
      }
      refreshUI() {
        this.updateStatusBar();
      }
    };
    LLMTaskService = class {
      constructor(plugin) {
        this.keyPressCount = 0;
        this.lastFileCount = 0;
        this.lastFolderCount = 0;
        this.intervalId = null;
        this.plugin = plugin;
        this.keyboardListener = this.handleKeyPress.bind(this);
        document.addEventListener("keydown", this.keyboardListener);
        this.updateFileFolderCounts();
        this.intervalId = window.setInterval(() => this.updateFileFolderCounts(), 6e4 * 5);
        this.lastFileCount = this.plugin.statCardData.stats.lastFileCount || 0;
        this.lastFolderCount = this.plugin.statCardData.stats.lastFolderCount || 0;
      }
      // Handle keyboard events to track writing skill
      handleKeyPress(e) {
        if (e.key.length === 1 || e.key === "Backspace" || e.key === "Delete" || e.key === "Enter") {
          this.keyPressCount++;
          if (this.keyPressCount >= 50) {
            try {
              this.updateWritingSkill(this.keyPressCount);
              this.keyPressCount = 0;
            } catch (error) {
              console.error("Error updating writing skill:", error);
            }
          }
        }
      }
      // Count files and folders in the vault
      async updateFileFolderCounts() {
        try {
          const vault = this.plugin.app.vault;
          const allFiles = vault.getFiles();
          const fileCount = allFiles.length;
          const folders = /* @__PURE__ */ new Set();
          allFiles.forEach((file) => {
            var _a;
            const parentPath = (_a = file.parent) == null ? void 0 : _a.path;
            if (parentPath && parentPath !== "/") {
              folders.add(parentPath);
            }
          });
          const folderCount = folders.size;
          this.plugin.statCardData.stats.lastFileCount = fileCount;
          this.plugin.statCardData.stats.lastFolderCount = folderCount;
          await this.plugin.saveStatCardData();
          if (fileCount !== this.lastFileCount) {
            this.updateResearchSkill(fileCount);
            this.lastFileCount = fileCount;
          }
          if (folderCount !== this.lastFolderCount) {
            this.updateOrganizationSkill(folderCount);
            this.lastFolderCount = folderCount;
          }
        } catch (error) {
          console.error("Error updating file/folder counts:", error);
        }
      }
      // Update writing skill based on keyboard activity
      updateWritingSkill(keyCount) {
        const skill = this.plugin.statCardData.skills.find((s) => s.id === "writing");
        if (skill) {
          const xpGain = Math.floor(keyCount / 10);
          this.updateSkill(skill, xpGain);
        }
      }
      // Update research skill based on file count
      updateResearchSkill(fileCount) {
        const skill = this.plugin.statCardData.skills.find((s) => s.id === "research");
        if (skill) {
          const xpGain = Math.floor(fileCount / 20);
          this.updateSkill(skill, xpGain);
        }
      }
      // Update organization skill based on folder count
      updateOrganizationSkill(folderCount) {
        const skill = this.plugin.statCardData.skills.find((s) => s.id === "organization");
        if (skill) {
          const xpGain = Math.floor(folderCount / 5);
          this.updateSkill(skill, xpGain);
        }
      }
      // Common skill update logic
      updateSkill(skill, xpAmount) {
        var _a;
        if (xpAmount <= 0) return;
        if ((_a = this.plugin.statCardData.activeEffects) == null ? void 0 : _a.xpMultiplier) {
          const multiplier = this.plugin.statCardData.activeEffects.xpMultiplier;
          const now = Date.now();
          if (multiplier.expiresAt > now) {
            xpAmount = Math.floor(xpAmount * multiplier.value);
          }
        }
        skill.xp += xpAmount;
        const nextLevel = skill.level + 1;
        const xpForNextLevel = nextLevel * 25;
        if (skill.xp >= xpForNextLevel) {
          skill.level = nextLevel;
          skill.xp = 0;
          new import_obsidian2.Notice(`Your ${skill.name} skill has increased to level ${skill.level}!`);
          this.plugin.statCardData.points += nextLevel * 2;
          this.plugin.saveStatCardData();
        }
      }
      async executeTask(instruction) {
        const pointsCost = await this.determineTaskCost(instruction);
        if (this.plugin.statCardData.points < pointsCost) {
          throw new Error(`Not enough points. You need ${pointsCost} points to perform this action.`);
        }
        try {
          this.plugin.statCardData.points -= pointsCost;
          await this.plugin.saveStatCardData();
          const functions = [
            {
              "name": "perform_task",
              "description": "Perform a task requested by the user",
              "parameters": {
                "type": "object",
                "properties": {
                  "result": {
                    "type": "string",
                    "description": "The result of the task execution"
                  },
                  "task_type": {
                    "type": "string",
                    "enum": ["answer", "code_execution", "analysis", "creative"],
                    "description": "The type of task performed"
                  },
                  "title": {
                    "type": "string",
                    "description": "A short title describing the task result"
                  }
                },
                "required": ["result"]
              }
            }
          ];
          const messages = [
            {
              "role": "system",
              "content": "You are a powerful demonic entity that performs tasks for mortals who have spent their precious life force (points) to access your dark powers. You speak with a sinister, otherworldly tone and occasionally remind users of the price they've paid. You can answer questions, run simple code (by explaining the code and providing the expected output), analyze data, or provide creative content. Respond in markdown format when appropriate."
            },
            {
              "role": "user",
              "content": `I'd like you to perform this task: ${instruction}`
            }
          ];
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 3e4);
          const response = await fetch(`${this.plugin.settings.apiUrl}/v1/chat/completions`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${this.plugin.settings.apiKey}`
            },
            body: JSON.stringify({
              model: "local-model",
              messages,
              tools: [{ "type": "function", "function": functions[0] }],
              tool_choice: { "type": "function", "function": { "name": "perform_task" } }
            }),
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API error: ${response.status} - ${errorText}`);
          }
          const data = await response.json();
          if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.tool_calls && data.choices[0].message.tool_calls[0]) {
            const toolCall = data.choices[0].message.tool_calls[0];
            const functionArgs = JSON.parse(toolCall.function.arguments);
            this.plugin.statCardData.stats.tasksCompleted++;
            await this.plugin.saveStatCardData();
            await this.saveResultToVault(functionArgs.result, functionArgs.title || "Untitled Task", pointsCost);
            return functionArgs.result;
          }
          throw new Error("Could not extract result from LLM response");
        } catch (error) {
          console.error("Error executing LLM task:", error);
          this.plugin.statCardData.points += pointsCost;
          await this.plugin.saveStatCardData();
          if (error.name === "AbortError") {
            throw new Error("The request timed out. The dark powers are not responding.");
          }
          throw error;
        }
      }
      async determineTaskCost(instruction) {
        var _a;
        try {
          const functions = [
            {
              "name": "determine_cost",
              "description": "Determine the point cost for executing a task based on complexity",
              "parameters": {
                "type": "object",
                "properties": {
                  "points": {
                    "type": "number",
                    "description": "The number of points required for the task"
                  },
                  "reasoning": {
                    "type": "string",
                    "description": "Explanation of how points were calculated"
                  },
                  "complexity": {
                    "type": "string",
                    "enum": ["trivial", "simple", "moderate", "complex", "extreme"],
                    "description": "Assessment of the task's complexity"
                  }
                },
                "required": ["points", "reasoning", "complexity"]
              }
            }
          ];
          const messages = [
            {
              "role": "system",
              "content": "You are a demonic gatekeeper determining the cost for tasks. Assign points based on complexity: trivial (1-5 points), simple (5-10 points), moderate (10-30 points), complex (30-50 points), extreme (50-1000 points). Be fair but slightly menacing in your assessment."
            },
            {
              "role": "user",
              "content": `I request your dark powers for this task: "${instruction}". What is the cost?`
            }
          ];
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 15e3);
          const response = await fetch(`${this.plugin.settings.apiUrl}/v1/chat/completions`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${this.plugin.settings.apiKey}`
            },
            body: JSON.stringify({
              model: "local-model",
              messages,
              tools: [{ "type": "function", "function": functions[0] }],
              tool_choice: { "type": "function", "function": { "name": "determine_cost" } }
            }),
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API error: ${response.status} - ${errorText}`);
          }
          const data = await response.json();
          if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.tool_calls && data.choices[0].message.tool_calls[0]) {
            const toolCall = data.choices[0].message.tool_calls[0];
            const functionArgs = JSON.parse(toolCall.function.arguments);
            let cost = Math.round(functionArgs.points);
            if ((_a = this.plugin.statCardData.activeEffects) == null ? void 0 : _a.taskDiscount) {
              const discount = this.plugin.statCardData.activeEffects.taskDiscount;
              const now = Date.now();
              if (discount.expiresAt > now) {
                cost = Math.max(1, Math.floor(cost * (1 - discount.value)));
              }
            }
            return cost;
          }
          throw new Error("Could not determine task cost");
        } catch (error) {
          console.error("Error determining task cost:", error);
          if (error.name === "AbortError") {
            throw new Error("The request timed out. The dark powers are not responding.");
          }
          return 10;
        }
      }
      async saveResultToVault(content, title, pointsCost) {
        try {
          const folderPath = "VQ";
          const folder = this.plugin.app.vault.getAbstractFileByPath(folderPath);
          if (!folder) {
            await this.plugin.app.vault.createFolder(folderPath);
          }
          const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[-:.TZ]/g, "");
          const randomStr = Math.random().toString(36).substring(2, 8);
          const safeTitle = title ? title.replace(/[^a-zA-Z0-9]/g, "_").substring(0, 20) : "untitled";
          const filename = `${folderPath}/${timestamp}_${safeTitle}_${randomStr}.md`;
          const fileContent = `---
title: ${title}
created: ${(/* @__PURE__ */ new Date()).toISOString()}
points_cost: ${pointsCost}
---

# ${title}

${content} 

*the portal closes....*
`;
          await this.plugin.app.vault.create(filename, fileContent);
          new import_obsidian2.Notice(`Task result saved to ${filename}`);
        } catch (error) {
          console.error("Error saving result to vault:", error);
          new import_obsidian2.Notice("Error saving task result to vault.");
        }
      }
      destroy() {
        document.removeEventListener("keydown", this.keyboardListener);
        if (this.intervalId !== null) {
          window.clearInterval(this.intervalId);
          this.intervalId = null;
        }
      }
    };
    RedeemTaskModal = class extends import_obsidian2.Modal {
      constructor(app, plugin) {
        super(app);
        this.instruction = "";
        this.plugin = plugin;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Summon Demonic Powers" });
        contentEl.createEl("p", {
          text: `Points Available: ${this.plugin.statCardData.points}`
        });
        contentEl.createEl("label", { text: "What do you wish to request from the darkness?" });
        const instructionInput = new import_obsidian2.TextComponent(contentEl).setPlaceholder('e.g., "Write a blood-curdling tale of cosmic horror"').onChange((value) => {
          this.instruction = value;
        });
        const inputEl = instructionInput.inputEl;
        inputEl.style.width = "100%";
        inputEl.style.height = "100px";
        const buttonContainer = contentEl.createDiv({ cls: "redeem-buttons" });
        new import_obsidian2.ButtonComponent(buttonContainer).setButtonText("Flee").onClick(() => {
          this.close();
          new StatCardModal(this.app, this.plugin).open();
        });
        new import_obsidian2.ButtonComponent(buttonContainer).setButtonText("Summon").setCta().onClick(async () => {
          if (!this.instruction) {
            new import_obsidian2.Notice("You must specify your desire.");
            return;
          }
          try {
            this.close();
            new import_obsidian2.Notice("Summoning demonic powers...");
            const llmService = new LLMTaskService(this.plugin);
            const cost = await llmService.determineTaskCost(this.instruction);
            if (this.plugin.statCardData.points < cost) {
              new import_obsidian2.Notice(`Not enough points. You need ${cost} points to perform this action.`);
              new StatCardModal(this.app, this.plugin).open();
              return;
            }
            const result = await llmService.executeTask(this.instruction);
            if (this.plugin.statCardService) {
              this.plugin.statCardService.refreshUI();
            }
            const resultModal = new TaskResultModal(this.app, this.plugin, result);
            resultModal.open();
          } catch (error) {
            console.error("Error executing task:", error);
            new import_obsidian2.Notice(`The summoning failed. ${error.message}`);
            new StatCardModal(this.app, this.plugin).open();
          }
        });
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    TaskResultModal = class extends import_obsidian2.Modal {
      constructor(app, plugin, result) {
        super(app);
        this.plugin = plugin;
        this.result = result;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Dark Powers Response" });
        const resultContainer = contentEl.createDiv({ cls: "task-result-container" });
        resultContainer.style.maxHeight = "400px";
        resultContainer.style.overflow = "auto";
        resultContainer.style.padding = "10px";
        resultContainer.style.border = "1px solid var(--background-modifier-border)";
        resultContainer.style.margin = "10px 0";
        const MarkdownIt = window.markdownit;
        if (MarkdownIt) {
          const md = new MarkdownIt();
          resultContainer.innerHTML = md.render(this.result);
        } else {
          resultContainer.innerHTML = this.result.replace(/\n/g, "<br>");
        }
        const buttonContainer = contentEl.createDiv({ cls: "task-result-buttons" });
        new import_obsidian2.ButtonComponent(buttonContainer).setButtonText("Return to Stat Card").onClick(() => {
          this.close();
          new StatCardModal(this.app, this.plugin).open();
        });
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    StatCardModal = class extends import_obsidian2.Modal {
      constructor(app, plugin) {
        super(app);
        this.plugin = plugin;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass("gamify-stat-card-modal");
        contentEl.createEl("h2", { text: "Grimoire", cls: "gamify-modal-title" });
        const statsContainer = contentEl.createDiv({ cls: "gamify-stats-container" });
        statsContainer.createEl("h3", { text: `Level ${this.plugin.statCardData.level} Soul Binder`, cls: "gamify-stats-heading" });
        const xpBar = statsContainer.createDiv({ cls: "gamify-xp-bar" });
        const fillPercentage = Math.min(100, this.plugin.statCardData.xp / this.plugin.statCardData.nextLevelXp * 100);
        const xpBarFill = xpBar.createDiv({ cls: "gamify-xp-bar-fill" });
        xpBarFill.style.width = `${fillPercentage}%`;
        statsContainer.createEl("div", {
          text: `Soul Energy: ${Math.floor(this.plugin.statCardData.xp)}/${this.plugin.statCardData.nextLevelXp}`,
          cls: "gamify-stat-item"
        });
        statsContainer.createEl("div", {
          text: `Demonic Tokens: ${this.plugin.statCardData.points}`,
          cls: "gamify-stat-item"
        });
        const statsSection = contentEl.createDiv({ cls: "gamify-stats-details" });
        statsSection.createEl("h3", { text: "Pact Details", cls: "gamify-section-heading" });
        statsSection.createEl("div", {
          text: `Rituals Completed: ${this.plugin.statCardData.stats.tasksCompleted}`,
          cls: "gamify-stat-item"
        });
        statsSection.createEl("div", {
          text: `Total Tokens Earned: ${this.plugin.statCardData.stats.totalPointsEarned}`,
          cls: "gamify-stat-item"
        });
        const skillsSection = contentEl.createDiv({ cls: "gamify-skills-section" });
        skillsSection.createEl("h3", { text: "Skills", cls: "gamify-section-heading" });
        const skillsList = skillsSection.createEl("ul", { cls: "gamify-skills-list" });
        for (const skill of this.plugin.statCardData.skills) {
          skillsList.createEl("li", {
            text: `${skill.name}: Level ${skill.level}`,
            cls: "gamify-skill-item"
          });
        }
        const redeemSection = contentEl.createDiv({ cls: "gamify-redeem-section" });
        redeemSection.createEl("h3", { text: "Summon Dark Powers", cls: "gamify-section-heading" });
        const redeemButton = new import_obsidian2.ButtonComponent(redeemSection).setButtonText("Make a Demonic Request").onClick(() => {
          this.close();
          new RedeemTaskModal(this.app, this.plugin).open();
        });
        if (this.plugin.statCardData.activeEffects && Object.keys(this.plugin.statCardData.activeEffects).length > 0) {
          const effectsSection = contentEl.createDiv({ cls: "gamify-active-effects" });
          effectsSection.createEl("h4", { text: "Active Dark Powers" });
          const now = Date.now();
          for (const [key, effect] of Object.entries(this.plugin.statCardData.activeEffects)) {
            if (effect.expiresAt && effect.expiresAt > now) {
              const timeLeft = Math.floor((effect.expiresAt - now) / (60 * 1e3));
              const effectEl = effectsSection.createDiv({ cls: "gamify-effect-item" });
              let effectName = "Unknown Effect";
              let effectValue = "";
              switch (key) {
                case "taskDiscount":
                  effectName = "Ritual Discount";
                  effectValue = `${effect.value * 100}%`;
                  break;
                case "xpMultiplier":
                  effectName = "Soul Energy Multiplier";
                  effectValue = `${effect.value}x`;
                  break;
              }
              effectEl.createEl("span", { text: `${effectName}: ${effectValue}` });
              effectEl.createEl("span", { text: `${timeLeft} min remaining` });
            }
          }
        }
        const buttonEl = redeemButton.buttonEl;
        buttonEl.addClass("gamify-summon-button");
        if (this.plugin.statCardData.hasFamiliar) {
          const familiarSection = contentEl.createDiv({ cls: "gamify-familiar-section" });
          familiarSection.createEl("h4", { text: "Bound Familiar" });
          familiarSection.createEl("p", {
            text: "Your demonic familiar is bound to your service, providing daily benefits."
          });
        }
        const storeButton = new import_obsidian2.ButtonComponent(redeemSection).setButtonText("Visit Item Store").onClick(() => {
          this.close();
          new ItemStoreModal(this.app, this.plugin, this.plugin.itemStoreService).open();
        });
        const storeButtonEl = storeButton.buttonEl;
        storeButtonEl.addClass("gamify-store-button");
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GamifyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");
init_services();

// task-assessment-service.ts
var import_obsidian3 = require("obsidian");
var TaskAssessmentService = class {
  constructor(plugin) {
    this.requestQueue = [];
    this.isProcessing = false;
    this.lastRequestTime = 0;
    this.taskStoragePath = "VQ/task_storage.json";
    this.plugin = plugin;
  }
  /**
   * Initialize the task storage file if it doesn't exist
   */
  async initializeTaskStorage() {
    if (!await this.plugin.app.vault.adapter.exists(this.taskStoragePath)) {
      await this.plugin.app.vault.adapter.write(
        this.taskStoragePath,
        JSON.stringify({ processedTasks: [] })
      );
    }
  }
  /**
   * Load task identifiers from storage
   */
  async loadTaskStorage() {
    if (await this.plugin.app.vault.adapter.exists(this.taskStoragePath)) {
      const data = await this.plugin.app.vault.adapter.read(this.taskStoragePath);
      try {
        const parsed = JSON.parse(data);
        return parsed.processedTasks || [];
      } catch (e) {
        console.error("Error parsing task storage:", e);
        return [];
      }
    }
    return [];
  }
  /**
   * Save task identifiers to storage
   */
  async saveTaskStorage(tasks) {
    await this.plugin.app.vault.adapter.write(
      this.taskStoragePath,
      JSON.stringify({ processedTasks: tasks })
    );
  }
  /**
   * Check if a task has been processed
   */
  async isTaskProcessed(filePath, taskText) {
    const tasks = await this.loadTaskStorage();
    return tasks.some(
      (task) => task.filePath === filePath && task.taskText === taskText && task.completed === true
    );
  }
  /**
   * Get a task from storage
   */
  async getTask(filePath, taskText) {
    const tasks = await this.loadTaskStorage();
    return tasks.find(
      (task) => task.filePath === filePath && task.taskText === taskText
    ) || null;
  }
  /**
   * Add a task to the processed list
   */
  async addProcessedTask(filePath, taskText, points, tags) {
    const tasks = await this.loadTaskStorage();
    const existingTaskIndex = tasks.findIndex(
      (task) => task.filePath === filePath && task.taskText === taskText
    );
    if (existingTaskIndex >= 0) {
      tasks[existingTaskIndex].completed = true;
      tasks[existingTaskIndex].lastUpdated = Date.now();
      tasks[existingTaskIndex].points = points;
      tasks[existingTaskIndex].tags = tags;
    } else {
      tasks.push({
        filePath,
        taskText,
        completed: true,
        lastUpdated: Date.now(),
        points,
        tags
      });
    }
    await this.saveTaskStorage(tasks);
  }
  /**
   * Mark a task as uncompleted
   */
  async markTaskUncompleted(filePath, taskText) {
    const tasks = await this.loadTaskStorage();
    const existingTaskIndex = tasks.findIndex(
      (task) => task.filePath === filePath && task.taskText === taskText
    );
    if (existingTaskIndex >= 0 && tasks[existingTaskIndex].completed) {
      const points = tasks[existingTaskIndex].points;
      tasks[existingTaskIndex].completed = false;
      tasks[existingTaskIndex].lastUpdated = Date.now();
      await this.saveTaskStorage(tasks);
      if (this.plugin.settings.deductPointsForUnchecking) {
        this.plugin.statCardData.points -= points;
        this.plugin.statCardData.stats.tasksUnchecked++;
        this.plugin.statCardData.stats.totalPointsDeducted += points;
        await this.plugin.saveStatCardData();
        this.plugin.statCardService.refreshUI();
        new import_obsidian3.Notice(`Task unchecked. Deducted ${points} points.`);
      }
    }
  }
  /**
   * Process a note to find completed and uncompleted tasks
   */
  async processNoteTasks(content, filePath) {
    const currentTasks = this.extractTasksFromNote(content);
    const storedTasks = await this.loadTaskStorage();
    const fileTasks = storedTasks.filter((task) => task.filePath === filePath);
    for (const task of currentTasks) {
      if (task.completed) {
        const isAlreadyProcessed = await this.isTaskProcessed(filePath, task.taskText);
        if (!isAlreadyProcessed) {
          const tags = this.plugin.extractTags(task.taskText);
          this.queueTaskAssessment(filePath, task.taskText, tags);
        }
      } else {
        const wasCompleted = fileTasks.some(
          (storedTask) => storedTask.taskText === task.taskText && storedTask.completed === true
        );
        if (wasCompleted) {
          await this.markTaskUncompleted(filePath, task.taskText);
        }
      }
    }
  }
  /**
   * Extract all tasks from a note
   */
  extractTasksFromNote(content) {
    const tasks = [];
    const taskRegex = /- \[([ xX])\]\s+(.*?)(?:\n|$)/g;
    let match;
    while ((match = taskRegex.exec(content)) !== null) {
      const isCompleted = match[1].toLowerCase() === "x";
      const taskText = match[2].trim();
      tasks.push({
        taskText,
        completed: isCompleted
      });
    }
    return tasks;
  }
  /**
   * Assess all completed tasks in tracked notes
   */
  async assessCompletedTasks() {
    if (this.plugin.settings.trackedNotes.length === 0) {
      new import_obsidian3.Notice('No notes are being tracked. Add notes using the "Track Current Note for Tasks" command.');
      return;
    }
    let newTasksAssessing = 0;
    for (const notePath of this.plugin.settings.trackedNotes) {
      const file = this.plugin.app.vault.getAbstractFileByPath(notePath);
      if (file instanceof import_obsidian3.TFile) {
        const content = await this.plugin.app.vault.read(file);
        await this.processNoteTasks(content, file.path);
        const tasks = this.extractTasksFromNote(content);
        const completedTasks = tasks.filter((task) => task.completed);
        for (const task of completedTasks) {
          const isAlreadyProcessed = await this.isTaskProcessed(file.path, task.taskText);
          if (!isAlreadyProcessed) {
            newTasksAssessing++;
          }
        }
      }
    }
    if (newTasksAssessing > 0) {
      new import_obsidian3.Notice(`Assessment started for ${newTasksAssessing} new completed tasks.`);
    } else {
      new import_obsidian3.Notice("Scan complete! No new completed tasks found.");
    }
  }
  /**
   * Queue a task for assessment with rate limiting
   */
  queueTaskAssessment(filePath, taskText, tags) {
    const task = async () => {
      try {
        const points = await this.plugin.calculatePointsForTask(taskText, tags);
        this.plugin.statCardData.points += points;
        this.plugin.statCardData.stats.tasksCompleted++;
        this.plugin.statCardData.stats.totalPointsEarned += points;
        await this.addProcessedTask(filePath, taskText, points, tags);
        await this.plugin.saveStatCardData();
        this.plugin.statCardService.refreshUI();
        new import_obsidian3.Notice(`Task assessed! Earned ${points} points.`);
      } catch (error) {
        console.error("Error assessing task:", error);
        new import_obsidian3.Notice("Error assessing task. See console for details.");
      }
    };
    this.requestQueue.push(task);
    if (!this.isProcessing) {
      this.processQueue();
    }
  }
  /**
   * Process the queue with rate limiting
   */
  async processQueue() {
    if (this.requestQueue.length === 0) {
      this.isProcessing = false;
      return;
    }
    this.isProcessing = true;
    if (this.plugin.settings.rateLimiting && this.plugin.settings.rateLimiting.enabled) {
      const now = Date.now();
      const minTimeGap = 6e4 / this.plugin.settings.rateLimiting.requestsPerMinute;
      const timeElapsed = now - this.lastRequestTime;
      if (timeElapsed < minTimeGap) {
        await new Promise((resolve) => setTimeout(resolve, minTimeGap - timeElapsed));
      }
    }
    const task = this.requestQueue.shift();
    if (task) {
      this.lastRequestTime = Date.now();
      await task();
    }
    this.processQueue();
  }
  /**
   * Handle events for file changes
   */
  async handleFileModified(file) {
    if (this.plugin.settings.trackedNotes.includes(file.path)) {
      const content = await this.plugin.app.vault.read(file);
      await this.processNoteTasks(content, file.path);
    }
  }
};

// task-storage-viewer.ts
var import_obsidian4 = require("obsidian");
var TaskStorageViewer = class extends import_obsidian4.Modal {
  constructor(app, plugin, taskAssessmentService) {
    super(app);
    this.statusFilter = "all";
    this.plugin = plugin;
    this.taskAssessmentService = taskAssessmentService;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("vq-task-storage-viewer");
    contentEl.createEl("h2", { text: "Task Storage Viewer" });
    const filterContainer = contentEl.createDiv({ cls: "vq-filter-container" });
    this.textFilter = new import_obsidian4.TextComponent(filterContainer).setPlaceholder("Filter by text or file path").onChange(async (value) => {
      await this.renderTaskList(value, this.statusFilter);
    });
    const filterOptions = ["all", "completed", "uncompleted"];
    new import_obsidian4.Setting(filterContainer).setName("Status").addDropdown((dropdown) => {
      filterOptions.forEach((option) => {
        dropdown.addOption(option, option.charAt(0).toUpperCase() + option.slice(1));
      });
      dropdown.setValue("all");
      dropdown.onChange(async (value) => {
        this.statusFilter = value;
        await this.renderTaskList(this.textFilter.getValue(), value);
      });
      return dropdown;
    });
    const actionContainer = contentEl.createDiv({ cls: "vq-action-container" });
    new import_obsidian4.ButtonComponent(actionContainer).setButtonText("Refresh").onClick(async () => {
      await this.renderTaskList(this.textFilter.getValue(), this.statusFilter);
    });
    new import_obsidian4.ButtonComponent(actionContainer).setButtonText("Clear All Data").setClass("mod-warning").onClick(async () => {
      if (confirm("Are you sure you want to clear all task data? This action cannot be undone.")) {
        await this.taskAssessmentService.saveTaskStorage([]);
        await this.renderTaskList("", "all");
      }
    });
    contentEl.createDiv({ cls: "vq-task-list-container" });
    const style = document.createElement("style");
    style.textContent = `
            .vq-task-storage-viewer {
                resize: both;
                overflow: auto;
                max-width: 190vw;
                max-height: 190vh;
                position: relative;
                border: 1px solid #ccc;
                padding: 10px;
            }
        `;
    document.head.appendChild(style);
    await this.renderTaskList("", "all");
  }
  async renderTaskList(textFilter, statusFilter) {
    const { contentEl } = this;
    const taskListContainer = contentEl.querySelector(".vq-task-list-container");
    if (!taskListContainer) return;
    taskListContainer.empty();
    const tasks = await this.taskAssessmentService.loadTaskStorage();
    const filteredTasks = tasks.filter((task) => {
      const textMatch = !textFilter || task.taskText.toLowerCase().includes(textFilter.toLowerCase()) || task.filePath.toLowerCase().includes(textFilter.toLowerCase());
      let statusMatch = true;
      if (statusFilter === "completed") {
        statusMatch = task.completed;
      } else if (statusFilter === "uncompleted") {
        statusMatch = !task.completed;
      }
      return textMatch && statusMatch;
    });
    filteredTasks.sort((a, b) => b.lastUpdated - a.lastUpdated);
    const statsEl = taskListContainer.createEl("div", { cls: "vq-stats-container" });
    statsEl.createEl("p", {
      text: `Showing ${filteredTasks.length} of ${tasks.length} tasks`
    });
    if (filteredTasks.length === 0) {
      taskListContainer.createEl("p", { text: "No tasks found." });
      return;
    }
    const table = taskListContainer.createEl("table", { cls: "vq-task-table" });
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    headerRow.createEl("th", { text: "Status" });
    headerRow.createEl("th", { text: "Task" });
    headerRow.createEl("th", { text: "File" });
    headerRow.createEl("th", { text: "Points" });
    headerRow.createEl("th", { text: "Tags" });
    headerRow.createEl("th", { text: "Last Updated" });
    headerRow.createEl("th", { text: "Actions" });
    const tbody = table.createEl("tbody");
    for (const task of filteredTasks) {
      const row = tbody.createEl("tr");
      const statusCell = row.createEl("td");
      statusCell.createEl("span", {
        cls: `vq-status ${task.completed ? "vq-completed" : "vq-uncompleted"}`,
        text: task.completed ? "\u2713" : "\u25CB"
      });
      row.createEl("td", {
        cls: "vq-task-text",
        text: task.taskText.length > 50 ? task.taskText.slice(0, 50) + "..." : task.taskText
      }).setAttribute("title", task.taskText);
      const filePathParts = task.filePath.split("/");
      const fileName = filePathParts[filePathParts.length - 1];
      row.createEl("td", { text: fileName }).setAttribute("title", task.filePath);
      row.createEl("td", { cls: "vq-points", text: task.points.toString() });
      const tagsCell = row.createEl("td", { cls: "vq-tags" });
      if (task.tags && task.tags.length > 0) {
        for (const tag of task.tags) {
          tagsCell.createEl("span", { cls: "vq-tag", text: tag });
        }
      } else {
        tagsCell.setText("None");
      }
      const date = new Date(task.lastUpdated);
      row.createEl("td", {
        text: date.toLocaleDateString() + " " + date.toLocaleTimeString()
      });
      const actionsCell = row.createEl("td", { cls: "vq-actions" });
      new import_obsidian4.ButtonComponent(actionsCell).setButtonText("Go to").setTooltip("Open this file").onClick(() => {
        const file = this.app.vault.getAbstractFileByPath(task.filePath);
        if (file && file instanceof import_obsidian4.TFile) {
          const leaf = this.app.workspace.activeLeaf;
          if (leaf) {
            leaf.openFile(file);
          } else {
            new import_obsidian4.Notice("No active leaf to open file");
          }
        } else {
          new import_obsidian4.Notice(`File not found: ${task.filePath}`);
        }
      });
      new import_obsidian4.ButtonComponent(actionsCell).setButtonText("Delete").setClass("mod-warning").setTooltip("Remove this task from storage").onClick(async () => {
        if (confirm("Are you sure you want to delete this task from storage?")) {
          const tasks2 = await this.taskAssessmentService.loadTaskStorage();
          const updatedTasks = tasks2.filter(
            (t) => !(t.filePath === task.filePath && t.taskText === task.taskText)
          );
          await this.taskAssessmentService.saveTaskStorage(updatedTasks);
          await this.renderTaskList(textFilter, statusFilter);
        }
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var TaskStorageRibbonIcon = class {
  constructor(plugin, taskAssessmentService) {
    this.plugin = plugin;
    this.taskAssessmentService = taskAssessmentService;
    const ribbonIconEl = this.plugin.addRibbonIcon(
      "list-checks",
      "View Task Storage",
      () => {
        new TaskStorageViewer(this.plugin.app, this.plugin, this.taskAssessmentService).open();
      }
    );
  }
};

// main.ts
init_itemStore();
var DEFAULT_SETTINGS = {
  xpPerCharacter: 0.1,
  pointsBaseValue: 10,
  tagMultipliers: {
    "#easy": 0.5,
    "#medium": 1,
    "#hard": 2,
    "#veryhard": 5
  },
  apiUrl: "http://localhost:1234",
  apiKey: "your-api-key",
  trackedNotes: [],
  selectedLLMModel: "local-model",
  rateLimiting: {
    enabled: true,
    requestsPerMinute: 10
    //minutes
  },
  scanInterval: 5,
  //minutes
  deductPointsForUnchecking: true
};
var GamifyPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.availableModels = [];
    // For rate limiting
    this.requestQueue = [];
    this.processingQueue = false;
    this.lastRequestTime = 0;
    this.scanIntervalId = null;
  }
  loadExternalStyles() {
    const existingStyle = document.getElementById("gamify-styles");
    if (existingStyle) {
      existingStyle.remove();
    }
    const linkEl = document.createElement("link");
    linkEl.id = "gamify-styles";
    linkEl.rel = "stylesheet";
    linkEl.type = "text/css";
    linkEl.href = this.app.vault.adapter.getResourcePath(this.manifest.dir + "/styles.css");
    document.head.appendChild(linkEl);
  }
  startPeriodicScanning() {
    if (this.scanIntervalId) clearInterval(this.scanIntervalId);
    this.scanIntervalId = setInterval(() => {
      this.taskAssessmentService.assessCompletedTasks();
    }, this.settings.scanInterval * 60 * 1e3);
  }
  async onload() {
    this.app.workspace.onLayoutReady(async () => {
      await this.loadSettings();
      await this.loadStatCardData();
      this.loadExternalStyles();
      this.statCardService = new StatCardService(this);
      this.llmTaskService = new LLMTaskService(this);
      this.itemStoreService = new ItemStoreService(this);
      this.statCardService.initializeUI();
      this.statCardService.refreshUI();
      this.taskAssessmentService = new TaskAssessmentService(this);
      this.taskAssessmentService.initializeTaskStorage();
      this.startPeriodicScanning();
      new TaskStorageRibbonIcon(this, this.taskAssessmentService);
      this.addRibbonIcon("check-circle", "Scan for Tasks", () => {
        this.taskAssessmentService.assessCompletedTasks();
        new import_obsidian5.Notice("Manual scan started.");
      });
      this.typing = {
        characterCount: 0,
        timeout: null
      };
      this.registerDomEvent(document, "keydown", (evt) => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
        if (view && this.isContentKey(evt)) {
          this.handleTyping();
        }
      });
      this.fileChangedEventRef = this.app.vault.on("modify", (file) => {
        if (file instanceof import_obsidian5.TFile && this.settings.trackedNotes.includes(file.path)) {
          this.checkForUncheckedTasks(file);
        }
      });
      this.addCommand({
        id: "track-current-note",
        name: "Track Current Note for Tasks",
        callback: () => this.trackCurrentNote()
      });
      this.addCommand({
        id: "untrack-note",
        name: "Remove Note from Task Tracking",
        callback: () => this.showUntrackNoteModal()
      });
      this.addCommand({
        id: "scan-tasks",
        name: "Scan Completed Tasks",
        callback: () => this.taskAssessmentService.assessCompletedTasks()
      });
      this.addSettingTab(new GamifySettingTab(this.app, this));
    });
  }
  onunload() {
    if (this.typing.timeout) {
      clearTimeout(this.typing.timeout);
      this.processTypingXp();
    }
    if (this.scanIntervalId) {
      clearInterval(this.scanIntervalId);
      this.scanIntervalId = null;
    }
    const styleEl = document.getElementById("gamify-styles");
    if (styleEl) styleEl.remove();
    this.app.vault.offref(this.fileChangedEventRef);
  }
  async checkForUncheckedTasks(file) {
    if (!this.settings.deductPointsForUnchecking) return;
  }
  isContentKey(evt) {
    return !evt.ctrlKey && !evt.altKey && !evt.metaKey && evt.key.length === 1 && !evt.repeat;
  }
  handleTyping() {
    this.typing.characterCount++;
    if (this.typing.timeout) {
      clearTimeout(this.typing.timeout);
    }
    this.typing.timeout = setTimeout(() => {
      this.processTypingXp();
    }, 2e3);
  }
  processTypingXp() {
    const xpGained = this.typing.characterCount * this.settings.xpPerCharacter;
    this.statCardData.xp += xpGained;
    this.typing.characterCount = 0;
    this.typing.timeout = null;
    this.checkForLevelUp();
    this.saveStatCardData();
    this.statCardService.refreshUI();
  }
  async trackCurrentNote() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian5.Notice("No active file to track.");
      return;
    }
    const filePath = activeFile.path;
    if (!this.settings.trackedNotes.includes(filePath)) {
      this.settings.trackedNotes.push(filePath);
      await this.saveSettings();
      new import_obsidian5.Notice(`Now tracking "${activeFile.basename}" for tasks.`);
    } else {
      new import_obsidian5.Notice(`Already tracking "${activeFile.basename}".`);
    }
  }
  async showUntrackNoteModal() {
    if (this.settings.trackedNotes.length === 0) {
      new import_obsidian5.Notice("No notes are currently being tracked.");
      return;
    }
    const modal = new SelectNoteModal(
      this.app,
      this.settings.trackedNotes,
      async (selectedPath) => {
        this.settings.trackedNotes = this.settings.trackedNotes.filter((path) => path !== selectedPath);
        await this.saveSettings();
        new import_obsidian5.Notice(`Stopped tracking "${selectedPath.split("/").pop()}".`);
      }
    );
    modal.open();
  }
  extractTags(text) {
    const tagRegex = /#[\w-]+/g;
    return text.match(tagRegex) || [];
  }
  async calculatePointsForTask(taskText, tags) {
    try {
      return await this.calculatePointsWithLLM(taskText, tags);
    } catch (error) {
      console.error("Error calculating points with LLM:", error);
      return this.calculateBasicPoints(tags);
    }
  }
  calculateBasicPoints(tags) {
    let multiplier = 1;
    for (const tag of tags) {
      if (this.settings.tagMultipliers[tag]) {
        multiplier = Math.max(multiplier, this.settings.tagMultipliers[tag]);
      }
    }
    return Math.round(this.settings.pointsBaseValue * multiplier);
  }
  async calculatePointsWithLLM(taskText, tags) {
    const functions = [
      {
        "name": "assign_points",
        "description": "Assign points to a completed task based on its difficulty",
        "parameters": {
          "type": "object",
          "properties": {
            "points": {
              "type": "number",
              "description": "The number of points to award for the task"
            },
            "reasoning": {
              "type": "string",
              "description": "Explanation of how points were calculated"
            },
            "difficulty_assessment": {
              "type": "string",
              "enum": ["easy", "medium", "hard", "very_hard"],
              "description": "Assessment of the task's difficulty"
            }
          },
          "required": ["points", "reasoning", "difficulty_assessment"]
        }
      }
    ];
    const messages = [
      {
        "role": "system",
        "content": "You are a task assessment system that assigns points to completed tasks based on their difficulty. For difficulty, consider the complexity of the task and any tags."
      },
      {
        "role": "user",
        "content": `I just completed this task: "${taskText}". Tags: ${tags.join(", ") || "None"}. Please assign appropriate points.`
      }
    ];
    return await this.rateLimit(() => this.callLLMApi(functions, messages));
  }
  async rateLimit(fn) {
    if (!this.settings.rateLimiting.enabled) {
      return fn();
    }
    return new Promise((resolve, reject) => {
      this.requestQueue.push(async () => {
        try {
          const result = await fn();
          resolve(result);
          return result;
        } catch (error) {
          reject(error);
          throw error;
        }
      });
      if (!this.processingQueue) {
        this.processQueue();
      }
    });
  }
  async processQueue() {
    if (this.requestQueue.length === 0) {
      this.processingQueue = false;
      return;
    }
    this.processingQueue = true;
    const now = Date.now();
    const timeSinceLastRequest = now - this.lastRequestTime;
    const minDelay = 60 * 1e3 / this.settings.rateLimiting.requestsPerMinute;
    const delay = Math.max(0, minDelay - timeSinceLastRequest);
    if (delay > 0) {
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
    const nextRequest = this.requestQueue.shift();
    if (nextRequest) {
      this.lastRequestTime = Date.now();
      try {
        await nextRequest();
      } catch (error) {
        console.error("Error in rate-limited request:", error);
      }
    }
    this.processQueue();
  }
  async callLLMApi(functions, messages) {
    try {
      const response = await fetch(`${this.settings.apiUrl}/v1/chat/completions`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiKey}`
        },
        body: JSON.stringify({
          model: this.settings.selectedLLMModel,
          messages,
          tools: [{ "type": "function", "function": functions[0] }],
          tool_choice: { "type": "function", "function": { "name": "assign_points" } }
        })
      });
      if (!response.ok) {
        throw new Error(`API error: ${response.status} - ${await response.text()}`);
      }
      const data = await response.json();
      if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.tool_calls && data.choices[0].message.tool_calls[0]) {
        const toolCall = data.choices[0].message.tool_calls[0];
        const functionArgs = JSON.parse(toolCall.function.arguments);
        if (functionArgs.difficulty_assessment === "very_hard" && this.statCardData.stats.highestDifficulty < 4) {
          this.statCardData.stats.highestDifficulty = 4;
        } else if (functionArgs.difficulty_assessment === "hard" && this.statCardData.stats.highestDifficulty < 3) {
          this.statCardData.stats.highestDifficulty = 3;
        } else if (functionArgs.difficulty_assessment === "medium" && this.statCardData.stats.highestDifficulty < 2) {
          this.statCardData.stats.highestDifficulty = 2;
        } else if (functionArgs.difficulty_assessment === "easy" && this.statCardData.stats.highestDifficulty < 1) {
          this.statCardData.stats.highestDifficulty = 1;
        }
        return Math.round(functionArgs.points);
      }
      throw new Error("Could not extract points from LLM response");
    } catch (error) {
      console.error("Error calling LLM:", error);
      throw error;
    }
  }
  checkForLevelUp() {
    while (this.statCardData.xp >= this.statCardData.nextLevelXp) {
      this.statCardData.xp -= this.statCardData.nextLevelXp;
      this.statCardData.level++;
      this.statCardData.nextLevelXp = Math.round(this.statCardData.nextLevelXp * (1.1 + this.statCardData.level * 0.05));
      new import_obsidian5.Notice(`Congratulations! You reached level ${this.statCardData.level}!`);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async loadStatCardData() {
    try {
      const dataFile = this.app.vault.getAbstractFileByPath("VQ/data.json");
      if (dataFile instanceof import_obsidian5.TFile) {
        const content = await this.app.vault.read(dataFile);
        const parsedData = JSON.parse(content);
        this.statCardData = parsedData.statCardData || parsedData;
      } else {
        this.initializeDefaultStatCardData();
        await this.saveStatCardData();
      }
    } catch (error) {
      console.error("Error loading user data:", error);
      this.initializeDefaultStatCardData();
    }
  }
  initializeDefaultStatCardData() {
    this.statCardData = {
      xp: 0,
      level: 1,
      points: 0,
      nextLevelXp: 100,
      skills: [
        {
          id: "writing",
          name: "Writing",
          level: 1,
          xp: 0
        },
        {
          id: "research",
          name: "Research",
          level: 1,
          xp: 0
        },
        {
          id: "organization",
          name: "Organization",
          level: 1,
          xp: 0
        }
      ],
      items: [],
      achievements: [],
      titles: [],
      stats: {
        tasksCompleted: 0,
        totalPointsEarned: 0,
        highestDifficulty: 0,
        tasksUnchecked: 0,
        totalPointsDeducted: 0,
        lastFileCount: 0,
        lastFolderCount: 0
      },
      ownedItems: [],
      activeEffects: {}
    };
  }
  async saveStatCardData() {
    try {
      const data = JSON.stringify({
        statCardData: this.statCardData
      }, null, 2);
      const dataFile = this.app.vault.getAbstractFileByPath("VQ/data.json");
      if (dataFile instanceof import_obsidian5.TFile) {
        await this.app.vault.modify(dataFile, data);
      } else {
        await this.app.vault.create("VQ/data.json", data);
      }
    } catch (error) {
      console.error("Error saving user data:", error);
      new import_obsidian5.Notice("Error saving progress data.");
    }
  }
  async fetchAvailableModels() {
    try {
      const response = await fetch(`${this.settings.apiUrl}/v1/models`, {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.apiKey}`
        }
      });
      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }
      const data = await response.json();
      return data.data || [];
    } catch (error) {
      console.error("Error fetching models:", error);
      return [];
    }
  }
  async testConnection() {
    try {
      const response = await fetch(`${this.settings.apiUrl}/v1/models`, {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.apiKey}`
        }
      });
      return response.ok;
    } catch (error) {
      console.error("Error testing connection:", error);
      return false;
    }
  }
};
var GamifySettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  hasSystemControlAccess() {
    return this.plugin.statCardData && this.plugin.statCardData.ownedItems && this.plugin.statCardData.ownedItems.includes("system_control");
  }
  async display() {
    var _a, _b;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Tracked Notes" });
    const trackedNotesContainer = containerEl.createDiv();
    if (this.plugin.settings.trackedNotes.length === 0) {
      trackedNotesContainer.createEl("p", {
        text: 'No notes are currently being tracked. Use the "Track Current Note for Tasks" command to start tracking notes.'
      });
    } else {
      const ul = trackedNotesContainer.createEl("ul");
      this.plugin.settings.trackedNotes.forEach((path) => {
        const li = ul.createEl("li");
        li.createEl("span", { text: path });
        const removeButton = li.createEl("button", {
          text: "Remove",
          cls: "gamify-remove-btn"
        });
        removeButton.style.marginLeft = "10px";
        removeButton.addEventListener("click", async () => {
          this.plugin.settings.trackedNotes = this.plugin.settings.trackedNotes.filter((p) => p !== path);
          await this.plugin.saveSettings();
          this.display();
        });
      });
    }
    containerEl.createEl("h2", { text: "XP/Point Modifier" });
    if (!this.hasSystemControlAccess()) {
      const notice = containerEl.createEl("div", {
        cls: "setting-item-description",
        text: "You do not have permission to modify this settings."
      });
      notice.style.color = "var(--text-error)";
      notice.style.marginBottom = "1em";
    }
    new import_obsidian5.Setting(containerEl).setName("XP per character").setDesc("How much XP is earned for each character typed.").addText((text) => {
      text.setValue(this.plugin.settings.xpPerCharacter.toString());
      if (!this.hasSystemControlAccess()) {
        text.setDisabled(true);
        text.inputEl.title = "Permission Required.";
      } else {
        text.onChange(async (value) => {
          this.plugin.settings.xpPerCharacter = parseFloat(value) || 0.1;
          await this.plugin.saveSettings();
        });
      }
    });
    new import_obsidian5.Setting(containerEl).setName("Base points value").setDesc("Base points awarded for completing a task.").addText((text) => {
      text.setValue(this.plugin.settings.pointsBaseValue.toString());
      if (!this.hasSystemControlAccess()) {
        text.setDisabled(true);
        text.inputEl.title = "Permission Required.";
      } else {
        text.onChange(async (value) => {
          this.plugin.settings.pointsBaseValue = parseInt(value) || 10;
          await this.plugin.saveSettings();
        });
      }
    });
    containerEl.createEl("h2", { text: "Tag Multipliers" });
    if (!this.hasSystemControlAccess()) {
      const notice = containerEl.createEl("div", {
        cls: "setting-item-description",
        text: "You do not have permission to modify this settings."
      });
      notice.style.color = "var(--text-error)";
      notice.style.marginBottom = "1em";
    }
    Object.entries(this.plugin.settings.tagMultipliers).forEach(([tag, multiplier]) => {
      const setting = new import_obsidian5.Setting(containerEl).setName(`Multiplier for ${tag}`).setDesc(`Multiplier for tasks with the ${tag} tag.`).addText((text) => {
        text.setValue(multiplier.toString());
        if (!this.hasSystemControlAccess()) {
          text.setDisabled(true);
          text.inputEl.title = "Permission Required.";
        } else {
          text.onChange(async (value) => {
            this.plugin.settings.tagMultipliers[tag] = parseFloat(value) || 1;
            await this.plugin.saveSettings();
          });
        }
      });
      if (this.hasSystemControlAccess()) {
        setting.addButton((button) => button.setButtonText("Remove").onClick(async () => {
          delete this.plugin.settings.tagMultipliers[tag];
          await this.plugin.saveSettings();
          this.display();
        }));
      }
    });
    if (this.hasSystemControlAccess()) {
      const newTagSetting = new import_obsidian5.Setting(containerEl).setName("Add new tag multiplier").setDesc("Add a new tag and its point multiplier.");
      let newTagInput = null;
      let newMultiplierInput = null;
      newTagSetting.addText((text) => {
        text.setPlaceholder("#tag");
        text.setValue("");
        newTagInput = text.inputEl;
      });
      newTagSetting.addText((text) => {
        text.setPlaceholder("multiplier");
        text.setValue("1.0");
        newMultiplierInput = text.inputEl;
      });
      newTagSetting.addButton((button) => button.setButtonText("Add").onClick(async () => {
        if (newTagInput && newMultiplierInput) {
          const tag = newTagInput.value;
          const multiplier = parseFloat(newMultiplierInput.value) || 1;
          if (tag && tag.startsWith("#")) {
            this.plugin.settings.tagMultipliers[tag] = multiplier;
            await this.plugin.saveSettings();
            this.display();
          }
        }
      }));
    }
    containerEl.createEl("h2", { text: "Task Assessment" });
    new import_obsidian5.Setting(containerEl).setName("Scan Completed Tasks").setDesc("Find and assess all completed tasks that have not been logged.").addButton((button) => button.setButtonText("Scan Completed").onClick(async () => {
      await this.plugin.taskAssessmentService.assessCompletedTasks();
    }));
    new import_obsidian5.Setting(containerEl).setName("Scan Interval (minutes)").setDesc("Set how often completed tasks are scanned.").addDropdown((dropdown) => {
      ["1", "5", "10", "15", "30", "60"].forEach((value) => {
        dropdown.addOption(value, `${value} minutes`);
      });
      dropdown.setValue(this.plugin.settings.scanInterval.toString());
      dropdown.onChange(async (value) => {
        this.plugin.settings.scanInterval = parseInt(value);
        await this.plugin.saveSettings();
        this.plugin.startPeriodicScanning();
      });
    });
    new import_obsidian5.Setting(containerEl).setName("Deduct Points for Unchecking Tasks").setDesc("When a completed task is unchecked, deduct the awarded points.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.deductPointsForUnchecking);
      if (!this.hasSystemControlAccess()) {
        toggle.setDisabled(true);
        toggle.toggleEl.title = "Permission Required.";
      } else {
        toggle.onChange(async (value) => {
          this.plugin.settings.deductPointsForUnchecking = value;
          await this.plugin.saveSettings();
        });
      }
    });
    containerEl.createEl("h2", { text: "Rate Limiting" });
    new import_obsidian5.Setting(containerEl).setName("Enable Rate Limiting").setDesc("Limit the rate of requests to the LLM API to avoid issues.").addToggle((toggle) => toggle.setValue(this.plugin.settings.rateLimiting.enabled).onChange(async (value) => {
      this.plugin.settings.rateLimiting.enabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Requests Per Minute").setDesc("Maximum number of requests to send per minute (1-60).").addSlider((slider) => slider.setLimits(1, 60, 1).setValue(this.plugin.settings.rateLimiting.requestsPerMinute).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.rateLimiting.requestsPerMinute = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "LLM API" });
    new import_obsidian5.Setting(containerEl).setName("API URL").setDesc("URL of your local LLM API.").addText((text) => text.setValue(this.plugin.settings.apiUrl).onChange(async (value) => {
      this.plugin.settings.apiUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("API Key").setDesc("API key for authentication (if required).").addText((text) => text.setValue(this.plugin.settings.apiKey).setPlaceholder("your-api-key").onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Test Connection").setDesc("Test the connection to your LLM API.").addButton((button) => button.setButtonText("Test Connection").onClick(async () => {
      const connectionTest = await this.plugin.testConnection();
      if (connectionTest) {
        new import_obsidian5.Notice("Connection successful!");
        const models = await this.plugin.fetchAvailableModels();
        this.plugin.availableModels = models;
        this.updateModelDropdown();
      } else {
        new import_obsidian5.Notice("Connection failed. Please check your API URL and key.");
      }
    }));
    const modelSetting = new import_obsidian5.Setting(containerEl).setName("LLM Model").setDesc("Select which LLM model to use for task assessment.");
    this.modelDropdown = document.createElement("select");
    this.modelDropdown.classList.add("dropdown");
    this.modelDropdown.value = this.plugin.settings.selectedLLMModel;
    this.modelDropdown.addEventListener("change", async () => {
      this.plugin.settings.selectedLLMModel = this.modelDropdown.value;
      await this.plugin.saveSettings();
    });
    const defaultOption = document.createElement("option");
    defaultOption.value = this.plugin.settings.selectedLLMModel;
    defaultOption.text = this.plugin.settings.selectedLLMModel;
    this.modelDropdown.appendChild(defaultOption);
    try {
      const models = await this.plugin.fetchAvailableModels();
      if (models && models.length > 0) {
        this.plugin.availableModels = models;
        this.updateModelDropdown();
      }
    } catch (error) {
      console.error("Error loading models:", error);
    }
    modelSetting.controlEl.appendChild(this.modelDropdown);
    containerEl.createEl("h2", { text: "Progress" });
    if (this.plugin.statCardData) {
      const progressDiv = containerEl.createDiv();
      progressDiv.innerHTML = `
				<div style="padding: 10px; border: 1px solid var(--background-modifier-border); border-radius: 5px; margin-bottom: 20px;">
					<p><strong>Level:</strong> ${this.plugin.statCardData.level || 1}</p>
					<p><strong>XP:</strong> ${Math.floor(this.plugin.statCardData.xp || 0)} / ${this.plugin.statCardData.nextLevelXp || 100}</p>
					<p><strong>Points:</strong> ${this.plugin.statCardData.points || 0}</p>
					<p><strong>Tasks Completed:</strong> ${((_b = (_a = this.plugin.statCardData) == null ? void 0 : _a.stats) == null ? void 0 : _b.tasksCompleted) || 0}</p>
				</div>
			`;
    } else {
      containerEl.createEl("p", {
        text: "Progress data not available. Please initialize the plugin first."
      });
    }
    new import_obsidian5.Setting(containerEl).setName("Reset Completed Tasks").setDesc("Clear the list of completed tasks.").addButton((button) => {
      button.setButtonText("Reset Task Completion Count").setWarning();
      if (!this.hasSystemControlAccess()) {
        button.setDisabled(true);
        button.buttonEl.title = "Permission Required.";
      } else {
        button.onClick(async () => {
          if (this.plugin.statCardData && this.plugin.statCardData.stats) {
            const confirm2 = await new Promise((resolve) => {
              const modal = new ConfirmationModal(
                this.app,
                "Reset Completed Tasks",
                "Are you sure you want to reset completed tasks? This cannot be undone!",
                resolve
              );
              modal.open();
            });
            if (confirm2) {
              this.plugin.statCardData.stats.tasksCompleted = 0;
              await this.plugin.saveStatCardData();
              this.display();
              new import_obsidian5.Notice("Task completion history has been reset.");
            }
          } else {
            new import_obsidian5.Notice("Stats data not available.");
          }
        });
      }
    });
    new import_obsidian5.Setting(containerEl).setName("Reset Progress").setDesc("Warning: This will reset all your progress!").addButton((button) => button.setButtonText("Reset All Progress").setWarning().onClick(async () => {
      const confirm2 = await new Promise((resolve) => {
        const modal = new ConfirmationModal(
          this.app,
          "Reset Progress",
          "Are you sure you want to reset all progress? This cannot be undone!",
          resolve
        );
        modal.open();
      });
      if (confirm2) {
        this.plugin.initializeDefaultStatCardData();
        await this.plugin.saveStatCardData();
        this.display();
        new import_obsidian5.Notice("All progress has been reset.");
      }
    }));
  }
  updateModelDropdown() {
    if (!this.modelDropdown) return;
    while (this.modelDropdown.firstChild) {
      this.modelDropdown.removeChild(this.modelDropdown.firstChild);
    }
    if (this.plugin.availableModels && this.plugin.availableModels.length > 0) {
      this.plugin.availableModels.forEach((model) => {
        const option = document.createElement("option");
        option.value = model.id;
        option.text = model.id;
        if (model.id === this.plugin.settings.selectedLLMModel) {
          option.selected = true;
        }
        this.modelDropdown.appendChild(option);
      });
      if (!this.plugin.availableModels.some((m) => m.id === this.plugin.settings.selectedLLMModel)) {
        const option = document.createElement("option");
        option.value = this.plugin.settings.selectedLLMModel;
        option.text = this.plugin.settings.selectedLLMModel + " (not found)";
        option.selected = true;
        this.modelDropdown.appendChild(option);
      }
    } else {
      const option = document.createElement("option");
      option.value = this.plugin.settings.selectedLLMModel;
      option.text = this.plugin.settings.selectedLLMModel;
      this.modelDropdown.appendChild(option);
    }
  }
};
var SelectNoteModal = class extends import_obsidian5.Modal {
  constructor(app, options, onSelect) {
    super(app);
    this.options = options;
    this.onSelect = onSelect;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Select Note to Untrack" });
    const ul = contentEl.createEl("ul", { cls: "gamify-modal-list" });
    this.options.forEach((option) => {
      const li = ul.createEl("li");
      li.textContent = option;
      li.addEventListener("click", () => {
        this.onSelect(option);
        this.close();
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ConfirmationModal = class extends import_obsidian5.Modal {
  constructor(app, title, message, result) {
    super(app);
    this.result = result;
    this.message = message;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Confirmation" });
    contentEl.createEl("p", { text: this.message });
    const buttonContainer = contentEl.createDiv();
    buttonContainer.addClass("modal-button-container");
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.result(false);
      this.close();
    });
    const confirmButton = buttonContainer.createEl("button", { text: "Confirm" });
    confirmButton.addClass("mod-warning");
    confirmButton.addEventListener("click", () => {
      this.result(true);
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
