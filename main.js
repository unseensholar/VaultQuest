/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GamifyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// services.ts
var import_obsidian = require("obsidian");
var StatCardService = class {
  constructor(plugin) {
    this.statusBarItem = null;
    this.plugin = plugin;
  }
  initializeUI() {
    this.plugin.addRibbonIcon("shield", "Open Grimoire", (evt) => {
      new StatCardModal(this.plugin.app, this.plugin).open();
    });
    this.statusBarItem = this.plugin.addStatusBarItem();
    this.updateStatusBar();
  }
  updateStatusBar() {
    if (this.statusBarItem) {
      this.statusBarItem.setText(
        `XP: ${Math.floor(this.plugin.statCardData.xp)} | Level: ${this.plugin.statCardData.level} | Points: ${this.plugin.statCardData.points} | Tasks Completed: ${this.plugin.statCardData.stats.tasksCompleted}`
      );
    }
  }
  refreshUI() {
    this.updateStatusBar();
  }
};
var LLMTaskService = class {
  constructor(plugin) {
    this.keyPressCount = 0;
    this.lastFileCount = 0;
    this.lastFolderCount = 0;
    this.plugin = plugin;
    this.keyboardListener = this.handleKeyPress.bind(this);
    document.addEventListener("keydown", this.keyboardListener);
    this.updateFileFolderCounts();
    setInterval(() => this.updateFileFolderCounts(), 6e4 * 5);
  }
  // Handle keyboard events to track writing skill
  handleKeyPress(e) {
    if (e.key.length === 1 || e.key === "Backspace" || e.key === "Delete" || e.key === "Enter") {
      this.keyPressCount++;
      if (this.keyPressCount >= 50) {
        this.updateWritingSkill(this.keyPressCount);
        this.keyPressCount = 0;
      }
    }
  }
  // Count files and folders in the vault
  async updateFileFolderCounts() {
    const vault = this.plugin.app.vault;
    const allFiles = vault.getFiles();
    const fileCount = allFiles.length;
    const folders = /* @__PURE__ */ new Set();
    allFiles.forEach((file) => {
      var _a;
      const parentPath = (_a = file.parent) == null ? void 0 : _a.path;
      if (parentPath && parentPath !== "/") {
        folders.add(parentPath);
      }
    });
    const folderCount = folders.size;
    if (fileCount !== this.lastFileCount) {
      this.updateResearchSkill(fileCount);
      this.lastFileCount = fileCount;
    }
    if (folderCount !== this.lastFolderCount) {
      this.updateOrganizationSkill(folderCount);
      this.lastFolderCount = folderCount;
    }
  }
  // Update writing skill based on keyboard activity
  updateWritingSkill(keyCount) {
    const skill = this.plugin.statCardData.skills.find((s) => s.id === "writing");
    if (skill) {
      const xpGain = Math.floor(keyCount / 10);
      this.updateSkill(skill, xpGain);
    }
  }
  // Update research skill based on file count
  updateResearchSkill(fileCount) {
    const skill = this.plugin.statCardData.skills.find((s) => s.id === "research");
    if (skill) {
      const xpGain = Math.floor(fileCount / 20);
      this.updateSkill(skill, xpGain);
    }
  }
  // Update organization skill based on folder count
  updateOrganizationSkill(folderCount) {
    const skill = this.plugin.statCardData.skills.find((s) => s.id === "organization");
    if (skill) {
      const xpGain = Math.floor(folderCount / 5);
      this.updateSkill(skill, xpGain);
    }
  }
  // Common skill update logic
  updateSkill(skill, xpAmount) {
    if (xpAmount <= 0) return;
    skill.xp += xpAmount;
    const nextLevel = skill.level + 1;
    const xpForNextLevel = nextLevel * 25;
    if (skill.xp >= xpForNextLevel) {
      skill.level = nextLevel;
      skill.xp = 0;
      new import_obsidian.Notice(`Your ${skill.name} skill has increased to level ${skill.level}!`);
      this.plugin.statCardData.points += nextLevel * 2;
      this.plugin.saveStatCardData();
    }
  }
  async executeTask(instruction) {
    const pointsCost = await this.determineTaskCost(instruction);
    if (this.plugin.statCardData.points < pointsCost) {
      throw new Error(`Not enough points. You need ${pointsCost} points to perform this action.`);
    }
    try {
      this.plugin.statCardData.points -= pointsCost;
      await this.plugin.saveStatCardData();
      const functions = [
        {
          "name": "perform_task",
          "description": "Perform a task requested by the user",
          "parameters": {
            "type": "object",
            "properties": {
              "result": {
                "type": "string",
                "description": "The result of the task execution"
              },
              "task_type": {
                "type": "string",
                "enum": ["answer", "code_execution", "analysis", "creative"],
                "description": "The type of task performed"
              },
              "title": {
                "type": "string",
                "description": "A short title describing the task result"
              }
            },
            "required": ["result"]
          }
        }
      ];
      const messages = [
        {
          "role": "system",
          "content": "You are a powerful demonic entity that performs tasks for mortals who have spent their precious life force (points) to access your dark powers. You speak with a sinister, otherworldly tone and occasionally remind users of the price they've paid. You can answer questions, run simple code (by explaining the code and providing the expected output), analyze data, or provide creative content. Respond in markdown format when appropriate."
        },
        {
          "role": "user",
          "content": `I'd like you to perform this task: ${instruction}`
        }
      ];
      const response = await fetch(`${this.plugin.settings.apiUrl}/v1/chat/completions`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.plugin.settings.apiKey}`
        },
        body: JSON.stringify({
          model: "local-model",
          messages,
          tools: [{ "type": "function", "function": functions[0] }],
          tool_choice: { "type": "function", "function": { "name": "perform_task" } }
        })
      });
      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }
      const data = await response.json();
      if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.tool_calls && data.choices[0].message.tool_calls[0]) {
        const toolCall = data.choices[0].message.tool_calls[0];
        const functionArgs = JSON.parse(toolCall.function.arguments);
        await this.saveResultToVault(functionArgs.result, functionArgs.title, pointsCost);
        return functionArgs.result;
      }
      throw new Error("Could not extract result from LLM response");
    } catch (error) {
      console.error("Error executing LLM task:", error);
      this.plugin.statCardData.points += pointsCost;
      await this.plugin.saveStatCardData();
      throw error;
    }
  }
  async determineTaskCost(instruction) {
    try {
      const functions = [
        {
          "name": "determine_cost",
          "description": "Determine the point cost for executing a task based on complexity",
          "parameters": {
            "type": "object",
            "properties": {
              "points": {
                "type": "number",
                "description": "The number of points required for the task"
              },
              "reasoning": {
                "type": "string",
                "description": "Explanation of how points were calculated"
              },
              "complexity": {
                "type": "string",
                "enum": ["trivial", "simple", "moderate", "complex", "extreme"],
                "description": "Assessment of the task's complexity"
              }
            },
            "required": ["points", "reasoning", "complexity"]
          }
        }
      ];
      const messages = [
        {
          "role": "system",
          "content": "You are a demonic gatekeeper determining the cost for tasks. Assign points based on complexity: trivial (1-5 points), simple (5-10 points), moderate (10-30 points), complex (30-50 points), extreme (50-1000 points). Be fair but slightly menacing in your assessment."
        },
        {
          "role": "user",
          "content": `I request your dark powers for this task: "${instruction}". What is the cost?`
        }
      ];
      const response = await fetch(`${this.plugin.settings.apiUrl}/v1/chat/completions`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.plugin.settings.apiKey}`
        },
        body: JSON.stringify({
          model: "local-model",
          messages,
          tools: [{ "type": "function", "function": functions[0] }],
          tool_choice: { "type": "function", "function": { "name": "determine_cost" } }
        })
      });
      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }
      const data = await response.json();
      if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.tool_calls && data.choices[0].message.tool_calls[0]) {
        const toolCall = data.choices[0].message.tool_calls[0];
        const functionArgs = JSON.parse(toolCall.function.arguments);
        return Math.round(functionArgs.points);
      }
      throw new Error("Could not determine task cost");
    } catch (error) {
      console.error("Error determining task cost:", error);
      return 10;
    }
  }
  async saveResultToVault(content, title, pointsCost) {
    try {
      const folderPath = "VQ";
      const folder = this.plugin.app.vault.getAbstractFileByPath(folderPath);
      if (!folder) {
        await this.plugin.app.vault.createFolder(folderPath);
      }
      const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[-:.TZ]/g, "");
      const randomStr = Math.random().toString(36).substring(2, 8);
      const safeTitle = title.replace(/[^a-zA-Z0-9]/g, "_").substring(0, 20);
      const filename = `${folderPath}/${timestamp}_${safeTitle}_${randomStr}.md`;
      const fileContent = `---
title: ${title}
created: ${(/* @__PURE__ */ new Date()).toISOString()}
points_cost: ${pointsCost}
---

# ${title}

${content} 

*the portal closes....*
`;
      await this.plugin.app.vault.create(filename, fileContent);
      new import_obsidian.Notice(`Task result saved to ${filename}`);
    } catch (error) {
      console.error("Error saving result to vault:", error);
      new import_obsidian.Notice("Error saving task result to vault.");
    }
  }
  destroy() {
    document.removeEventListener("keydown", this.keyboardListener);
  }
};
var RedeemTaskModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.instruction = "";
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Summon Demonic Powers" });
    contentEl.createEl("p", {
      text: `Points Available: ${this.plugin.statCardData.points}`
    });
    contentEl.createEl("label", { text: "What do you wish to request from the darkness?" });
    const instructionInput = new import_obsidian.TextComponent(contentEl).setPlaceholder('e.g., "Write a blood-curdling tale of cosmic horror"').onChange((value) => {
      this.instruction = value;
    });
    const inputEl = instructionInput.inputEl;
    inputEl.style.width = "100%";
    inputEl.style.height = "100px";
    const buttonContainer = contentEl.createDiv({ cls: "redeem-buttons" });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Flee").onClick(() => {
      this.close();
      new StatCardModal(this.app, this.plugin).open();
    });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Summon").setCta().onClick(async () => {
      if (!this.instruction) {
        new import_obsidian.Notice("You must specify your desire.");
        return;
      }
      try {
        this.close();
        new import_obsidian.Notice("Summoning demonic powers...");
        const llmService = new LLMTaskService(this.plugin);
        const cost = await llmService.determineTaskCost(this.instruction);
        if (this.plugin.statCardData.points < cost) {
          new import_obsidian.Notice(`Not enough points. You need ${cost} points to perform this action.`);
          new StatCardModal(this.app, this.plugin).open();
          return;
        }
        const result = await llmService.executeTask(this.instruction);
        if (this.plugin.statCardService) {
          this.plugin.statCardService.refreshUI();
        }
        const resultModal = new TaskResultModal(this.app, this.plugin, result);
        resultModal.open();
      } catch (error) {
        console.error("Error executing task:", error);
        new import_obsidian.Notice(`The summoning failed. ${error.message}`);
        new StatCardModal(this.app, this.plugin).open();
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var TaskResultModal = class extends import_obsidian.Modal {
  constructor(app, plugin, result) {
    super(app);
    this.plugin = plugin;
    this.result = result;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Dark Powers Response" });
    const resultContainer = contentEl.createDiv({ cls: "task-result-container" });
    resultContainer.style.maxHeight = "400px";
    resultContainer.style.overflow = "auto";
    resultContainer.style.padding = "10px";
    resultContainer.style.border = "1px solid var(--background-modifier-border)";
    resultContainer.style.margin = "10px 0";
    const MarkdownIt = window.markdownit;
    if (MarkdownIt) {
      const md = new MarkdownIt();
      resultContainer.innerHTML = md.render(this.result);
    } else {
      resultContainer.innerHTML = this.result.replace(/\n/g, "<br>");
    }
    const buttonContainer = contentEl.createDiv({ cls: "task-result-buttons" });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Return to Stat Card").onClick(() => {
      this.close();
      new StatCardModal(this.app, this.plugin).open();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var StatCardModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gamify-stat-card-modal");
    contentEl.createEl("h2", { text: "Grimoire", cls: "gamify-modal-title" });
    const statsContainer = contentEl.createDiv({ cls: "gamify-stats-container" });
    statsContainer.createEl("h3", { text: `Level ${this.plugin.statCardData.level} Soul Binder`, cls: "gamify-stats-heading" });
    const xpBar = statsContainer.createDiv({ cls: "gamify-xp-bar" });
    const fillPercentage = Math.min(100, this.plugin.statCardData.xp / this.plugin.statCardData.nextLevelXp * 100);
    const xpBarFill = xpBar.createDiv({ cls: "gamify-xp-bar-fill" });
    xpBarFill.style.width = `${fillPercentage}%`;
    statsContainer.createEl("div", {
      text: `Soul Energy: ${Math.floor(this.plugin.statCardData.xp)}/${this.plugin.statCardData.nextLevelXp}`,
      cls: "gamify-stat-item"
    });
    statsContainer.createEl("div", {
      text: `Demonic Tokens: ${this.plugin.statCardData.points}`,
      cls: "gamify-stat-item"
    });
    const statsSection = contentEl.createDiv({ cls: "gamify-stats-details" });
    statsSection.createEl("h3", { text: "Pact Details", cls: "gamify-section-heading" });
    statsSection.createEl("div", {
      text: `Rituals Completed: ${this.plugin.statCardData.stats.tasksCompleted}`,
      cls: "gamify-stat-item"
    });
    statsSection.createEl("div", {
      text: `Total Tokens Earned: ${this.plugin.statCardData.stats.totalPointsEarned}`,
      cls: "gamify-stat-item"
    });
    const skillsSection = contentEl.createDiv({ cls: "gamify-skills-section" });
    skillsSection.createEl("h3", { text: "Skills", cls: "gamify-section-heading" });
    const skillsList = skillsSection.createEl("ul", { cls: "gamify-skills-list" });
    for (const skill of this.plugin.statCardData.skills) {
      skillsList.createEl("li", {
        text: `${skill.name}: Level ${skill.level}`,
        cls: "gamify-skill-item"
      });
    }
    const redeemSection = contentEl.createDiv({ cls: "gamify-redeem-section" });
    redeemSection.createEl("h3", { text: "Summon Dark Powers", cls: "gamify-section-heading" });
    const redeemButton = new import_obsidian.ButtonComponent(redeemSection).setButtonText("Make a Demonic Request").onClick(() => {
      this.close();
      new RedeemTaskModal(this.app, this.plugin).open();
    });
    const buttonEl = redeemButton.buttonEl;
    buttonEl.addClass("gamify-summon-button");
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  xpPerCharacter: 0.1,
  pointsBaseValue: 10,
  tagMultipliers: {
    "#easy": 0.5,
    "#medium": 1,
    "#hard": 2,
    "#veryhard": 5
  },
  apiUrl: "http://196.168.10.1:1234",
  apiKey: "your-api-key",
  trackedNotes: [],
  removeTagOnUncheck: true
};
var GamifyPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.processedTasks = [];
  }
  loadStyles() {
    const styleEl = document.createElement("style");
    styleEl.id = "gamify-styles";
    styleEl.textContent = this.getStyles();
    document.head.appendChild(styleEl);
  }
  getStyles() {
    return `
		/* Base styles for the modal */
		.gamify-stat-card-modal {
			background-color: var(--background-primary);
			color: var(--text-normal);
			padding: 1rem;
		}

		/* Title styling */
		.gamify-modal-title {
			color: var(--text-accent);
			margin-bottom: 1rem;
			text-align: center;
			font-size: 1.8rem;
		}

		/* Section headings */
		.gamify-section-heading {
			color: var(--text-accent);
			margin: 1rem 0 0.5rem;
			font-size: 1.4rem;
		}

		/* Stats containers */
		.gamify-stats-container,
		.gamify-stats-details,
		.gamify-skills-section,
		.gamify-redeem-section {
			margin-bottom: 1.5rem;
			padding: 0.75rem;
			border-radius: 4px;
			background-color: var(--background-secondary);
		}

		/* XP Bar styling */
		.gamify-xp-bar {
			height: 10px;
			background-color: var(--background-modifier-border);
			border-radius: 5px;
			margin: 0.5rem 0;
			overflow: hidden;
		}

		.gamify-xp-bar-fill {
			height: 100%;
			background-color: var(--text-accent);
			border-radius: 5px;
			transition: width 0.3s ease-in-out;
		}

		/* Stat items */
		.gamify-stat-item {
			margin: 0.25rem 0;
			font-size: 0.9rem;
		}

		/* Skills list */
		.gamify-skills-list {
			margin: 0.5rem 0;
			padding-left: 1.5rem;
		}

		.gamify-skill-item {
			margin: 0.25rem 0;
		}

		/* Button styling */
		.gamify-summon-button {
			background-color: var(--interactive-accent);
			color: var(--text-on-accent);
			border: 1px solid var(--interactive-accent-hover);
		}

		.gamify-summon-button:hover {
			background-color: var(--interactive-accent-hover);
		}

		/* Task result container */
		.task-result-container {
			max-height: 400px;
			overflow: auto;
			padding: 10px;
			border: 1px solid var(--background-modifier-border);
			margin: 10px 0;
			background-color: var(--background-secondary);
		}
		`;
  }
  async onload() {
    this.app.workspace.onLayoutReady(async () => {
      await this.loadSettings();
      await this.loadStatCardData();
      await this.loadProcessedTasks();
      this.statCardService = new StatCardService(this);
      this.llmTaskService = new LLMTaskService(this);
      this.statCardService.initializeUI();
      this.statCardService.refreshUI();
      this.loadStyles();
      this.typing = {
        characterCount: 0,
        timeout: null
      };
      this.registerDomEvent(document, "keydown", (evt) => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
        if (view && this.isContentKey(evt)) {
          this.handleTyping();
        }
      });
      this.fileChangedEventRef = this.app.vault.on("modify", this.handleFileChanged.bind(this));
      this.addCommand({
        id: "track-current-note",
        name: "Track Current Note for Tasks",
        callback: () => this.trackCurrentNote()
      });
      this.addCommand({
        id: "untrack-note",
        name: "Remove Note from Task Tracking",
        callback: () => this.showUntrackNoteModal()
      });
      this.addCommand({
        id: "scan-tasks",
        name: "Scan for Completed Tasks",
        callback: () => this.scanAllTrackedNotes()
      });
      this.addSettingTab(new GamifySettingTab(this.app, this));
    });
  }
  onunload() {
    if (this.typing.timeout) {
      clearTimeout(this.typing.timeout);
      this.processTypingXp();
    }
    const styleEl = document.getElementById("gamify-styles");
    if (styleEl) styleEl.remove();
    this.app.vault.offref(this.fileChangedEventRef);
  }
  isContentKey(evt) {
    return !evt.ctrlKey && !evt.altKey && !evt.metaKey && evt.key.length === 1 && !evt.repeat;
  }
  handleTyping() {
    this.typing.characterCount++;
    if (this.typing.timeout) {
      clearTimeout(this.typing.timeout);
    }
    this.typing.timeout = setTimeout(() => {
      this.processTypingXp();
    }, 2e3);
  }
  processTypingXp() {
    const xpGained = this.typing.characterCount * this.settings.xpPerCharacter;
    this.statCardData.xp += xpGained;
    this.typing.characterCount = 0;
    this.typing.timeout = null;
    this.checkForLevelUp();
    this.saveStatCardData();
    this.statCardService.refreshUI();
  }
  async trackCurrentNote() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian2.Notice("No active file to track.");
      return;
    }
    const filePath = activeFile.path;
    if (!this.settings.trackedNotes.includes(filePath)) {
      this.settings.trackedNotes.push(filePath);
      await this.saveSettings();
      new import_obsidian2.Notice(`Now tracking "${activeFile.basename}" for tasks.`);
    } else {
      new import_obsidian2.Notice(`Already tracking "${activeFile.basename}".`);
    }
  }
  async showUntrackNoteModal() {
    if (this.settings.trackedNotes.length === 0) {
      new import_obsidian2.Notice("No notes are currently being tracked.");
      return;
    }
    const modal = new SelectNoteModal(
      this.app,
      this.settings.trackedNotes,
      async (selectedPath) => {
        this.settings.trackedNotes = this.settings.trackedNotes.filter((path) => path !== selectedPath);
        await this.saveSettings();
        new import_obsidian2.Notice(`Stopped tracking "${selectedPath.split("/").pop()}".`);
      }
    );
    modal.open();
  }
  async scanAllTrackedNotes() {
    if (this.settings.trackedNotes.length === 0) {
      new import_obsidian2.Notice('No notes are being tracked. Add notes using the "Track Current Note for Tasks" command.');
      return;
    }
    let tasksFound = 0;
    let newTasksCompleted = 0;
    for (const notePath of this.settings.trackedNotes) {
      const file = this.app.vault.getAbstractFileByPath(notePath);
      if (file instanceof import_obsidian2.TFile) {
        const content = await this.app.vault.read(file);
        const newTasks = await this.processCompletedTasksInNote(content, file.path);
        tasksFound += newTasks.tasksFound;
        newTasksCompleted += newTasks.newTasksCompleted;
      }
    }
    if (newTasksCompleted > 0) {
      new import_obsidian2.Notice(`Scan complete! Found ${tasksFound} completed tasks, ${newTasksCompleted} new.`);
    } else {
      new import_obsidian2.Notice(`Scan complete! Found ${tasksFound} completed tasks, all already processed.`);
    }
  }
  async handleFileChanged(file) {
    if (!(file instanceof import_obsidian2.TFile) || file.extension !== "md") {
      return;
    }
    if (this.settings.trackedNotes.includes(file.path)) {
      const content = await this.app.vault.read(file);
      await this.handleUncheckedTasks(content, file.path);
      const updatedContent = await this.app.vault.read(file);
      await this.processCompletedTasksInNote(updatedContent, file.path);
    }
  }
  async handleUncheckedTasks(content, filePath) {
    if (!this.settings.removeTagOnUncheck) return false;
    const uncheckedTaskRegex = /- \[\s*\]\s+(.*?)(#VQdone)(\s|$)/g;
    let hasChanges = false;
    let updatedContent = content;
    updatedContent = updatedContent.replace(uncheckedTaskRegex, (match, taskText, doneTag, ending) => {
      hasChanges = true;
      return `- [ ] ${taskText}${ending}`;
    });
    if (hasChanges) {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian2.TFile) {
        await this.app.vault.modify(file, updatedContent);
      }
    }
    return hasChanges;
  }
  async processCompletedTasksInNote(content, filePath) {
    const completedTaskRegex = /- \[x\]\s+((?:(?!#VQdone).)*?)(?:\n|$)/g;
    let match;
    let tasksFound = 0;
    let newTasksCompleted = 0;
    let updatedContent = content;
    while ((match = completedTaskRegex.exec(content)) !== null) {
      const taskText = match[1].trim();
      if (taskText.includes("#VQdone")) {
        continue;
      }
      tasksFound++;
      if (!this.isTaskProcessed(filePath, taskText)) {
        const tags = this.extractTags(taskText);
        const points = await this.calculatePointsForTask(taskText, tags);
        this.statCardData.points += points;
        this.statCardData.stats.tasksCompleted++;
        this.statCardData.stats.totalPointsEarned += points;
        this.addProcessedTask(filePath, taskText);
        newTasksCompleted++;
        const originalTask = `- [x] ${taskText}`;
        const taggedTask = `- [x] ${taskText} #VQdone`;
        updatedContent = updatedContent.replace(originalTask, taggedTask);
        await this.saveStatCardData();
        await this.saveProcessedTasks();
        this.statCardService.refreshUI();
        if (newTasksCompleted === 1) {
          new import_obsidian2.Notice(`Task completed! You earned ${points} points.`);
        }
      }
    }
    if (newTasksCompleted > 0) {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian2.TFile) {
        await this.app.vault.modify(file, updatedContent);
      }
    }
    return { tasksFound, newTasksCompleted };
  }
  isTaskProcessed(filePath, taskText) {
    return this.processedTasks.some((task) => task.filePath === filePath && task.taskText === taskText);
  }
  addProcessedTask(filePath, taskText) {
    this.processedTasks.push({
      filePath,
      taskText,
      completedOn: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  extractTags(text) {
    const tagRegex = /#[\w-]+/g;
    return text.match(tagRegex) || [];
  }
  async calculatePointsForTask(taskText, tags) {
    try {
      return await this.calculatePointsWithLLM(taskText, tags);
    } catch (error) {
      console.error("Error calculating points with LLM:", error);
      return this.calculateBasicPoints(tags);
    }
  }
  calculateBasicPoints(tags) {
    let multiplier = 1;
    for (const tag of tags) {
      if (this.settings.tagMultipliers[tag]) {
        multiplier = Math.max(multiplier, this.settings.tagMultipliers[tag]);
      }
    }
    return Math.round(this.settings.pointsBaseValue * multiplier);
  }
  async calculatePointsWithLLM(taskText, tags) {
    const functions = [
      {
        "name": "assign_points",
        "description": "Assign points to a completed task based on its difficulty",
        "parameters": {
          "type": "object",
          "properties": {
            "points": {
              "type": "number",
              "description": "The number of points to award for the task"
            },
            "reasoning": {
              "type": "string",
              "description": "Explanation of how points were calculated"
            },
            "difficulty_assessment": {
              "type": "string",
              "enum": ["easy", "medium", "hard", "very_hard"],
              "description": "Assessment of the task's difficulty"
            }
          },
          "required": ["points", "reasoning", "difficulty_assessment"]
        }
      }
    ];
    const messages = [
      {
        "role": "system",
        "content": "You are a task assessment system that assigns points to completed tasks based on their difficulty. For difficulty, consider the complexity of the task and any tags."
      },
      {
        "role": "user",
        "content": `I just completed this task: "${taskText}". Tags: ${tags.join(", ") || "None"}. Please assign appropriate points.`
      }
    ];
    try {
      const response = await fetch(`${this.settings.apiUrl}/v1/chat/completions`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiKey}`
        },
        body: JSON.stringify({
          model: "local-model",
          messages,
          tools: [{ "type": "function", "function": functions[0] }],
          tool_choice: { "type": "function", "function": { "name": "assign_points" } }
        })
      });
      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }
      const data = await response.json();
      if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.tool_calls && data.choices[0].message.tool_calls[0]) {
        const toolCall = data.choices[0].message.tool_calls[0];
        const functionArgs = JSON.parse(toolCall.function.arguments);
        if (functionArgs.difficulty_assessment === "very_hard" && this.statCardData.stats.highestDifficulty < 4) {
          this.statCardData.stats.highestDifficulty = 4;
        } else if (functionArgs.difficulty_assessment === "hard" && this.statCardData.stats.highestDifficulty < 3) {
          this.statCardData.stats.highestDifficulty = 3;
        } else if (functionArgs.difficulty_assessment === "medium" && this.statCardData.stats.highestDifficulty < 2) {
          this.statCardData.stats.highestDifficulty = 2;
        } else if (functionArgs.difficulty_assessment === "easy" && this.statCardData.stats.highestDifficulty < 1) {
          this.statCardData.stats.highestDifficulty = 1;
        }
        return Math.round(functionArgs.points);
      }
      throw new Error("Could not extract points from LLM response");
    } catch (error) {
      console.error("Error calling LLM:", error);
      throw error;
    }
  }
  checkForLevelUp() {
    while (this.statCardData.xp >= this.statCardData.nextLevelXp) {
      this.statCardData.xp -= this.statCardData.nextLevelXp;
      this.statCardData.level++;
      this.statCardData.nextLevelXp = Math.round(this.statCardData.nextLevelXp * 1.5);
      new import_obsidian2.Notice(`Congratulations! You reached level ${this.statCardData.level}!`);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async loadStatCardData() {
    try {
      const dataFile = this.app.vault.getAbstractFileByPath("VQ/data.json");
      if (dataFile instanceof import_obsidian2.TFile) {
        const content = await this.app.vault.read(dataFile);
        const parsedData = JSON.parse(content);
        this.statCardData = parsedData.statCardData || parsedData;
      } else {
        this.initializeDefaultStatCardData();
        await this.saveStatCardData();
      }
    } catch (error) {
      console.error("Error loading user data:", error);
      this.initializeDefaultStatCardData();
    }
  }
  initializeDefaultStatCardData() {
    this.statCardData = {
      xp: 0,
      level: 1,
      points: 0,
      nextLevelXp: 100,
      skills: [
        {
          id: "writing",
          name: "Writing",
          level: 1,
          xp: 0
        },
        {
          id: "research",
          name: "Research",
          level: 1,
          xp: 0
        },
        {
          id: "organization",
          name: "Organization",
          level: 1,
          xp: 0
        }
      ],
      items: [],
      achievements: [],
      stats: {
        tasksCompleted: 0,
        totalPointsEarned: 0,
        highestDifficulty: 0
      }
    };
  }
  async saveStatCardData() {
    try {
      const data = JSON.stringify({
        statCardData: this.statCardData
      }, null, 2);
      const dataFile = this.app.vault.getAbstractFileByPath("VQ/data.json");
      if (dataFile instanceof import_obsidian2.TFile) {
        await this.app.vault.modify(dataFile, data);
      } else {
        await this.app.vault.create("VQ/data.json", data);
      }
    } catch (error) {
      console.error("Error saving user data:", error);
      new import_obsidian2.Notice("Error saving progress data.");
    }
  }
  async loadProcessedTasks() {
    try {
      const folderPath = "VQ";
      const folder = this.app.vault.getAbstractFileByPath(folderPath);
      if (!folder) {
        await this.app.vault.createFolder(folderPath);
      }
      const tasksFile = this.app.vault.getAbstractFileByPath(`${folderPath}/tasks.json`);
      if (tasksFile instanceof import_obsidian2.TFile) {
        const content = await this.app.vault.read(tasksFile);
        this.processedTasks = JSON.parse(content);
      } else {
        this.processedTasks = [];
        await this.saveProcessedTasks();
      }
    } catch (error) {
      console.error("Error loading processed tasks:", error);
      this.processedTasks = [];
    }
  }
  async saveProcessedTasks() {
    try {
      const folderPath = "VQ";
      const data = "Disabled";
      const tasksFile = this.app.vault.getAbstractFileByPath(`${folderPath}/tasks.json`);
      if (tasksFile instanceof import_obsidian2.TFile) {
        await this.app.vault.modify(tasksFile, data);
      } else {
        const folder = this.app.vault.getAbstractFileByPath(folderPath);
        if (!folder) {
          await this.app.vault.createFolder(folderPath);
        }
        await this.app.vault.create(`${folderPath}/tasks.json`, data);
      }
    } catch (error) {
      console.error("Error saving processed tasks:", error);
    }
  }
};
var GamifySettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "XP/Point Modifier" });
    new import_obsidian2.Setting(containerEl).setName("XP per character").setDesc("How much XP is earned for each character typed.").addText((text) => text.setValue(this.plugin.settings.xpPerCharacter.toString()).onChange(async (value) => {
      this.plugin.settings.xpPerCharacter = parseFloat(value) || 0.1;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Base points value").setDesc("Base points awarded for completing a task.").addText((text) => text.setValue(this.plugin.settings.pointsBaseValue.toString()).onChange(async (value) => {
      this.plugin.settings.pointsBaseValue = parseInt(value) || 10;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "Tracked Notes" });
    const trackedNotesContainer = containerEl.createDiv();
    if (this.plugin.settings.trackedNotes.length === 0) {
      trackedNotesContainer.createEl("p", {
        text: 'No notes are currently being tracked. Use the "Track Current Note for Tasks" command to start tracking notes.'
      });
    } else {
      const ul = trackedNotesContainer.createEl("ul");
      this.plugin.settings.trackedNotes.forEach((path) => {
        const li = ul.createEl("li");
        li.createEl("span", { text: path });
        const removeButton = li.createEl("button", {
          text: "Remove",
          cls: "gamify-remove-btn"
        });
        removeButton.addEventListener("click", async () => {
          this.plugin.settings.trackedNotes = this.plugin.settings.trackedNotes.filter((p) => p !== path);
          await this.plugin.saveSettings();
          this.display();
        });
      });
    }
    containerEl.createEl("h2", { text: "Tag Multipliers" });
    Object.entries(this.plugin.settings.tagMultipliers).forEach(([tag, multiplier]) => {
      new import_obsidian2.Setting(containerEl).setName(`Multiplier for ${tag}`).setDesc(`Multiplier for tasks with the ${tag} tag.`).addText((text) => text.setValue(multiplier.toString()).onChange(async (value) => {
        this.plugin.settings.tagMultipliers[tag] = parseFloat(value) || 1;
        await this.plugin.saveSettings();
      })).addButton((button) => button.setButtonText("Remove").onClick(async () => {
        delete this.plugin.settings.tagMultipliers[tag];
        await this.plugin.saveSettings();
        this.display();
      }));
    });
    new import_obsidian2.Setting(containerEl).setName("Add new tag multiplier").setDesc("Add a new tag and its point multiplier.").addText((text) => text.setPlaceholder("#tag").setValue("")).addText((text) => text.setPlaceholder("multiplier").setValue("1.0")).addButton((button) => button.setButtonText("Add").onClick(async (evt) => {
      var _a, _b;
      const settingItem = evt.target;
      const inputs = (_b = (_a = settingItem.parentElement) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.querySelectorAll("input");
      if (inputs && inputs.length >= 2) {
        const tag = inputs[0].value;
        const multiplier = parseFloat(inputs[1].value) || 1;
        if (tag && tag.startsWith("#")) {
          this.plugin.settings.tagMultipliers[tag] = multiplier;
          await this.plugin.saveSettings();
          this.display();
        }
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Remove #VQdone tag on uncheck").setDesc("Automatically remove the #VQdone tag when a task is unchecked").addToggle((toggle) => toggle.setValue(this.plugin.settings.removeTagOnUncheck).onChange(async (value) => {
      this.plugin.settings.removeTagOnUncheck = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "LLM API" });
    new import_obsidian2.Setting(containerEl).setName("API URL").setDesc("URL of your local LLM API.").addText((text) => text.setValue(this.plugin.settings.apiUrl).onChange(async (value) => {
      this.plugin.settings.apiUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("API Key").setDesc("API key for authentication (if required).").addText((text) => text.setValue(this.plugin.settings.apiKey).setPlaceholder("your-api-key").onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "Progress" });
    const progressDiv = containerEl.createDiv();
    progressDiv.innerHTML = `
			<div style="padding: 10px; border: 1px solid var(--background-modifier-border); border-radius: 5px; margin-bottom: 20px;">
				<p><strong>Level:</strong> ${this.plugin.statCardData.level}</p>
				<p><strong>XP:</strong> ${Math.floor(this.plugin.statCardData.xp)} / ${this.plugin.statCardData.nextLevelXp}</p>
				<p><strong>Points:</strong> ${this.plugin.statCardData.points}</p>
				<p><strong>Tasks Completed:</strong> ${this.plugin.statCardData.stats.tasksCompleted}</p>
				<p><strong>Processed Tasks:</strong> ${this.plugin.processedTasks.length}</p>
			</div>
		`;
    new import_obsidian2.Setting(containerEl).setName("Reset Processed Tasks").setDesc("Clear the list of processed tasks (will allow re-earning points for completed tasks).").addButton((button) => button.setButtonText("Reset Task History").setWarning().onClick(async () => {
      this.plugin.processedTasks = [];
      await this.plugin.saveProcessedTasks();
      this.display();
      new import_obsidian2.Notice("Task history has been reset.");
    }));
    new import_obsidian2.Setting(containerEl).setName("Reset Progress").setDesc("Warning: This will reset all your progress!").addButton((button) => button.setButtonText("Reset All Progress").setWarning().onClick(async () => {
      const confirm = await new Promise((resolve) => {
        const modal = new ConfirmationModal(
          this.app,
          "Reset Progress",
          "Are you sure you want to reset all progress? This cannot be undone!",
          resolve
        );
        modal.open();
      });
      if (confirm) {
        this.plugin.initializeDefaultStatCardData();
        this.plugin.processedTasks = [];
        await this.plugin.saveStatCardData();
        await this.plugin.saveProcessedTasks();
        this.display();
        new import_obsidian2.Notice("All progress has been reset.");
      }
    }));
  }
};
var SelectNoteModal = class extends import_obsidian2.Modal {
  constructor(app, options, onSelect) {
    super(app);
    this.options = options;
    this.onSelect = onSelect;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Select Note to Untrack" });
    const ul = contentEl.createEl("ul", { cls: "gamify-modal-list" });
    this.options.forEach((option) => {
      const li = ul.createEl("li");
      li.textContent = option;
      li.addEventListener("click", () => {
        this.onSelect(option);
        this.close();
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ConfirmationModal = class extends import_obsidian2.Modal {
  constructor(app, title, message, result) {
    super(app);
    this.result = result;
    this.message = message;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Confirmation" });
    contentEl.createEl("p", { text: this.message });
    const buttonContainer = contentEl.createDiv();
    buttonContainer.addClass("modal-button-container");
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.result(false);
      this.close();
    });
    const confirmButton = buttonContainer.createEl("button", { text: "Confirm" });
    confirmButton.addClass("mod-warning");
    confirmButton.addEventListener("click", () => {
      this.result(true);
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
